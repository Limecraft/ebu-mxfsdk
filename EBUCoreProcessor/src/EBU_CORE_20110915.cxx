// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "EBU_CORE_20110915.hxx"

namespace ebuCore_2011
{
  // ebuCoreMainType
  // 

  const ebuCoreMainType::coreMetadata_type& ebuCoreMainType::
  coreMetadata () const
  {
    return this->coreMetadata_.get ();
  }

  ebuCoreMainType::coreMetadata_type& ebuCoreMainType::
  coreMetadata ()
  {
    return this->coreMetadata_.get ();
  }

  void ebuCoreMainType::
  coreMetadata (const coreMetadata_type& x)
  {
    this->coreMetadata_.set (x);
  }

  void ebuCoreMainType::
  coreMetadata (::std::auto_ptr< coreMetadata_type > x)
  {
    this->coreMetadata_.set (x);
  }

  const ebuCoreMainType::metadataProvider_optional& ebuCoreMainType::
  metadataProvider () const
  {
    return this->metadataProvider_;
  }

  ebuCoreMainType::metadataProvider_optional& ebuCoreMainType::
  metadataProvider ()
  {
    return this->metadataProvider_;
  }

  void ebuCoreMainType::
  metadataProvider (const metadataProvider_type& x)
  {
    this->metadataProvider_.set (x);
  }

  void ebuCoreMainType::
  metadataProvider (const metadataProvider_optional& x)
  {
    this->metadataProvider_ = x;
  }

  void ebuCoreMainType::
  metadataProvider (::std::auto_ptr< metadataProvider_type > x)
  {
    this->metadataProvider_.set (x);
  }

  const ebuCoreMainType::schema_type& ebuCoreMainType::
  schema () const
  {
    return this->schema_.get ();
  }

  ebuCoreMainType::schema_type& ebuCoreMainType::
  schema ()
  {
    return this->schema_.get ();
  }

  void ebuCoreMainType::
  schema (const schema_type& x)
  {
    this->schema_.set (x);
  }

  void ebuCoreMainType::
  schema (::std::auto_ptr< schema_type > x)
  {
    this->schema_.set (x);
  }

  const ebuCoreMainType::schema_type& ebuCoreMainType::
  schema_default_value ()
  {
    return schema_default_value_;
  }

  const ebuCoreMainType::version_type& ebuCoreMainType::
  version () const
  {
    return this->version_.get ();
  }

  ebuCoreMainType::version_type& ebuCoreMainType::
  version ()
  {
    return this->version_.get ();
  }

  void ebuCoreMainType::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void ebuCoreMainType::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const ebuCoreMainType::version_type& ebuCoreMainType::
  version_default_value ()
  {
    return version_default_value_;
  }

  const ebuCoreMainType::dateLastModified_optional& ebuCoreMainType::
  dateLastModified () const
  {
    return this->dateLastModified_;
  }

  ebuCoreMainType::dateLastModified_optional& ebuCoreMainType::
  dateLastModified ()
  {
    return this->dateLastModified_;
  }

  void ebuCoreMainType::
  dateLastModified (const dateLastModified_type& x)
  {
    this->dateLastModified_.set (x);
  }

  void ebuCoreMainType::
  dateLastModified (const dateLastModified_optional& x)
  {
    this->dateLastModified_ = x;
  }

  void ebuCoreMainType::
  dateLastModified (::std::auto_ptr< dateLastModified_type > x)
  {
    this->dateLastModified_.set (x);
  }

  const ebuCoreMainType::documentId_optional& ebuCoreMainType::
  documentId () const
  {
    return this->documentId_;
  }

  ebuCoreMainType::documentId_optional& ebuCoreMainType::
  documentId ()
  {
    return this->documentId_;
  }

  void ebuCoreMainType::
  documentId (const documentId_type& x)
  {
    this->documentId_.set (x);
  }

  void ebuCoreMainType::
  documentId (const documentId_optional& x)
  {
    this->documentId_ = x;
  }

  void ebuCoreMainType::
  documentId (::std::auto_ptr< documentId_type > x)
  {
    this->documentId_.set (x);
  }

  const ebuCoreMainType::lang_optional& ebuCoreMainType::
  lang () const
  {
    return this->lang_;
  }

  ebuCoreMainType::lang_optional& ebuCoreMainType::
  lang ()
  {
    return this->lang_;
  }

  void ebuCoreMainType::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void ebuCoreMainType::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void ebuCoreMainType::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // coreMetadataType
  // 

  const coreMetadataType::title_sequence& coreMetadataType::
  title () const
  {
    return this->title_;
  }

  coreMetadataType::title_sequence& coreMetadataType::
  title ()
  {
    return this->title_;
  }

  void coreMetadataType::
  title (const title_sequence& s)
  {
    this->title_ = s;
  }

  const coreMetadataType::alternativeTitle_sequence& coreMetadataType::
  alternativeTitle () const
  {
    return this->alternativeTitle_;
  }

  coreMetadataType::alternativeTitle_sequence& coreMetadataType::
  alternativeTitle ()
  {
    return this->alternativeTitle_;
  }

  void coreMetadataType::
  alternativeTitle (const alternativeTitle_sequence& s)
  {
    this->alternativeTitle_ = s;
  }

  const coreMetadataType::creator_sequence& coreMetadataType::
  creator () const
  {
    return this->creator_;
  }

  coreMetadataType::creator_sequence& coreMetadataType::
  creator ()
  {
    return this->creator_;
  }

  void coreMetadataType::
  creator (const creator_sequence& s)
  {
    this->creator_ = s;
  }

  const coreMetadataType::subject_sequence& coreMetadataType::
  subject () const
  {
    return this->subject_;
  }

  coreMetadataType::subject_sequence& coreMetadataType::
  subject ()
  {
    return this->subject_;
  }

  void coreMetadataType::
  subject (const subject_sequence& s)
  {
    this->subject_ = s;
  }

  const coreMetadataType::description_sequence& coreMetadataType::
  description () const
  {
    return this->description_;
  }

  coreMetadataType::description_sequence& coreMetadataType::
  description ()
  {
    return this->description_;
  }

  void coreMetadataType::
  description (const description_sequence& s)
  {
    this->description_ = s;
  }

  const coreMetadataType::publisher_sequence& coreMetadataType::
  publisher () const
  {
    return this->publisher_;
  }

  coreMetadataType::publisher_sequence& coreMetadataType::
  publisher ()
  {
    return this->publisher_;
  }

  void coreMetadataType::
  publisher (const publisher_sequence& s)
  {
    this->publisher_ = s;
  }

  const coreMetadataType::contributor_sequence& coreMetadataType::
  contributor () const
  {
    return this->contributor_;
  }

  coreMetadataType::contributor_sequence& coreMetadataType::
  contributor ()
  {
    return this->contributor_;
  }

  void coreMetadataType::
  contributor (const contributor_sequence& s)
  {
    this->contributor_ = s;
  }

  const coreMetadataType::date_sequence& coreMetadataType::
  date () const
  {
    return this->date_;
  }

  coreMetadataType::date_sequence& coreMetadataType::
  date ()
  {
    return this->date_;
  }

  void coreMetadataType::
  date (const date_sequence& s)
  {
    this->date_ = s;
  }

  const coreMetadataType::type_sequence& coreMetadataType::
  type () const
  {
    return this->type_;
  }

  coreMetadataType::type_sequence& coreMetadataType::
  type ()
  {
    return this->type_;
  }

  void coreMetadataType::
  type (const type_sequence& s)
  {
    this->type_ = s;
  }

  const coreMetadataType::format_sequence& coreMetadataType::
  format () const
  {
    return this->format_;
  }

  coreMetadataType::format_sequence& coreMetadataType::
  format ()
  {
    return this->format_;
  }

  void coreMetadataType::
  format (const format_sequence& s)
  {
    this->format_ = s;
  }

  const coreMetadataType::identifier_sequence& coreMetadataType::
  identifier () const
  {
    return this->identifier_;
  }

  coreMetadataType::identifier_sequence& coreMetadataType::
  identifier ()
  {
    return this->identifier_;
  }

  void coreMetadataType::
  identifier (const identifier_sequence& s)
  {
    this->identifier_ = s;
  }

  const coreMetadataType::source_sequence& coreMetadataType::
  source () const
  {
    return this->source_;
  }

  coreMetadataType::source_sequence& coreMetadataType::
  source ()
  {
    return this->source_;
  }

  void coreMetadataType::
  source (const source_sequence& s)
  {
    this->source_ = s;
  }

  const coreMetadataType::language_sequence& coreMetadataType::
  language () const
  {
    return this->language_;
  }

  coreMetadataType::language_sequence& coreMetadataType::
  language ()
  {
    return this->language_;
  }

  void coreMetadataType::
  language (const language_sequence& s)
  {
    this->language_ = s;
  }

  const coreMetadataType::relation_sequence& coreMetadataType::
  relation () const
  {
    return this->relation_;
  }

  coreMetadataType::relation_sequence& coreMetadataType::
  relation ()
  {
    return this->relation_;
  }

  void coreMetadataType::
  relation (const relation_sequence& s)
  {
    this->relation_ = s;
  }

  const coreMetadataType::isVersionOf_sequence& coreMetadataType::
  isVersionOf () const
  {
    return this->isVersionOf_;
  }

  coreMetadataType::isVersionOf_sequence& coreMetadataType::
  isVersionOf ()
  {
    return this->isVersionOf_;
  }

  void coreMetadataType::
  isVersionOf (const isVersionOf_sequence& s)
  {
    this->isVersionOf_ = s;
  }

  const coreMetadataType::hasVersion_sequence& coreMetadataType::
  hasVersion () const
  {
    return this->hasVersion_;
  }

  coreMetadataType::hasVersion_sequence& coreMetadataType::
  hasVersion ()
  {
    return this->hasVersion_;
  }

  void coreMetadataType::
  hasVersion (const hasVersion_sequence& s)
  {
    this->hasVersion_ = s;
  }

  const coreMetadataType::isReplacedBy_sequence& coreMetadataType::
  isReplacedBy () const
  {
    return this->isReplacedBy_;
  }

  coreMetadataType::isReplacedBy_sequence& coreMetadataType::
  isReplacedBy ()
  {
    return this->isReplacedBy_;
  }

  void coreMetadataType::
  isReplacedBy (const isReplacedBy_sequence& s)
  {
    this->isReplacedBy_ = s;
  }

  const coreMetadataType::replaces_sequence& coreMetadataType::
  replaces () const
  {
    return this->replaces_;
  }

  coreMetadataType::replaces_sequence& coreMetadataType::
  replaces ()
  {
    return this->replaces_;
  }

  void coreMetadataType::
  replaces (const replaces_sequence& s)
  {
    this->replaces_ = s;
  }

  const coreMetadataType::isRequiredBy_sequence& coreMetadataType::
  isRequiredBy () const
  {
    return this->isRequiredBy_;
  }

  coreMetadataType::isRequiredBy_sequence& coreMetadataType::
  isRequiredBy ()
  {
    return this->isRequiredBy_;
  }

  void coreMetadataType::
  isRequiredBy (const isRequiredBy_sequence& s)
  {
    this->isRequiredBy_ = s;
  }

  const coreMetadataType::requires_sequence& coreMetadataType::
  requires () const
  {
    return this->requires_;
  }

  coreMetadataType::requires_sequence& coreMetadataType::
  requires ()
  {
    return this->requires_;
  }

  void coreMetadataType::
  requires (const requires_sequence& s)
  {
    this->requires_ = s;
  }

  const coreMetadataType::isPartOf_sequence& coreMetadataType::
  isPartOf () const
  {
    return this->isPartOf_;
  }

  coreMetadataType::isPartOf_sequence& coreMetadataType::
  isPartOf ()
  {
    return this->isPartOf_;
  }

  void coreMetadataType::
  isPartOf (const isPartOf_sequence& s)
  {
    this->isPartOf_ = s;
  }

  const coreMetadataType::hasPart_sequence& coreMetadataType::
  hasPart () const
  {
    return this->hasPart_;
  }

  coreMetadataType::hasPart_sequence& coreMetadataType::
  hasPart ()
  {
    return this->hasPart_;
  }

  void coreMetadataType::
  hasPart (const hasPart_sequence& s)
  {
    this->hasPart_ = s;
  }

  const coreMetadataType::hasTrackPart_sequence& coreMetadataType::
  hasTrackPart () const
  {
    return this->hasTrackPart_;
  }

  coreMetadataType::hasTrackPart_sequence& coreMetadataType::
  hasTrackPart ()
  {
    return this->hasTrackPart_;
  }

  void coreMetadataType::
  hasTrackPart (const hasTrackPart_sequence& s)
  {
    this->hasTrackPart_ = s;
  }

  const coreMetadataType::isReferencedBy_sequence& coreMetadataType::
  isReferencedBy () const
  {
    return this->isReferencedBy_;
  }

  coreMetadataType::isReferencedBy_sequence& coreMetadataType::
  isReferencedBy ()
  {
    return this->isReferencedBy_;
  }

  void coreMetadataType::
  isReferencedBy (const isReferencedBy_sequence& s)
  {
    this->isReferencedBy_ = s;
  }

  const coreMetadataType::references_sequence& coreMetadataType::
  references () const
  {
    return this->references_;
  }

  coreMetadataType::references_sequence& coreMetadataType::
  references ()
  {
    return this->references_;
  }

  void coreMetadataType::
  references (const references_sequence& s)
  {
    this->references_ = s;
  }

  const coreMetadataType::isFormatOf_sequence& coreMetadataType::
  isFormatOf () const
  {
    return this->isFormatOf_;
  }

  coreMetadataType::isFormatOf_sequence& coreMetadataType::
  isFormatOf ()
  {
    return this->isFormatOf_;
  }

  void coreMetadataType::
  isFormatOf (const isFormatOf_sequence& s)
  {
    this->isFormatOf_ = s;
  }

  const coreMetadataType::hasFormat_sequence& coreMetadataType::
  hasFormat () const
  {
    return this->hasFormat_;
  }

  coreMetadataType::hasFormat_sequence& coreMetadataType::
  hasFormat ()
  {
    return this->hasFormat_;
  }

  void coreMetadataType::
  hasFormat (const hasFormat_sequence& s)
  {
    this->hasFormat_ = s;
  }

  const coreMetadataType::isEpisodeOf_sequence& coreMetadataType::
  isEpisodeOf () const
  {
    return this->isEpisodeOf_;
  }

  coreMetadataType::isEpisodeOf_sequence& coreMetadataType::
  isEpisodeOf ()
  {
    return this->isEpisodeOf_;
  }

  void coreMetadataType::
  isEpisodeOf (const isEpisodeOf_sequence& s)
  {
    this->isEpisodeOf_ = s;
  }

  const coreMetadataType::isMemberOf_sequence& coreMetadataType::
  isMemberOf () const
  {
    return this->isMemberOf_;
  }

  coreMetadataType::isMemberOf_sequence& coreMetadataType::
  isMemberOf ()
  {
    return this->isMemberOf_;
  }

  void coreMetadataType::
  isMemberOf (const isMemberOf_sequence& s)
  {
    this->isMemberOf_ = s;
  }

  const coreMetadataType::coverage_sequence& coreMetadataType::
  coverage () const
  {
    return this->coverage_;
  }

  coreMetadataType::coverage_sequence& coreMetadataType::
  coverage ()
  {
    return this->coverage_;
  }

  void coreMetadataType::
  coverage (const coverage_sequence& s)
  {
    this->coverage_ = s;
  }

  const coreMetadataType::rights_sequence& coreMetadataType::
  rights () const
  {
    return this->rights_;
  }

  coreMetadataType::rights_sequence& coreMetadataType::
  rights ()
  {
    return this->rights_;
  }

  void coreMetadataType::
  rights (const rights_sequence& s)
  {
    this->rights_ = s;
  }

  const coreMetadataType::version_optional& coreMetadataType::
  version () const
  {
    return this->version_;
  }

  coreMetadataType::version_optional& coreMetadataType::
  version ()
  {
    return this->version_;
  }

  void coreMetadataType::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void coreMetadataType::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void coreMetadataType::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const coreMetadataType::publicationHistory_optional& coreMetadataType::
  publicationHistory () const
  {
    return this->publicationHistory_;
  }

  coreMetadataType::publicationHistory_optional& coreMetadataType::
  publicationHistory ()
  {
    return this->publicationHistory_;
  }

  void coreMetadataType::
  publicationHistory (const publicationHistory_type& x)
  {
    this->publicationHistory_.set (x);
  }

  void coreMetadataType::
  publicationHistory (const publicationHistory_optional& x)
  {
    this->publicationHistory_ = x;
  }

  void coreMetadataType::
  publicationHistory (::std::auto_ptr< publicationHistory_type > x)
  {
    this->publicationHistory_.set (x);
  }

  const coreMetadataType::rating_sequence& coreMetadataType::
  rating () const
  {
    return this->rating_;
  }

  coreMetadataType::rating_sequence& coreMetadataType::
  rating ()
  {
    return this->rating_;
  }

  void coreMetadataType::
  rating (const rating_sequence& s)
  {
    this->rating_ = s;
  }

  const coreMetadataType::part_sequence& coreMetadataType::
  part () const
  {
    return this->part_;
  }

  coreMetadataType::part_sequence& coreMetadataType::
  part ()
  {
    return this->part_;
  }

  void coreMetadataType::
  part (const part_sequence& s)
  {
    this->part_ = s;
  }


  // titleType
  // 

  const titleType::title_type& titleType::
  title () const
  {
    return this->title_.get ();
  }

  titleType::title_type& titleType::
  title ()
  {
    return this->title_.get ();
  }

  void titleType::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void titleType::
  title (::std::auto_ptr< title_type > x)
  {
    this->title_.set (x);
  }

  const titleType::attributiondate_optional& titleType::
  attributiondate () const
  {
    return this->attributiondate_;
  }

  titleType::attributiondate_optional& titleType::
  attributiondate ()
  {
    return this->attributiondate_;
  }

  void titleType::
  attributiondate (const attributiondate_type& x)
  {
    this->attributiondate_.set (x);
  }

  void titleType::
  attributiondate (const attributiondate_optional& x)
  {
    this->attributiondate_ = x;
  }

  void titleType::
  attributiondate (::std::auto_ptr< attributiondate_type > x)
  {
    this->attributiondate_.set (x);
  }

  const titleType::note_optional& titleType::
  note () const
  {
    return this->note_;
  }

  titleType::note_optional& titleType::
  note ()
  {
    return this->note_;
  }

  void titleType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void titleType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void titleType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // alternativeTitleType
  // 

  const alternativeTitleType::title_type& alternativeTitleType::
  title () const
  {
    return this->title_.get ();
  }

  alternativeTitleType::title_type& alternativeTitleType::
  title ()
  {
    return this->title_.get ();
  }

  void alternativeTitleType::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void alternativeTitleType::
  title (::std::auto_ptr< title_type > x)
  {
    this->title_.set (x);
  }

  const alternativeTitleType::typeLabel_optional& alternativeTitleType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  alternativeTitleType::typeLabel_optional& alternativeTitleType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void alternativeTitleType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void alternativeTitleType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void alternativeTitleType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const alternativeTitleType::typeDefinition_optional& alternativeTitleType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  alternativeTitleType::typeDefinition_optional& alternativeTitleType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void alternativeTitleType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void alternativeTitleType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void alternativeTitleType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const alternativeTitleType::typeLink_optional& alternativeTitleType::
  typeLink () const
  {
    return this->typeLink_;
  }

  alternativeTitleType::typeLink_optional& alternativeTitleType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void alternativeTitleType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void alternativeTitleType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void alternativeTitleType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const alternativeTitleType::statusLabel_optional& alternativeTitleType::
  statusLabel () const
  {
    return this->statusLabel_;
  }

  alternativeTitleType::statusLabel_optional& alternativeTitleType::
  statusLabel ()
  {
    return this->statusLabel_;
  }

  void alternativeTitleType::
  statusLabel (const statusLabel_type& x)
  {
    this->statusLabel_.set (x);
  }

  void alternativeTitleType::
  statusLabel (const statusLabel_optional& x)
  {
    this->statusLabel_ = x;
  }

  void alternativeTitleType::
  statusLabel (::std::auto_ptr< statusLabel_type > x)
  {
    this->statusLabel_.set (x);
  }

  const alternativeTitleType::statusDefinition_optional& alternativeTitleType::
  statusDefinition () const
  {
    return this->statusDefinition_;
  }

  alternativeTitleType::statusDefinition_optional& alternativeTitleType::
  statusDefinition ()
  {
    return this->statusDefinition_;
  }

  void alternativeTitleType::
  statusDefinition (const statusDefinition_type& x)
  {
    this->statusDefinition_.set (x);
  }

  void alternativeTitleType::
  statusDefinition (const statusDefinition_optional& x)
  {
    this->statusDefinition_ = x;
  }

  void alternativeTitleType::
  statusDefinition (::std::auto_ptr< statusDefinition_type > x)
  {
    this->statusDefinition_.set (x);
  }

  const alternativeTitleType::statusLink_optional& alternativeTitleType::
  statusLink () const
  {
    return this->statusLink_;
  }

  alternativeTitleType::statusLink_optional& alternativeTitleType::
  statusLink ()
  {
    return this->statusLink_;
  }

  void alternativeTitleType::
  statusLink (const statusLink_type& x)
  {
    this->statusLink_.set (x);
  }

  void alternativeTitleType::
  statusLink (const statusLink_optional& x)
  {
    this->statusLink_ = x;
  }

  void alternativeTitleType::
  statusLink (::std::auto_ptr< statusLink_type > x)
  {
    this->statusLink_.set (x);
  }

  const alternativeTitleType::startYear_optional& alternativeTitleType::
  startYear () const
  {
    return this->startYear_;
  }

  alternativeTitleType::startYear_optional& alternativeTitleType::
  startYear ()
  {
    return this->startYear_;
  }

  void alternativeTitleType::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void alternativeTitleType::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void alternativeTitleType::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const alternativeTitleType::startDate_optional& alternativeTitleType::
  startDate () const
  {
    return this->startDate_;
  }

  alternativeTitleType::startDate_optional& alternativeTitleType::
  startDate ()
  {
    return this->startDate_;
  }

  void alternativeTitleType::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void alternativeTitleType::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void alternativeTitleType::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const alternativeTitleType::startTime_optional& alternativeTitleType::
  startTime () const
  {
    return this->startTime_;
  }

  alternativeTitleType::startTime_optional& alternativeTitleType::
  startTime ()
  {
    return this->startTime_;
  }

  void alternativeTitleType::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void alternativeTitleType::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void alternativeTitleType::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const alternativeTitleType::endYear_optional& alternativeTitleType::
  endYear () const
  {
    return this->endYear_;
  }

  alternativeTitleType::endYear_optional& alternativeTitleType::
  endYear ()
  {
    return this->endYear_;
  }

  void alternativeTitleType::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void alternativeTitleType::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void alternativeTitleType::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const alternativeTitleType::endDate_optional& alternativeTitleType::
  endDate () const
  {
    return this->endDate_;
  }

  alternativeTitleType::endDate_optional& alternativeTitleType::
  endDate ()
  {
    return this->endDate_;
  }

  void alternativeTitleType::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void alternativeTitleType::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void alternativeTitleType::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const alternativeTitleType::endTime_optional& alternativeTitleType::
  endTime () const
  {
    return this->endTime_;
  }

  alternativeTitleType::endTime_optional& alternativeTitleType::
  endTime ()
  {
    return this->endTime_;
  }

  void alternativeTitleType::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void alternativeTitleType::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void alternativeTitleType::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const alternativeTitleType::period_optional& alternativeTitleType::
  period () const
  {
    return this->period_;
  }

  alternativeTitleType::period_optional& alternativeTitleType::
  period ()
  {
    return this->period_;
  }

  void alternativeTitleType::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void alternativeTitleType::
  period (const period_optional& x)
  {
    this->period_ = x;
  }

  void alternativeTitleType::
  period (::std::auto_ptr< period_type > x)
  {
    this->period_.set (x);
  }

  const alternativeTitleType::note_optional& alternativeTitleType::
  note () const
  {
    return this->note_;
  }

  alternativeTitleType::note_optional& alternativeTitleType::
  note ()
  {
    return this->note_;
  }

  void alternativeTitleType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void alternativeTitleType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void alternativeTitleType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // identifierType
  // 

  const identifierType::identifier_type& identifierType::
  identifier () const
  {
    return this->identifier_.get ();
  }

  identifierType::identifier_type& identifierType::
  identifier ()
  {
    return this->identifier_.get ();
  }

  void identifierType::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void identifierType::
  identifier (::std::auto_ptr< identifier_type > x)
  {
    this->identifier_.set (x);
  }

  const identifierType::attributor_optional& identifierType::
  attributor () const
  {
    return this->attributor_;
  }

  identifierType::attributor_optional& identifierType::
  attributor ()
  {
    return this->attributor_;
  }

  void identifierType::
  attributor (const attributor_type& x)
  {
    this->attributor_.set (x);
  }

  void identifierType::
  attributor (const attributor_optional& x)
  {
    this->attributor_ = x;
  }

  void identifierType::
  attributor (::std::auto_ptr< attributor_type > x)
  {
    this->attributor_.set (x);
  }

  const identifierType::typeLabel_optional& identifierType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  identifierType::typeLabel_optional& identifierType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void identifierType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void identifierType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void identifierType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const identifierType::typeDefinition_optional& identifierType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  identifierType::typeDefinition_optional& identifierType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void identifierType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void identifierType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void identifierType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const identifierType::typeLink_optional& identifierType::
  typeLink () const
  {
    return this->typeLink_;
  }

  identifierType::typeLink_optional& identifierType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void identifierType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void identifierType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void identifierType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const identifierType::formatLabel_optional& identifierType::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  identifierType::formatLabel_optional& identifierType::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void identifierType::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void identifierType::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void identifierType::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const identifierType::formatDefinition_optional& identifierType::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  identifierType::formatDefinition_optional& identifierType::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void identifierType::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void identifierType::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void identifierType::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const identifierType::formatLink_optional& identifierType::
  formatLink () const
  {
    return this->formatLink_;
  }

  identifierType::formatLink_optional& identifierType::
  formatLink ()
  {
    return this->formatLink_;
  }

  void identifierType::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void identifierType::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void identifierType::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const identifierType::note_optional& identifierType::
  note () const
  {
    return this->note_;
  }

  identifierType::note_optional& identifierType::
  note ()
  {
    return this->note_;
  }

  void identifierType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void identifierType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void identifierType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // subjectType
  // 

  const subjectType::subject_type& subjectType::
  subject () const
  {
    return this->subject_.get ();
  }

  subjectType::subject_type& subjectType::
  subject ()
  {
    return this->subject_.get ();
  }

  void subjectType::
  subject (const subject_type& x)
  {
    this->subject_.set (x);
  }

  void subjectType::
  subject (::std::auto_ptr< subject_type > x)
  {
    this->subject_.set (x);
  }

  const subjectType::subjectCode_optional& subjectType::
  subjectCode () const
  {
    return this->subjectCode_;
  }

  subjectType::subjectCode_optional& subjectType::
  subjectCode ()
  {
    return this->subjectCode_;
  }

  void subjectType::
  subjectCode (const subjectCode_type& x)
  {
    this->subjectCode_.set (x);
  }

  void subjectType::
  subjectCode (const subjectCode_optional& x)
  {
    this->subjectCode_ = x;
  }

  void subjectType::
  subjectCode (::std::auto_ptr< subjectCode_type > x)
  {
    this->subjectCode_.set (x);
  }

  const subjectType::subjectDefinition_optional& subjectType::
  subjectDefinition () const
  {
    return this->subjectDefinition_;
  }

  subjectType::subjectDefinition_optional& subjectType::
  subjectDefinition ()
  {
    return this->subjectDefinition_;
  }

  void subjectType::
  subjectDefinition (const subjectDefinition_type& x)
  {
    this->subjectDefinition_.set (x);
  }

  void subjectType::
  subjectDefinition (const subjectDefinition_optional& x)
  {
    this->subjectDefinition_ = x;
  }

  void subjectType::
  subjectDefinition (::std::auto_ptr< subjectDefinition_type > x)
  {
    this->subjectDefinition_.set (x);
  }

  const subjectType::attributor_optional& subjectType::
  attributor () const
  {
    return this->attributor_;
  }

  subjectType::attributor_optional& subjectType::
  attributor ()
  {
    return this->attributor_;
  }

  void subjectType::
  attributor (const attributor_type& x)
  {
    this->attributor_.set (x);
  }

  void subjectType::
  attributor (const attributor_optional& x)
  {
    this->attributor_ = x;
  }

  void subjectType::
  attributor (::std::auto_ptr< attributor_type > x)
  {
    this->attributor_.set (x);
  }

  const subjectType::typeLabel_optional& subjectType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  subjectType::typeLabel_optional& subjectType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void subjectType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void subjectType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void subjectType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const subjectType::typeDefinition_optional& subjectType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  subjectType::typeDefinition_optional& subjectType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void subjectType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void subjectType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void subjectType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const subjectType::typeLink_optional& subjectType::
  typeLink () const
  {
    return this->typeLink_;
  }

  subjectType::typeLink_optional& subjectType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void subjectType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void subjectType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void subjectType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const subjectType::note_optional& subjectType::
  note () const
  {
    return this->note_;
  }

  subjectType::note_optional& subjectType::
  note ()
  {
    return this->note_;
  }

  void subjectType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void subjectType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void subjectType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // typeType
  // 

  const typeType::type_sequence& typeType::
  type () const
  {
    return this->type_;
  }

  typeType::type_sequence& typeType::
  type ()
  {
    return this->type_;
  }

  void typeType::
  type (const type_sequence& s)
  {
    this->type_ = s;
  }

  const typeType::genre_sequence& typeType::
  genre () const
  {
    return this->genre_;
  }

  typeType::genre_sequence& typeType::
  genre ()
  {
    return this->genre_;
  }

  void typeType::
  genre (const genre_sequence& s)
  {
    this->genre_ = s;
  }

  const typeType::objectType_sequence& typeType::
  objectType () const
  {
    return this->objectType_;
  }

  typeType::objectType_sequence& typeType::
  objectType ()
  {
    return this->objectType_;
  }

  void typeType::
  objectType (const objectType_sequence& s)
  {
    this->objectType_ = s;
  }

  const typeType::targetAudience_sequence& typeType::
  targetAudience () const
  {
    return this->targetAudience_;
  }

  typeType::targetAudience_sequence& typeType::
  targetAudience ()
  {
    return this->targetAudience_;
  }

  void typeType::
  targetAudience (const targetAudience_sequence& s)
  {
    this->targetAudience_ = s;
  }

  const typeType::note_optional& typeType::
  note () const
  {
    return this->note_;
  }

  typeType::note_optional& typeType::
  note ()
  {
    return this->note_;
  }

  void typeType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void typeType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void typeType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // descriptionType
  // 

  const descriptionType::description_type& descriptionType::
  description () const
  {
    return this->description_.get ();
  }

  descriptionType::description_type& descriptionType::
  description ()
  {
    return this->description_.get ();
  }

  void descriptionType::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void descriptionType::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }

  const descriptionType::typeLabel_optional& descriptionType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  descriptionType::typeLabel_optional& descriptionType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void descriptionType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void descriptionType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void descriptionType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const descriptionType::typeDefinition_optional& descriptionType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  descriptionType::typeDefinition_optional& descriptionType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void descriptionType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void descriptionType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void descriptionType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const descriptionType::typeLink_optional& descriptionType::
  typeLink () const
  {
    return this->typeLink_;
  }

  descriptionType::typeLink_optional& descriptionType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void descriptionType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void descriptionType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void descriptionType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const descriptionType::note_optional& descriptionType::
  note () const
  {
    return this->note_;
  }

  descriptionType::note_optional& descriptionType::
  note ()
  {
    return this->note_;
  }

  void descriptionType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void descriptionType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void descriptionType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // coverageType
  // 

  const coverageType::coverage_optional& coverageType::
  coverage () const
  {
    return this->coverage_;
  }

  coverageType::coverage_optional& coverageType::
  coverage ()
  {
    return this->coverage_;
  }

  void coverageType::
  coverage (const coverage_type& x)
  {
    this->coverage_.set (x);
  }

  void coverageType::
  coverage (const coverage_optional& x)
  {
    this->coverage_ = x;
  }

  void coverageType::
  coverage (::std::auto_ptr< coverage_type > x)
  {
    this->coverage_.set (x);
  }

  const coverageType::temporal_optional& coverageType::
  temporal () const
  {
    return this->temporal_;
  }

  coverageType::temporal_optional& coverageType::
  temporal ()
  {
    return this->temporal_;
  }

  void coverageType::
  temporal (const temporal_type& x)
  {
    this->temporal_.set (x);
  }

  void coverageType::
  temporal (const temporal_optional& x)
  {
    this->temporal_ = x;
  }

  void coverageType::
  temporal (::std::auto_ptr< temporal_type > x)
  {
    this->temporal_.set (x);
  }

  const coverageType::spatial_optional& coverageType::
  spatial () const
  {
    return this->spatial_;
  }

  coverageType::spatial_optional& coverageType::
  spatial ()
  {
    return this->spatial_;
  }

  void coverageType::
  spatial (const spatial_type& x)
  {
    this->spatial_.set (x);
  }

  void coverageType::
  spatial (const spatial_optional& x)
  {
    this->spatial_ = x;
  }

  void coverageType::
  spatial (::std::auto_ptr< spatial_type > x)
  {
    this->spatial_.set (x);
  }


  // rightsType
  // 

  const rightsType::rights_optional& rightsType::
  rights () const
  {
    return this->rights_;
  }

  rightsType::rights_optional& rightsType::
  rights ()
  {
    return this->rights_;
  }

  void rightsType::
  rights (const rights_type& x)
  {
    this->rights_.set (x);
  }

  void rightsType::
  rights (const rights_optional& x)
  {
    this->rights_ = x;
  }

  void rightsType::
  rights (::std::auto_ptr< rights_type > x)
  {
    this->rights_.set (x);
  }

  const rightsType::rightsLink_optional& rightsType::
  rightsLink () const
  {
    return this->rightsLink_;
  }

  rightsType::rightsLink_optional& rightsType::
  rightsLink ()
  {
    return this->rightsLink_;
  }

  void rightsType::
  rightsLink (const rightsLink_type& x)
  {
    this->rightsLink_.set (x);
  }

  void rightsType::
  rightsLink (const rightsLink_optional& x)
  {
    this->rightsLink_ = x;
  }

  void rightsType::
  rightsLink (::std::auto_ptr< rightsLink_type > x)
  {
    this->rightsLink_.set (x);
  }

  const rightsType::rightsHolder_optional& rightsType::
  rightsHolder () const
  {
    return this->rightsHolder_;
  }

  rightsType::rightsHolder_optional& rightsType::
  rightsHolder ()
  {
    return this->rightsHolder_;
  }

  void rightsType::
  rightsHolder (const rightsHolder_type& x)
  {
    this->rightsHolder_.set (x);
  }

  void rightsType::
  rightsHolder (const rightsHolder_optional& x)
  {
    this->rightsHolder_ = x;
  }

  void rightsType::
  rightsHolder (::std::auto_ptr< rightsHolder_type > x)
  {
    this->rightsHolder_.set (x);
  }

  const rightsType::exploitationIssues_optional& rightsType::
  exploitationIssues () const
  {
    return this->exploitationIssues_;
  }

  rightsType::exploitationIssues_optional& rightsType::
  exploitationIssues ()
  {
    return this->exploitationIssues_;
  }

  void rightsType::
  exploitationIssues (const exploitationIssues_type& x)
  {
    this->exploitationIssues_.set (x);
  }

  void rightsType::
  exploitationIssues (const exploitationIssues_optional& x)
  {
    this->exploitationIssues_ = x;
  }

  void rightsType::
  exploitationIssues (::std::auto_ptr< exploitationIssues_type > x)
  {
    this->exploitationIssues_.set (x);
  }

  const rightsType::coverage_optional& rightsType::
  coverage () const
  {
    return this->coverage_;
  }

  rightsType::coverage_optional& rightsType::
  coverage ()
  {
    return this->coverage_;
  }

  void rightsType::
  coverage (const coverage_type& x)
  {
    this->coverage_.set (x);
  }

  void rightsType::
  coverage (const coverage_optional& x)
  {
    this->coverage_ = x;
  }

  void rightsType::
  coverage (::std::auto_ptr< coverage_type > x)
  {
    this->coverage_.set (x);
  }

  const rightsType::rightsClearanceFlag_optional& rightsType::
  rightsClearanceFlag () const
  {
    return this->rightsClearanceFlag_;
  }

  rightsType::rightsClearanceFlag_optional& rightsType::
  rightsClearanceFlag ()
  {
    return this->rightsClearanceFlag_;
  }

  void rightsType::
  rightsClearanceFlag (const rightsClearanceFlag_type& x)
  {
    this->rightsClearanceFlag_.set (x);
  }

  void rightsType::
  rightsClearanceFlag (const rightsClearanceFlag_optional& x)
  {
    this->rightsClearanceFlag_ = x;
  }

  const rightsType::disclaimer_sequence& rightsType::
  disclaimer () const
  {
    return this->disclaimer_;
  }

  rightsType::disclaimer_sequence& rightsType::
  disclaimer ()
  {
    return this->disclaimer_;
  }

  void rightsType::
  disclaimer (const disclaimer_sequence& s)
  {
    this->disclaimer_ = s;
  }

  const rightsType::rightsId_sequence& rightsType::
  rightsId () const
  {
    return this->rightsId_;
  }

  rightsType::rightsId_sequence& rightsType::
  rightsId ()
  {
    return this->rightsId_;
  }

  void rightsType::
  rightsId (const rightsId_sequence& s)
  {
    this->rightsId_ = s;
  }

  const rightsType::contactDetails_sequence& rightsType::
  contactDetails () const
  {
    return this->contactDetails_;
  }

  rightsType::contactDetails_sequence& rightsType::
  contactDetails ()
  {
    return this->contactDetails_;
  }

  void rightsType::
  contactDetails (const contactDetails_sequence& s)
  {
    this->contactDetails_ = s;
  }

  const rightsType::typeLabel_optional& rightsType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  rightsType::typeLabel_optional& rightsType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void rightsType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void rightsType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void rightsType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const rightsType::typeDefinition_optional& rightsType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  rightsType::typeDefinition_optional& rightsType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void rightsType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void rightsType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void rightsType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const rightsType::typeLink_optional& rightsType::
  typeLink () const
  {
    return this->typeLink_;
  }

  rightsType::typeLink_optional& rightsType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void rightsType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void rightsType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void rightsType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const rightsType::note_optional& rightsType::
  note () const
  {
    return this->note_;
  }

  rightsType::note_optional& rightsType::
  note ()
  {
    return this->note_;
  }

  void rightsType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void rightsType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void rightsType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }

  const rightsType::formatIDRefs_optional& rightsType::
  formatIDRefs () const
  {
    return this->formatIDRefs_;
  }

  rightsType::formatIDRefs_optional& rightsType::
  formatIDRefs ()
  {
    return this->formatIDRefs_;
  }

  void rightsType::
  formatIDRefs (const formatIDRefs_type& x)
  {
    this->formatIDRefs_.set (x);
  }

  void rightsType::
  formatIDRefs (const formatIDRefs_optional& x)
  {
    this->formatIDRefs_ = x;
  }

  void rightsType::
  formatIDRefs (::std::auto_ptr< formatIDRefs_type > x)
  {
    this->formatIDRefs_.set (x);
  }


  // formatType
  // 

  const formatType::format_optional& formatType::
  format () const
  {
    return this->format_;
  }

  formatType::format_optional& formatType::
  format ()
  {
    return this->format_;
  }

  void formatType::
  format (const format_type& x)
  {
    this->format_.set (x);
  }

  void formatType::
  format (const format_optional& x)
  {
    this->format_ = x;
  }

  void formatType::
  format (::std::auto_ptr< format_type > x)
  {
    this->format_.set (x);
  }

  const formatType::regionDelimX_optional& formatType::
  regionDelimX () const
  {
    return this->regionDelimX_;
  }

  formatType::regionDelimX_optional& formatType::
  regionDelimX ()
  {
    return this->regionDelimX_;
  }

  void formatType::
  regionDelimX (const regionDelimX_type& x)
  {
    this->regionDelimX_.set (x);
  }

  void formatType::
  regionDelimX (const regionDelimX_optional& x)
  {
    this->regionDelimX_ = x;
  }

  const formatType::regionDelimY_optional& formatType::
  regionDelimY () const
  {
    return this->regionDelimY_;
  }

  formatType::regionDelimY_optional& formatType::
  regionDelimY ()
  {
    return this->regionDelimY_;
  }

  void formatType::
  regionDelimY (const regionDelimY_type& x)
  {
    this->regionDelimY_.set (x);
  }

  void formatType::
  regionDelimY (const regionDelimY_optional& x)
  {
    this->regionDelimY_ = x;
  }

  const formatType::width_optional& formatType::
  width () const
  {
    return this->width_;
  }

  formatType::width_optional& formatType::
  width ()
  {
    return this->width_;
  }

  void formatType::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void formatType::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void formatType::
  width (::std::auto_ptr< width_type > x)
  {
    this->width_.set (x);
  }

  const formatType::height_optional& formatType::
  height () const
  {
    return this->height_;
  }

  formatType::height_optional& formatType::
  height ()
  {
    return this->height_;
  }

  void formatType::
  height (const height_type& x)
  {
    this->height_.set (x);
  }

  void formatType::
  height (const height_optional& x)
  {
    this->height_ = x;
  }

  void formatType::
  height (::std::auto_ptr< height_type > x)
  {
    this->height_.set (x);
  }

  const formatType::medium_sequence& formatType::
  medium () const
  {
    return this->medium_;
  }

  formatType::medium_sequence& formatType::
  medium ()
  {
    return this->medium_;
  }

  void formatType::
  medium (const medium_sequence& s)
  {
    this->medium_ = s;
  }

  const formatType::mimeType_sequence& formatType::
  mimeType () const
  {
    return this->mimeType_;
  }

  formatType::mimeType_sequence& formatType::
  mimeType ()
  {
    return this->mimeType_;
  }

  void formatType::
  mimeType (const mimeType_sequence& s)
  {
    this->mimeType_ = s;
  }

  const formatType::imageFormat_sequence& formatType::
  imageFormat () const
  {
    return this->imageFormat_;
  }

  formatType::imageFormat_sequence& formatType::
  imageFormat ()
  {
    return this->imageFormat_;
  }

  void formatType::
  imageFormat (const imageFormat_sequence& s)
  {
    this->imageFormat_ = s;
  }

  const formatType::videoFormat_sequence& formatType::
  videoFormat () const
  {
    return this->videoFormat_;
  }

  formatType::videoFormat_sequence& formatType::
  videoFormat ()
  {
    return this->videoFormat_;
  }

  void formatType::
  videoFormat (const videoFormat_sequence& s)
  {
    this->videoFormat_ = s;
  }

  const formatType::audioFormat_sequence& formatType::
  audioFormat () const
  {
    return this->audioFormat_;
  }

  formatType::audioFormat_sequence& formatType::
  audioFormat ()
  {
    return this->audioFormat_;
  }

  void formatType::
  audioFormat (const audioFormat_sequence& s)
  {
    this->audioFormat_ = s;
  }

  const formatType::containerFormat_sequence& formatType::
  containerFormat () const
  {
    return this->containerFormat_;
  }

  formatType::containerFormat_sequence& formatType::
  containerFormat ()
  {
    return this->containerFormat_;
  }

  void formatType::
  containerFormat (const containerFormat_sequence& s)
  {
    this->containerFormat_ = s;
  }

  const formatType::dataFormat_sequence& formatType::
  dataFormat () const
  {
    return this->dataFormat_;
  }

  formatType::dataFormat_sequence& formatType::
  dataFormat ()
  {
    return this->dataFormat_;
  }

  void formatType::
  dataFormat (const dataFormat_sequence& s)
  {
    this->dataFormat_ = s;
  }

  const formatType::signingFormat_sequence& formatType::
  signingFormat () const
  {
    return this->signingFormat_;
  }

  formatType::signingFormat_sequence& formatType::
  signingFormat ()
  {
    return this->signingFormat_;
  }

  void formatType::
  signingFormat (const signingFormat_sequence& s)
  {
    this->signingFormat_ = s;
  }

  const formatType::start_optional& formatType::
  start () const
  {
    return this->start_;
  }

  formatType::start_optional& formatType::
  start ()
  {
    return this->start_;
  }

  void formatType::
  start (const start_type& x)
  {
    this->start_.set (x);
  }

  void formatType::
  start (const start_optional& x)
  {
    this->start_ = x;
  }

  void formatType::
  start (::std::auto_ptr< start_type > x)
  {
    this->start_.set (x);
  }

  const formatType::end_optional& formatType::
  end () const
  {
    return this->end_;
  }

  formatType::end_optional& formatType::
  end ()
  {
    return this->end_;
  }

  void formatType::
  end (const end_type& x)
  {
    this->end_.set (x);
  }

  void formatType::
  end (const end_optional& x)
  {
    this->end_ = x;
  }

  void formatType::
  end (::std::auto_ptr< end_type > x)
  {
    this->end_.set (x);
  }

  const formatType::duration_optional& formatType::
  duration () const
  {
    return this->duration_;
  }

  formatType::duration_optional& formatType::
  duration ()
  {
    return this->duration_;
  }

  void formatType::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void formatType::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void formatType::
  duration (::std::auto_ptr< duration_type > x)
  {
    this->duration_.set (x);
  }

  const formatType::fileSize_optional& formatType::
  fileSize () const
  {
    return this->fileSize_;
  }

  formatType::fileSize_optional& formatType::
  fileSize ()
  {
    return this->fileSize_;
  }

  void formatType::
  fileSize (const fileSize_type& x)
  {
    this->fileSize_.set (x);
  }

  void formatType::
  fileSize (const fileSize_optional& x)
  {
    this->fileSize_ = x;
  }

  const formatType::filename_optional& formatType::
  filename () const
  {
    return this->filename_;
  }

  formatType::filename_optional& formatType::
  filename ()
  {
    return this->filename_;
  }

  void formatType::
  filename (const filename_type& x)
  {
    this->filename_.set (x);
  }

  void formatType::
  filename (const filename_optional& x)
  {
    this->filename_ = x;
  }

  void formatType::
  filename (::std::auto_ptr< filename_type > x)
  {
    this->filename_.set (x);
  }

  const formatType::locator_optional& formatType::
  locator () const
  {
    return this->locator_;
  }

  formatType::locator_optional& formatType::
  locator ()
  {
    return this->locator_;
  }

  void formatType::
  locator (const locator_type& x)
  {
    this->locator_.set (x);
  }

  void formatType::
  locator (const locator_optional& x)
  {
    this->locator_ = x;
  }

  void formatType::
  locator (::std::auto_ptr< locator_type > x)
  {
    this->locator_.set (x);
  }

  const formatType::documentFormat_optional& formatType::
  documentFormat () const
  {
    return this->documentFormat_;
  }

  formatType::documentFormat_optional& formatType::
  documentFormat ()
  {
    return this->documentFormat_;
  }

  void formatType::
  documentFormat (const documentFormat_type& x)
  {
    this->documentFormat_.set (x);
  }

  void formatType::
  documentFormat (const documentFormat_optional& x)
  {
    this->documentFormat_ = x;
  }

  void formatType::
  documentFormat (::std::auto_ptr< documentFormat_type > x)
  {
    this->documentFormat_.set (x);
  }

  const formatType::technicalAttributeString_sequence& formatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  formatType::technicalAttributeString_sequence& formatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void formatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const formatType::technicalAttributeByte_sequence& formatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  formatType::technicalAttributeByte_sequence& formatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void formatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const formatType::technicalAttributeShort_sequence& formatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  formatType::technicalAttributeShort_sequence& formatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void formatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const formatType::technicalAttributeInteger_sequence& formatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  formatType::technicalAttributeInteger_sequence& formatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void formatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const formatType::technicalAttributeLong_sequence& formatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  formatType::technicalAttributeLong_sequence& formatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void formatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const formatType::technicalAttributeUnsignedByte_sequence& formatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  formatType::technicalAttributeUnsignedByte_sequence& formatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void formatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const formatType::technicalAttributeUnsignedShort_sequence& formatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  formatType::technicalAttributeUnsignedShort_sequence& formatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void formatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const formatType::technicalAttributeUnsignedInteger_sequence& formatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  formatType::technicalAttributeUnsignedInteger_sequence& formatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void formatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const formatType::technicalAttributeUnsignedLong_sequence& formatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  formatType::technicalAttributeUnsignedLong_sequence& formatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void formatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const formatType::technicalAttributeBoolean_sequence& formatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  formatType::technicalAttributeBoolean_sequence& formatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void formatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const formatType::technicalAttributeFloat_sequence& formatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  formatType::technicalAttributeFloat_sequence& formatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void formatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const formatType::technicalAttributeRational_sequence& formatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  formatType::technicalAttributeRational_sequence& formatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void formatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const formatType::technicalAttributeUri_sequence& formatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  formatType::technicalAttributeUri_sequence& formatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void formatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const formatType::dateCreated_optional& formatType::
  dateCreated () const
  {
    return this->dateCreated_;
  }

  formatType::dateCreated_optional& formatType::
  dateCreated ()
  {
    return this->dateCreated_;
  }

  void formatType::
  dateCreated (const dateCreated_type& x)
  {
    this->dateCreated_.set (x);
  }

  void formatType::
  dateCreated (const dateCreated_optional& x)
  {
    this->dateCreated_ = x;
  }

  void formatType::
  dateCreated (::std::auto_ptr< dateCreated_type > x)
  {
    this->dateCreated_.set (x);
  }

  const formatType::dateModified_optional& formatType::
  dateModified () const
  {
    return this->dateModified_;
  }

  formatType::dateModified_optional& formatType::
  dateModified ()
  {
    return this->dateModified_;
  }

  void formatType::
  dateModified (const dateModified_type& x)
  {
    this->dateModified_.set (x);
  }

  void formatType::
  dateModified (const dateModified_optional& x)
  {
    this->dateModified_ = x;
  }

  void formatType::
  dateModified (::std::auto_ptr< dateModified_type > x)
  {
    this->dateModified_.set (x);
  }

  const formatType::formatId_optional& formatType::
  formatId () const
  {
    return this->formatId_;
  }

  formatType::formatId_optional& formatType::
  formatId ()
  {
    return this->formatId_;
  }

  void formatType::
  formatId (const formatId_type& x)
  {
    this->formatId_.set (x);
  }

  void formatType::
  formatId (const formatId_optional& x)
  {
    this->formatId_ = x;
  }

  void formatType::
  formatId (::std::auto_ptr< formatId_type > x)
  {
    this->formatId_.set (x);
  }

  const formatType::formatName_optional& formatType::
  formatName () const
  {
    return this->formatName_;
  }

  formatType::formatName_optional& formatType::
  formatName ()
  {
    return this->formatName_;
  }

  void formatType::
  formatName (const formatName_type& x)
  {
    this->formatName_.set (x);
  }

  void formatType::
  formatName (const formatName_optional& x)
  {
    this->formatName_ = x;
  }

  void formatType::
  formatName (::std::auto_ptr< formatName_type > x)
  {
    this->formatName_.set (x);
  }

  const formatType::formatDefinition_optional& formatType::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  formatType::formatDefinition_optional& formatType::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void formatType::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void formatType::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void formatType::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }


  // relationType
  // 

  const relationType::relation_optional& relationType::
  relation () const
  {
    return this->relation_;
  }

  relationType::relation_optional& relationType::
  relation ()
  {
    return this->relation_;
  }

  void relationType::
  relation (const relation_type& x)
  {
    this->relation_.set (x);
  }

  void relationType::
  relation (const relation_optional& x)
  {
    this->relation_ = x;
  }

  void relationType::
  relation (::std::auto_ptr< relation_type > x)
  {
    this->relation_.set (x);
  }

  const relationType::relationIdentifier_optional& relationType::
  relationIdentifier () const
  {
    return this->relationIdentifier_;
  }

  relationType::relationIdentifier_optional& relationType::
  relationIdentifier ()
  {
    return this->relationIdentifier_;
  }

  void relationType::
  relationIdentifier (const relationIdentifier_type& x)
  {
    this->relationIdentifier_.set (x);
  }

  void relationType::
  relationIdentifier (const relationIdentifier_optional& x)
  {
    this->relationIdentifier_ = x;
  }

  void relationType::
  relationIdentifier (::std::auto_ptr< relationIdentifier_type > x)
  {
    this->relationIdentifier_.set (x);
  }

  const relationType::relationLink_optional& relationType::
  relationLink () const
  {
    return this->relationLink_;
  }

  relationType::relationLink_optional& relationType::
  relationLink ()
  {
    return this->relationLink_;
  }

  void relationType::
  relationLink (const relationLink_type& x)
  {
    this->relationLink_.set (x);
  }

  void relationType::
  relationLink (const relationLink_optional& x)
  {
    this->relationLink_ = x;
  }

  void relationType::
  relationLink (::std::auto_ptr< relationLink_type > x)
  {
    this->relationLink_.set (x);
  }

  const relationType::typeLabel_optional& relationType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  relationType::typeLabel_optional& relationType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void relationType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void relationType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void relationType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const relationType::typeDefinition_optional& relationType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  relationType::typeDefinition_optional& relationType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void relationType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void relationType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void relationType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const relationType::typeLink_optional& relationType::
  typeLink () const
  {
    return this->typeLink_;
  }

  relationType::typeLink_optional& relationType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void relationType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void relationType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void relationType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const relationType::runningOrderNumber_optional& relationType::
  runningOrderNumber () const
  {
    return this->runningOrderNumber_;
  }

  relationType::runningOrderNumber_optional& relationType::
  runningOrderNumber ()
  {
    return this->runningOrderNumber_;
  }

  void relationType::
  runningOrderNumber (const runningOrderNumber_type& x)
  {
    this->runningOrderNumber_.set (x);
  }

  void relationType::
  runningOrderNumber (const runningOrderNumber_optional& x)
  {
    this->runningOrderNumber_ = x;
  }

  const relationType::note_optional& relationType::
  note () const
  {
    return this->note_;
  }

  relationType::note_optional& relationType::
  note ()
  {
    return this->note_;
  }

  void relationType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void relationType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void relationType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // languageType
  // 

  const languageType::language_optional& languageType::
  language () const
  {
    return this->language_;
  }

  languageType::language_optional& languageType::
  language ()
  {
    return this->language_;
  }

  void languageType::
  language (const language_type& x)
  {
    this->language_.set (x);
  }

  void languageType::
  language (const language_optional& x)
  {
    this->language_ = x;
  }

  void languageType::
  language (::std::auto_ptr< language_type > x)
  {
    this->language_.set (x);
  }

  const languageType::typeLabel_optional& languageType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  languageType::typeLabel_optional& languageType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void languageType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void languageType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void languageType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const languageType::typeDefinition_optional& languageType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  languageType::typeDefinition_optional& languageType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void languageType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void languageType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void languageType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const languageType::typeLink_optional& languageType::
  typeLink () const
  {
    return this->typeLink_;
  }

  languageType::typeLink_optional& languageType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void languageType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void languageType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void languageType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const languageType::note_optional& languageType::
  note () const
  {
    return this->note_;
  }

  languageType::note_optional& languageType::
  note ()
  {
    return this->note_;
  }

  void languageType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void languageType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void languageType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // dateType
  // 

  const dateType::date_sequence& dateType::
  date () const
  {
    return this->date_;
  }

  dateType::date_sequence& dateType::
  date ()
  {
    return this->date_;
  }

  void dateType::
  date (const date_sequence& s)
  {
    this->date_ = s;
  }

  const dateType::created_optional& dateType::
  created () const
  {
    return this->created_;
  }

  dateType::created_optional& dateType::
  created ()
  {
    return this->created_;
  }

  void dateType::
  created (const created_type& x)
  {
    this->created_.set (x);
  }

  void dateType::
  created (const created_optional& x)
  {
    this->created_ = x;
  }

  void dateType::
  created (::std::auto_ptr< created_type > x)
  {
    this->created_.set (x);
  }

  const dateType::issued_optional& dateType::
  issued () const
  {
    return this->issued_;
  }

  dateType::issued_optional& dateType::
  issued ()
  {
    return this->issued_;
  }

  void dateType::
  issued (const issued_type& x)
  {
    this->issued_.set (x);
  }

  void dateType::
  issued (const issued_optional& x)
  {
    this->issued_ = x;
  }

  void dateType::
  issued (::std::auto_ptr< issued_type > x)
  {
    this->issued_.set (x);
  }

  const dateType::modified_optional& dateType::
  modified () const
  {
    return this->modified_;
  }

  dateType::modified_optional& dateType::
  modified ()
  {
    return this->modified_;
  }

  void dateType::
  modified (const modified_type& x)
  {
    this->modified_.set (x);
  }

  void dateType::
  modified (const modified_optional& x)
  {
    this->modified_ = x;
  }

  void dateType::
  modified (::std::auto_ptr< modified_type > x)
  {
    this->modified_.set (x);
  }

  const dateType::digitised_optional& dateType::
  digitised () const
  {
    return this->digitised_;
  }

  dateType::digitised_optional& dateType::
  digitised ()
  {
    return this->digitised_;
  }

  void dateType::
  digitised (const digitised_type& x)
  {
    this->digitised_.set (x);
  }

  void dateType::
  digitised (const digitised_optional& x)
  {
    this->digitised_ = x;
  }

  void dateType::
  digitised (::std::auto_ptr< digitised_type > x)
  {
    this->digitised_.set (x);
  }

  const dateType::alternative_sequence& dateType::
  alternative () const
  {
    return this->alternative_;
  }

  dateType::alternative_sequence& dateType::
  alternative ()
  {
    return this->alternative_;
  }

  void dateType::
  alternative (const alternative_sequence& s)
  {
    this->alternative_ = s;
  }


  // publicationHistoryType
  // 

  const publicationHistoryType::firstPublicationDate_optional& publicationHistoryType::
  firstPublicationDate () const
  {
    return this->firstPublicationDate_;
  }

  publicationHistoryType::firstPublicationDate_optional& publicationHistoryType::
  firstPublicationDate ()
  {
    return this->firstPublicationDate_;
  }

  void publicationHistoryType::
  firstPublicationDate (const firstPublicationDate_type& x)
  {
    this->firstPublicationDate_.set (x);
  }

  void publicationHistoryType::
  firstPublicationDate (const firstPublicationDate_optional& x)
  {
    this->firstPublicationDate_ = x;
  }

  void publicationHistoryType::
  firstPublicationDate (::std::auto_ptr< firstPublicationDate_type > x)
  {
    this->firstPublicationDate_.set (x);
  }

  const publicationHistoryType::firstPublicationTime_optional& publicationHistoryType::
  firstPublicationTime () const
  {
    return this->firstPublicationTime_;
  }

  publicationHistoryType::firstPublicationTime_optional& publicationHistoryType::
  firstPublicationTime ()
  {
    return this->firstPublicationTime_;
  }

  void publicationHistoryType::
  firstPublicationTime (const firstPublicationTime_type& x)
  {
    this->firstPublicationTime_.set (x);
  }

  void publicationHistoryType::
  firstPublicationTime (const firstPublicationTime_optional& x)
  {
    this->firstPublicationTime_ = x;
  }

  void publicationHistoryType::
  firstPublicationTime (::std::auto_ptr< firstPublicationTime_type > x)
  {
    this->firstPublicationTime_.set (x);
  }

  const publicationHistoryType::firstPublicationChannel_optional& publicationHistoryType::
  firstPublicationChannel () const
  {
    return this->firstPublicationChannel_;
  }

  publicationHistoryType::firstPublicationChannel_optional& publicationHistoryType::
  firstPublicationChannel ()
  {
    return this->firstPublicationChannel_;
  }

  void publicationHistoryType::
  firstPublicationChannel (const firstPublicationChannel_type& x)
  {
    this->firstPublicationChannel_.set (x);
  }

  void publicationHistoryType::
  firstPublicationChannel (const firstPublicationChannel_optional& x)
  {
    this->firstPublicationChannel_ = x;
  }

  void publicationHistoryType::
  firstPublicationChannel (::std::auto_ptr< firstPublicationChannel_type > x)
  {
    this->firstPublicationChannel_.set (x);
  }

  const publicationHistoryType::repeatDate_sequence& publicationHistoryType::
  repeatDate () const
  {
    return this->repeatDate_;
  }

  publicationHistoryType::repeatDate_sequence& publicationHistoryType::
  repeatDate ()
  {
    return this->repeatDate_;
  }

  void publicationHistoryType::
  repeatDate (const repeatDate_sequence& s)
  {
    this->repeatDate_ = s;
  }

  const publicationHistoryType::repeatTime_sequence& publicationHistoryType::
  repeatTime () const
  {
    return this->repeatTime_;
  }

  publicationHistoryType::repeatTime_sequence& publicationHistoryType::
  repeatTime ()
  {
    return this->repeatTime_;
  }

  void publicationHistoryType::
  repeatTime (const repeatTime_sequence& s)
  {
    this->repeatTime_ = s;
  }

  const publicationHistoryType::repeatChannel_sequence& publicationHistoryType::
  repeatChannel () const
  {
    return this->repeatChannel_;
  }

  publicationHistoryType::repeatChannel_sequence& publicationHistoryType::
  repeatChannel ()
  {
    return this->repeatChannel_;
  }

  void publicationHistoryType::
  repeatChannel (const repeatChannel_sequence& s)
  {
    this->repeatChannel_ = s;
  }


  // entityType
  // 

  const entityType::contactDetails_sequence& entityType::
  contactDetails () const
  {
    return this->contactDetails_;
  }

  entityType::contactDetails_sequence& entityType::
  contactDetails ()
  {
    return this->contactDetails_;
  }

  void entityType::
  contactDetails (const contactDetails_sequence& s)
  {
    this->contactDetails_ = s;
  }

  const entityType::organisationDetails_optional& entityType::
  organisationDetails () const
  {
    return this->organisationDetails_;
  }

  entityType::organisationDetails_optional& entityType::
  organisationDetails ()
  {
    return this->organisationDetails_;
  }

  void entityType::
  organisationDetails (const organisationDetails_type& x)
  {
    this->organisationDetails_.set (x);
  }

  void entityType::
  organisationDetails (const organisationDetails_optional& x)
  {
    this->organisationDetails_ = x;
  }

  void entityType::
  organisationDetails (::std::auto_ptr< organisationDetails_type > x)
  {
    this->organisationDetails_.set (x);
  }

  const entityType::role_sequence& entityType::
  role () const
  {
    return this->role_;
  }

  entityType::role_sequence& entityType::
  role ()
  {
    return this->role_;
  }

  void entityType::
  role (const role_sequence& s)
  {
    this->role_ = s;
  }

  const entityType::entityId_optional& entityType::
  entityId () const
  {
    return this->entityId_;
  }

  entityType::entityId_optional& entityType::
  entityId ()
  {
    return this->entityId_;
  }

  void entityType::
  entityId (const entityId_type& x)
  {
    this->entityId_.set (x);
  }

  void entityType::
  entityId (const entityId_optional& x)
  {
    this->entityId_ = x;
  }

  void entityType::
  entityId (::std::auto_ptr< entityId_type > x)
  {
    this->entityId_.set (x);
  }


  // contactDetailsType
  // 

  const contactDetailsType::name_optional& contactDetailsType::
  name () const
  {
    return this->name_;
  }

  contactDetailsType::name_optional& contactDetailsType::
  name ()
  {
    return this->name_;
  }

  void contactDetailsType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void contactDetailsType::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void contactDetailsType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const contactDetailsType::givenName_optional& contactDetailsType::
  givenName () const
  {
    return this->givenName_;
  }

  contactDetailsType::givenName_optional& contactDetailsType::
  givenName ()
  {
    return this->givenName_;
  }

  void contactDetailsType::
  givenName (const givenName_type& x)
  {
    this->givenName_.set (x);
  }

  void contactDetailsType::
  givenName (const givenName_optional& x)
  {
    this->givenName_ = x;
  }

  void contactDetailsType::
  givenName (::std::auto_ptr< givenName_type > x)
  {
    this->givenName_.set (x);
  }

  const contactDetailsType::familyName_optional& contactDetailsType::
  familyName () const
  {
    return this->familyName_;
  }

  contactDetailsType::familyName_optional& contactDetailsType::
  familyName ()
  {
    return this->familyName_;
  }

  void contactDetailsType::
  familyName (const familyName_type& x)
  {
    this->familyName_.set (x);
  }

  void contactDetailsType::
  familyName (const familyName_optional& x)
  {
    this->familyName_ = x;
  }

  void contactDetailsType::
  familyName (::std::auto_ptr< familyName_type > x)
  {
    this->familyName_.set (x);
  }

  const contactDetailsType::username_optional& contactDetailsType::
  username () const
  {
    return this->username_;
  }

  contactDetailsType::username_optional& contactDetailsType::
  username ()
  {
    return this->username_;
  }

  void contactDetailsType::
  username (const username_type& x)
  {
    this->username_.set (x);
  }

  void contactDetailsType::
  username (const username_optional& x)
  {
    this->username_ = x;
  }

  void contactDetailsType::
  username (::std::auto_ptr< username_type > x)
  {
    this->username_.set (x);
  }

  const contactDetailsType::occupation_optional& contactDetailsType::
  occupation () const
  {
    return this->occupation_;
  }

  contactDetailsType::occupation_optional& contactDetailsType::
  occupation ()
  {
    return this->occupation_;
  }

  void contactDetailsType::
  occupation (const occupation_type& x)
  {
    this->occupation_.set (x);
  }

  void contactDetailsType::
  occupation (const occupation_optional& x)
  {
    this->occupation_ = x;
  }

  void contactDetailsType::
  occupation (::std::auto_ptr< occupation_type > x)
  {
    this->occupation_.set (x);
  }

  const contactDetailsType::details_sequence& contactDetailsType::
  details () const
  {
    return this->details_;
  }

  contactDetailsType::details_sequence& contactDetailsType::
  details ()
  {
    return this->details_;
  }

  void contactDetailsType::
  details (const details_sequence& s)
  {
    this->details_ = s;
  }

  const contactDetailsType::stageName_sequence& contactDetailsType::
  stageName () const
  {
    return this->stageName_;
  }

  contactDetailsType::stageName_sequence& contactDetailsType::
  stageName ()
  {
    return this->stageName_;
  }

  void contactDetailsType::
  stageName (const stageName_sequence& s)
  {
    this->stageName_ = s;
  }

  const contactDetailsType::relatedContacts_sequence& contactDetailsType::
  relatedContacts () const
  {
    return this->relatedContacts_;
  }

  contactDetailsType::relatedContacts_sequence& contactDetailsType::
  relatedContacts ()
  {
    return this->relatedContacts_;
  }

  void contactDetailsType::
  relatedContacts (const relatedContacts_sequence& s)
  {
    this->relatedContacts_ = s;
  }

  const contactDetailsType::contactId_optional& contactDetailsType::
  contactId () const
  {
    return this->contactId_;
  }

  contactDetailsType::contactId_optional& contactDetailsType::
  contactId ()
  {
    return this->contactId_;
  }

  void contactDetailsType::
  contactId (const contactId_type& x)
  {
    this->contactId_.set (x);
  }

  void contactDetailsType::
  contactId (const contactId_optional& x)
  {
    this->contactId_ = x;
  }

  void contactDetailsType::
  contactId (::std::auto_ptr< contactId_type > x)
  {
    this->contactId_.set (x);
  }


  // organisationDetailsType
  // 

  const organisationDetailsType::organisationName_type& organisationDetailsType::
  organisationName () const
  {
    return this->organisationName_.get ();
  }

  organisationDetailsType::organisationName_type& organisationDetailsType::
  organisationName ()
  {
    return this->organisationName_.get ();
  }

  void organisationDetailsType::
  organisationName (const organisationName_type& x)
  {
    this->organisationName_.set (x);
  }

  void organisationDetailsType::
  organisationName (::std::auto_ptr< organisationName_type > x)
  {
    this->organisationName_.set (x);
  }

  const organisationDetailsType::organisationDepartment_optional& organisationDetailsType::
  organisationDepartment () const
  {
    return this->organisationDepartment_;
  }

  organisationDetailsType::organisationDepartment_optional& organisationDetailsType::
  organisationDepartment ()
  {
    return this->organisationDepartment_;
  }

  void organisationDetailsType::
  organisationDepartment (const organisationDepartment_type& x)
  {
    this->organisationDepartment_.set (x);
  }

  void organisationDetailsType::
  organisationDepartment (const organisationDepartment_optional& x)
  {
    this->organisationDepartment_ = x;
  }

  void organisationDetailsType::
  organisationDepartment (::std::auto_ptr< organisationDepartment_type > x)
  {
    this->organisationDepartment_.set (x);
  }

  const organisationDetailsType::details_sequence& organisationDetailsType::
  details () const
  {
    return this->details_;
  }

  organisationDetailsType::details_sequence& organisationDetailsType::
  details ()
  {
    return this->details_;
  }

  void organisationDetailsType::
  details (const details_sequence& s)
  {
    this->details_ = s;
  }

  const organisationDetailsType::contacts_sequence& organisationDetailsType::
  contacts () const
  {
    return this->contacts_;
  }

  organisationDetailsType::contacts_sequence& organisationDetailsType::
  contacts ()
  {
    return this->contacts_;
  }

  void organisationDetailsType::
  contacts (const contacts_sequence& s)
  {
    this->contacts_ = s;
  }

  const organisationDetailsType::organisationId_optional& organisationDetailsType::
  organisationId () const
  {
    return this->organisationId_;
  }

  organisationDetailsType::organisationId_optional& organisationDetailsType::
  organisationId ()
  {
    return this->organisationId_;
  }

  void organisationDetailsType::
  organisationId (const organisationId_type& x)
  {
    this->organisationId_.set (x);
  }

  void organisationDetailsType::
  organisationId (const organisationId_optional& x)
  {
    this->organisationId_ = x;
  }

  void organisationDetailsType::
  organisationId (::std::auto_ptr< organisationId_type > x)
  {
    this->organisationId_.set (x);
  }


  // detailsType
  // 

  const detailsType::emailAddress_optional& detailsType::
  emailAddress () const
  {
    return this->emailAddress_;
  }

  detailsType::emailAddress_optional& detailsType::
  emailAddress ()
  {
    return this->emailAddress_;
  }

  void detailsType::
  emailAddress (const emailAddress_type& x)
  {
    this->emailAddress_.set (x);
  }

  void detailsType::
  emailAddress (const emailAddress_optional& x)
  {
    this->emailAddress_ = x;
  }

  void detailsType::
  emailAddress (::std::auto_ptr< emailAddress_type > x)
  {
    this->emailAddress_.set (x);
  }

  const detailsType::webAddress_optional& detailsType::
  webAddress () const
  {
    return this->webAddress_;
  }

  detailsType::webAddress_optional& detailsType::
  webAddress ()
  {
    return this->webAddress_;
  }

  void detailsType::
  webAddress (const webAddress_type& x)
  {
    this->webAddress_.set (x);
  }

  void detailsType::
  webAddress (const webAddress_optional& x)
  {
    this->webAddress_ = x;
  }

  void detailsType::
  webAddress (::std::auto_ptr< webAddress_type > x)
  {
    this->webAddress_.set (x);
  }

  const detailsType::address_optional& detailsType::
  address () const
  {
    return this->address_;
  }

  detailsType::address_optional& detailsType::
  address ()
  {
    return this->address_;
  }

  void detailsType::
  address (const address_type& x)
  {
    this->address_.set (x);
  }

  void detailsType::
  address (const address_optional& x)
  {
    this->address_ = x;
  }

  void detailsType::
  address (::std::auto_ptr< address_type > x)
  {
    this->address_.set (x);
  }

  const detailsType::telephoneNumber_optional& detailsType::
  telephoneNumber () const
  {
    return this->telephoneNumber_;
  }

  detailsType::telephoneNumber_optional& detailsType::
  telephoneNumber ()
  {
    return this->telephoneNumber_;
  }

  void detailsType::
  telephoneNumber (const telephoneNumber_type& x)
  {
    this->telephoneNumber_.set (x);
  }

  void detailsType::
  telephoneNumber (const telephoneNumber_optional& x)
  {
    this->telephoneNumber_ = x;
  }

  void detailsType::
  telephoneNumber (::std::auto_ptr< telephoneNumber_type > x)
  {
    this->telephoneNumber_.set (x);
  }

  const detailsType::mobileTelephoneNumber_optional& detailsType::
  mobileTelephoneNumber () const
  {
    return this->mobileTelephoneNumber_;
  }

  detailsType::mobileTelephoneNumber_optional& detailsType::
  mobileTelephoneNumber ()
  {
    return this->mobileTelephoneNumber_;
  }

  void detailsType::
  mobileTelephoneNumber (const mobileTelephoneNumber_type& x)
  {
    this->mobileTelephoneNumber_.set (x);
  }

  void detailsType::
  mobileTelephoneNumber (const mobileTelephoneNumber_optional& x)
  {
    this->mobileTelephoneNumber_ = x;
  }

  void detailsType::
  mobileTelephoneNumber (::std::auto_ptr< mobileTelephoneNumber_type > x)
  {
    this->mobileTelephoneNumber_.set (x);
  }

  const detailsType::typeLabel_optional& detailsType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  detailsType::typeLabel_optional& detailsType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void detailsType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void detailsType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void detailsType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const detailsType::typeDefinition_optional& detailsType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  detailsType::typeDefinition_optional& detailsType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void detailsType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void detailsType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void detailsType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const detailsType::typeLink_optional& detailsType::
  typeLink () const
  {
    return this->typeLink_;
  }

  detailsType::typeLink_optional& detailsType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void detailsType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void detailsType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void detailsType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // addressType
  // 

  const addressType::addressLine_sequence& addressType::
  addressLine () const
  {
    return this->addressLine_;
  }

  addressType::addressLine_sequence& addressType::
  addressLine ()
  {
    return this->addressLine_;
  }

  void addressType::
  addressLine (const addressLine_sequence& s)
  {
    this->addressLine_ = s;
  }

  const addressType::addressTownCity_optional& addressType::
  addressTownCity () const
  {
    return this->addressTownCity_;
  }

  addressType::addressTownCity_optional& addressType::
  addressTownCity ()
  {
    return this->addressTownCity_;
  }

  void addressType::
  addressTownCity (const addressTownCity_type& x)
  {
    this->addressTownCity_.set (x);
  }

  void addressType::
  addressTownCity (const addressTownCity_optional& x)
  {
    this->addressTownCity_ = x;
  }

  void addressType::
  addressTownCity (::std::auto_ptr< addressTownCity_type > x)
  {
    this->addressTownCity_.set (x);
  }

  const addressType::addressCountyState_optional& addressType::
  addressCountyState () const
  {
    return this->addressCountyState_;
  }

  addressType::addressCountyState_optional& addressType::
  addressCountyState ()
  {
    return this->addressCountyState_;
  }

  void addressType::
  addressCountyState (const addressCountyState_type& x)
  {
    this->addressCountyState_.set (x);
  }

  void addressType::
  addressCountyState (const addressCountyState_optional& x)
  {
    this->addressCountyState_ = x;
  }

  void addressType::
  addressCountyState (::std::auto_ptr< addressCountyState_type > x)
  {
    this->addressCountyState_.set (x);
  }

  const addressType::addressDeliveryCode_optional& addressType::
  addressDeliveryCode () const
  {
    return this->addressDeliveryCode_;
  }

  addressType::addressDeliveryCode_optional& addressType::
  addressDeliveryCode ()
  {
    return this->addressDeliveryCode_;
  }

  void addressType::
  addressDeliveryCode (const addressDeliveryCode_type& x)
  {
    this->addressDeliveryCode_.set (x);
  }

  void addressType::
  addressDeliveryCode (const addressDeliveryCode_optional& x)
  {
    this->addressDeliveryCode_ = x;
  }

  void addressType::
  addressDeliveryCode (::std::auto_ptr< addressDeliveryCode_type > x)
  {
    this->addressDeliveryCode_.set (x);
  }

  const addressType::country_optional& addressType::
  country () const
  {
    return this->country_;
  }

  addressType::country_optional& addressType::
  country ()
  {
    return this->country_;
  }

  void addressType::
  country (const country_type& x)
  {
    this->country_.set (x);
  }

  void addressType::
  country (const country_optional& x)
  {
    this->country_ = x;
  }

  void addressType::
  country (::std::auto_ptr< country_type > x)
  {
    this->country_.set (x);
  }


  // editUnitNumberType
  // 

  const editUnitNumberType::editRate_optional& editUnitNumberType::
  editRate () const
  {
    return this->editRate_;
  }

  editUnitNumberType::editRate_optional& editUnitNumberType::
  editRate ()
  {
    return this->editRate_;
  }

  void editUnitNumberType::
  editRate (const editRate_type& x)
  {
    this->editRate_.set (x);
  }

  void editUnitNumberType::
  editRate (const editRate_optional& x)
  {
    this->editRate_ = x;
  }

  const editUnitNumberType::factorNumerator_type& editUnitNumberType::
  factorNumerator () const
  {
    return this->factorNumerator_.get ();
  }

  editUnitNumberType::factorNumerator_type& editUnitNumberType::
  factorNumerator ()
  {
    return this->factorNumerator_.get ();
  }

  void editUnitNumberType::
  factorNumerator (const factorNumerator_type& x)
  {
    this->factorNumerator_.set (x);
  }

  editUnitNumberType::factorNumerator_type editUnitNumberType::
  factorNumerator_default_value ()
  {
    return factorNumerator_type (1ULL);
  }

  const editUnitNumberType::factorDenominator_type& editUnitNumberType::
  factorDenominator () const
  {
    return this->factorDenominator_.get ();
  }

  editUnitNumberType::factorDenominator_type& editUnitNumberType::
  factorDenominator ()
  {
    return this->factorDenominator_.get ();
  }

  void editUnitNumberType::
  factorDenominator (const factorDenominator_type& x)
  {
    this->factorDenominator_.set (x);
  }

  editUnitNumberType::factorDenominator_type editUnitNumberType::
  factorDenominator_default_value ()
  {
    return factorDenominator_type (1ULL);
  }


  // ratingType
  // 

  const ratingType::ratingValue_type& ratingType::
  ratingValue () const
  {
    return this->ratingValue_.get ();
  }

  ratingType::ratingValue_type& ratingType::
  ratingValue ()
  {
    return this->ratingValue_.get ();
  }

  void ratingType::
  ratingValue (const ratingValue_type& x)
  {
    this->ratingValue_.set (x);
  }

  void ratingType::
  ratingValue (::std::auto_ptr< ratingValue_type > x)
  {
    this->ratingValue_.set (x);
  }

  const ratingType::ratingScaleMaxValue_type& ratingType::
  ratingScaleMaxValue () const
  {
    return this->ratingScaleMaxValue_.get ();
  }

  ratingType::ratingScaleMaxValue_type& ratingType::
  ratingScaleMaxValue ()
  {
    return this->ratingScaleMaxValue_.get ();
  }

  void ratingType::
  ratingScaleMaxValue (const ratingScaleMaxValue_type& x)
  {
    this->ratingScaleMaxValue_.set (x);
  }

  void ratingType::
  ratingScaleMaxValue (::std::auto_ptr< ratingScaleMaxValue_type > x)
  {
    this->ratingScaleMaxValue_.set (x);
  }

  const ratingType::ratingScaleMinValue_type& ratingType::
  ratingScaleMinValue () const
  {
    return this->ratingScaleMinValue_.get ();
  }

  ratingType::ratingScaleMinValue_type& ratingType::
  ratingScaleMinValue ()
  {
    return this->ratingScaleMinValue_.get ();
  }

  void ratingType::
  ratingScaleMinValue (const ratingScaleMinValue_type& x)
  {
    this->ratingScaleMinValue_.set (x);
  }

  void ratingType::
  ratingScaleMinValue (::std::auto_ptr< ratingScaleMinValue_type > x)
  {
    this->ratingScaleMinValue_.set (x);
  }

  const ratingType::ratingProvider_type& ratingType::
  ratingProvider () const
  {
    return this->ratingProvider_.get ();
  }

  ratingType::ratingProvider_type& ratingType::
  ratingProvider ()
  {
    return this->ratingProvider_.get ();
  }

  void ratingType::
  ratingProvider (const ratingProvider_type& x)
  {
    this->ratingProvider_.set (x);
  }

  void ratingType::
  ratingProvider (::std::auto_ptr< ratingProvider_type > x)
  {
    this->ratingProvider_.set (x);
  }

  const ratingType::typeLabel_optional& ratingType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  ratingType::typeLabel_optional& ratingType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void ratingType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void ratingType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void ratingType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const ratingType::typeDefinition_optional& ratingType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  ratingType::typeDefinition_optional& ratingType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void ratingType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void ratingType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void ratingType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const ratingType::typeLink_optional& ratingType::
  typeLink () const
  {
    return this->typeLink_;
  }

  ratingType::typeLink_optional& ratingType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void ratingType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void ratingType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void ratingType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const ratingType::formatLabel_optional& ratingType::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  ratingType::formatLabel_optional& ratingType::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void ratingType::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void ratingType::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void ratingType::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const ratingType::formatDefinition_optional& ratingType::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  ratingType::formatDefinition_optional& ratingType::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void ratingType::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void ratingType::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void ratingType::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const ratingType::formatLink_optional& ratingType::
  formatLink () const
  {
    return this->formatLink_;
  }

  ratingType::formatLink_optional& ratingType::
  formatLink ()
  {
    return this->formatLink_;
  }

  void ratingType::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void ratingType::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void ratingType::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }


  // lengthType
  // 

  const lengthType::unit_optional& lengthType::
  unit () const
  {
    return this->unit_;
  }

  lengthType::unit_optional& lengthType::
  unit ()
  {
    return this->unit_;
  }

  void lengthType::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void lengthType::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void lengthType::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }


  // imageFormatType
  // 

  const imageFormatType::regionDelimX_optional& imageFormatType::
  regionDelimX () const
  {
    return this->regionDelimX_;
  }

  imageFormatType::regionDelimX_optional& imageFormatType::
  regionDelimX ()
  {
    return this->regionDelimX_;
  }

  void imageFormatType::
  regionDelimX (const regionDelimX_type& x)
  {
    this->regionDelimX_.set (x);
  }

  void imageFormatType::
  regionDelimX (const regionDelimX_optional& x)
  {
    this->regionDelimX_ = x;
  }

  const imageFormatType::regionDelimY_optional& imageFormatType::
  regionDelimY () const
  {
    return this->regionDelimY_;
  }

  imageFormatType::regionDelimY_optional& imageFormatType::
  regionDelimY ()
  {
    return this->regionDelimY_;
  }

  void imageFormatType::
  regionDelimY (const regionDelimY_type& x)
  {
    this->regionDelimY_.set (x);
  }

  void imageFormatType::
  regionDelimY (const regionDelimY_optional& x)
  {
    this->regionDelimY_ = x;
  }

  const imageFormatType::width_optional& imageFormatType::
  width () const
  {
    return this->width_;
  }

  imageFormatType::width_optional& imageFormatType::
  width ()
  {
    return this->width_;
  }

  void imageFormatType::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void imageFormatType::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void imageFormatType::
  width (::std::auto_ptr< width_type > x)
  {
    this->width_.set (x);
  }

  const imageFormatType::height_optional& imageFormatType::
  height () const
  {
    return this->height_;
  }

  imageFormatType::height_optional& imageFormatType::
  height ()
  {
    return this->height_;
  }

  void imageFormatType::
  height (const height_type& x)
  {
    this->height_.set (x);
  }

  void imageFormatType::
  height (const height_optional& x)
  {
    this->height_ = x;
  }

  void imageFormatType::
  height (::std::auto_ptr< height_type > x)
  {
    this->height_.set (x);
  }

  const imageFormatType::orientation_optional& imageFormatType::
  orientation () const
  {
    return this->orientation_;
  }

  imageFormatType::orientation_optional& imageFormatType::
  orientation ()
  {
    return this->orientation_;
  }

  void imageFormatType::
  orientation (const orientation_type& x)
  {
    this->orientation_.set (x);
  }

  void imageFormatType::
  orientation (const orientation_optional& x)
  {
    this->orientation_ = x;
  }

  void imageFormatType::
  orientation (::std::auto_ptr< orientation_type > x)
  {
    this->orientation_.set (x);
  }

  const imageFormatType::imageEncoding_sequence& imageFormatType::
  imageEncoding () const
  {
    return this->imageEncoding_;
  }

  imageFormatType::imageEncoding_sequence& imageFormatType::
  imageEncoding ()
  {
    return this->imageEncoding_;
  }

  void imageFormatType::
  imageEncoding (const imageEncoding_sequence& s)
  {
    this->imageEncoding_ = s;
  }

  const imageFormatType::technicalAttributeString_sequence& imageFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  imageFormatType::technicalAttributeString_sequence& imageFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void imageFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const imageFormatType::technicalAttributeByte_sequence& imageFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  imageFormatType::technicalAttributeByte_sequence& imageFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void imageFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const imageFormatType::technicalAttributeShort_sequence& imageFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  imageFormatType::technicalAttributeShort_sequence& imageFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void imageFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const imageFormatType::technicalAttributeInteger_sequence& imageFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  imageFormatType::technicalAttributeInteger_sequence& imageFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void imageFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const imageFormatType::technicalAttributeLong_sequence& imageFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  imageFormatType::technicalAttributeLong_sequence& imageFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void imageFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const imageFormatType::technicalAttributeUnsignedByte_sequence& imageFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  imageFormatType::technicalAttributeUnsignedByte_sequence& imageFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void imageFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const imageFormatType::technicalAttributeUnsignedShort_sequence& imageFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  imageFormatType::technicalAttributeUnsignedShort_sequence& imageFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void imageFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const imageFormatType::technicalAttributeUnsignedInteger_sequence& imageFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  imageFormatType::technicalAttributeUnsignedInteger_sequence& imageFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void imageFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const imageFormatType::technicalAttributeUnsignedLong_sequence& imageFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  imageFormatType::technicalAttributeUnsignedLong_sequence& imageFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void imageFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const imageFormatType::technicalAttributeBoolean_sequence& imageFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  imageFormatType::technicalAttributeBoolean_sequence& imageFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void imageFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const imageFormatType::technicalAttributeFloat_sequence& imageFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  imageFormatType::technicalAttributeFloat_sequence& imageFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void imageFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const imageFormatType::technicalAttributeRational_sequence& imageFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  imageFormatType::technicalAttributeRational_sequence& imageFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void imageFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const imageFormatType::technicalAttributeUri_sequence& imageFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  imageFormatType::technicalAttributeUri_sequence& imageFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void imageFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const imageFormatType::imageFormatId_optional& imageFormatType::
  imageFormatId () const
  {
    return this->imageFormatId_;
  }

  imageFormatType::imageFormatId_optional& imageFormatType::
  imageFormatId ()
  {
    return this->imageFormatId_;
  }

  void imageFormatType::
  imageFormatId (const imageFormatId_type& x)
  {
    this->imageFormatId_.set (x);
  }

  void imageFormatType::
  imageFormatId (const imageFormatId_optional& x)
  {
    this->imageFormatId_ = x;
  }

  void imageFormatType::
  imageFormatId (::std::auto_ptr< imageFormatId_type > x)
  {
    this->imageFormatId_.set (x);
  }

  const imageFormatType::imageFormatName_optional& imageFormatType::
  imageFormatName () const
  {
    return this->imageFormatName_;
  }

  imageFormatType::imageFormatName_optional& imageFormatType::
  imageFormatName ()
  {
    return this->imageFormatName_;
  }

  void imageFormatType::
  imageFormatName (const imageFormatName_type& x)
  {
    this->imageFormatName_.set (x);
  }

  void imageFormatType::
  imageFormatName (const imageFormatName_optional& x)
  {
    this->imageFormatName_ = x;
  }

  void imageFormatType::
  imageFormatName (::std::auto_ptr< imageFormatName_type > x)
  {
    this->imageFormatName_.set (x);
  }

  const imageFormatType::imageFormatDefinition_optional& imageFormatType::
  imageFormatDefinition () const
  {
    return this->imageFormatDefinition_;
  }

  imageFormatType::imageFormatDefinition_optional& imageFormatType::
  imageFormatDefinition ()
  {
    return this->imageFormatDefinition_;
  }

  void imageFormatType::
  imageFormatDefinition (const imageFormatDefinition_type& x)
  {
    this->imageFormatDefinition_.set (x);
  }

  void imageFormatType::
  imageFormatDefinition (const imageFormatDefinition_optional& x)
  {
    this->imageFormatDefinition_ = x;
  }

  void imageFormatType::
  imageFormatDefinition (::std::auto_ptr< imageFormatDefinition_type > x)
  {
    this->imageFormatDefinition_.set (x);
  }


  // videoFormatType
  // 

  const videoFormatType::regionDelimX_optional& videoFormatType::
  regionDelimX () const
  {
    return this->regionDelimX_;
  }

  videoFormatType::regionDelimX_optional& videoFormatType::
  regionDelimX ()
  {
    return this->regionDelimX_;
  }

  void videoFormatType::
  regionDelimX (const regionDelimX_type& x)
  {
    this->regionDelimX_.set (x);
  }

  void videoFormatType::
  regionDelimX (const regionDelimX_optional& x)
  {
    this->regionDelimX_ = x;
  }

  const videoFormatType::regionDelimY_optional& videoFormatType::
  regionDelimY () const
  {
    return this->regionDelimY_;
  }

  videoFormatType::regionDelimY_optional& videoFormatType::
  regionDelimY ()
  {
    return this->regionDelimY_;
  }

  void videoFormatType::
  regionDelimY (const regionDelimY_type& x)
  {
    this->regionDelimY_.set (x);
  }

  void videoFormatType::
  regionDelimY (const regionDelimY_optional& x)
  {
    this->regionDelimY_ = x;
  }

  const videoFormatType::width_optional& videoFormatType::
  width () const
  {
    return this->width_;
  }

  videoFormatType::width_optional& videoFormatType::
  width ()
  {
    return this->width_;
  }

  void videoFormatType::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void videoFormatType::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void videoFormatType::
  width (::std::auto_ptr< width_type > x)
  {
    this->width_.set (x);
  }

  const videoFormatType::height_optional& videoFormatType::
  height () const
  {
    return this->height_;
  }

  videoFormatType::height_optional& videoFormatType::
  height ()
  {
    return this->height_;
  }

  void videoFormatType::
  height (const height_type& x)
  {
    this->height_.set (x);
  }

  void videoFormatType::
  height (const height_optional& x)
  {
    this->height_ = x;
  }

  void videoFormatType::
  height (::std::auto_ptr< height_type > x)
  {
    this->height_.set (x);
  }

  const videoFormatType::aspectRatio_optional& videoFormatType::
  aspectRatio () const
  {
    return this->aspectRatio_;
  }

  videoFormatType::aspectRatio_optional& videoFormatType::
  aspectRatio ()
  {
    return this->aspectRatio_;
  }

  void videoFormatType::
  aspectRatio (const aspectRatio_type& x)
  {
    this->aspectRatio_.set (x);
  }

  void videoFormatType::
  aspectRatio (const aspectRatio_optional& x)
  {
    this->aspectRatio_ = x;
  }

  void videoFormatType::
  aspectRatio (::std::auto_ptr< aspectRatio_type > x)
  {
    this->aspectRatio_.set (x);
  }

  const videoFormatType::videoEncoding_sequence& videoFormatType::
  videoEncoding () const
  {
    return this->videoEncoding_;
  }

  videoFormatType::videoEncoding_sequence& videoFormatType::
  videoEncoding ()
  {
    return this->videoEncoding_;
  }

  void videoFormatType::
  videoEncoding (const videoEncoding_sequence& s)
  {
    this->videoEncoding_ = s;
  }

  const videoFormatType::videoTrack_sequence& videoFormatType::
  videoTrack () const
  {
    return this->videoTrack_;
  }

  videoFormatType::videoTrack_sequence& videoFormatType::
  videoTrack ()
  {
    return this->videoTrack_;
  }

  void videoFormatType::
  videoTrack (const videoTrack_sequence& s)
  {
    this->videoTrack_ = s;
  }

  const videoFormatType::technicalAttributeString_sequence& videoFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  videoFormatType::technicalAttributeString_sequence& videoFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void videoFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const videoFormatType::technicalAttributeByte_sequence& videoFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  videoFormatType::technicalAttributeByte_sequence& videoFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void videoFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const videoFormatType::technicalAttributeShort_sequence& videoFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  videoFormatType::technicalAttributeShort_sequence& videoFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void videoFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const videoFormatType::technicalAttributeInteger_sequence& videoFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  videoFormatType::technicalAttributeInteger_sequence& videoFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void videoFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const videoFormatType::technicalAttributeLong_sequence& videoFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  videoFormatType::technicalAttributeLong_sequence& videoFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void videoFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const videoFormatType::technicalAttributeUnsignedByte_sequence& videoFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  videoFormatType::technicalAttributeUnsignedByte_sequence& videoFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void videoFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const videoFormatType::technicalAttributeUnsignedShort_sequence& videoFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  videoFormatType::technicalAttributeUnsignedShort_sequence& videoFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void videoFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const videoFormatType::technicalAttributeUnsignedInteger_sequence& videoFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  videoFormatType::technicalAttributeUnsignedInteger_sequence& videoFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void videoFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const videoFormatType::technicalAttributeUnsignedLong_sequence& videoFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  videoFormatType::technicalAttributeUnsignedLong_sequence& videoFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void videoFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const videoFormatType::technicalAttributeBoolean_sequence& videoFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  videoFormatType::technicalAttributeBoolean_sequence& videoFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void videoFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const videoFormatType::technicalAttributeFloat_sequence& videoFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  videoFormatType::technicalAttributeFloat_sequence& videoFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void videoFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const videoFormatType::technicalAttributeRational_sequence& videoFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  videoFormatType::technicalAttributeRational_sequence& videoFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void videoFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const videoFormatType::technicalAttributeUri_sequence& videoFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  videoFormatType::technicalAttributeUri_sequence& videoFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void videoFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const videoFormatType::videoFormatId_optional& videoFormatType::
  videoFormatId () const
  {
    return this->videoFormatId_;
  }

  videoFormatType::videoFormatId_optional& videoFormatType::
  videoFormatId ()
  {
    return this->videoFormatId_;
  }

  void videoFormatType::
  videoFormatId (const videoFormatId_type& x)
  {
    this->videoFormatId_.set (x);
  }

  void videoFormatType::
  videoFormatId (const videoFormatId_optional& x)
  {
    this->videoFormatId_ = x;
  }

  void videoFormatType::
  videoFormatId (::std::auto_ptr< videoFormatId_type > x)
  {
    this->videoFormatId_.set (x);
  }

  const videoFormatType::videoFormatName_optional& videoFormatType::
  videoFormatName () const
  {
    return this->videoFormatName_;
  }

  videoFormatType::videoFormatName_optional& videoFormatType::
  videoFormatName ()
  {
    return this->videoFormatName_;
  }

  void videoFormatType::
  videoFormatName (const videoFormatName_type& x)
  {
    this->videoFormatName_.set (x);
  }

  void videoFormatType::
  videoFormatName (const videoFormatName_optional& x)
  {
    this->videoFormatName_ = x;
  }

  void videoFormatType::
  videoFormatName (::std::auto_ptr< videoFormatName_type > x)
  {
    this->videoFormatName_.set (x);
  }

  const videoFormatType::videoFormatDefinition_optional& videoFormatType::
  videoFormatDefinition () const
  {
    return this->videoFormatDefinition_;
  }

  videoFormatType::videoFormatDefinition_optional& videoFormatType::
  videoFormatDefinition ()
  {
    return this->videoFormatDefinition_;
  }

  void videoFormatType::
  videoFormatDefinition (const videoFormatDefinition_type& x)
  {
    this->videoFormatDefinition_.set (x);
  }

  void videoFormatType::
  videoFormatDefinition (const videoFormatDefinition_optional& x)
  {
    this->videoFormatDefinition_ = x;
  }

  void videoFormatType::
  videoFormatDefinition (::std::auto_ptr< videoFormatDefinition_type > x)
  {
    this->videoFormatDefinition_.set (x);
  }


  // audioFormatType
  // 

  const audioFormatType::audioEncoding_sequence& audioFormatType::
  audioEncoding () const
  {
    return this->audioEncoding_;
  }

  audioFormatType::audioEncoding_sequence& audioFormatType::
  audioEncoding ()
  {
    return this->audioEncoding_;
  }

  void audioFormatType::
  audioEncoding (const audioEncoding_sequence& s)
  {
    this->audioEncoding_ = s;
  }

  const audioFormatType::audioTrackConfiguration_optional& audioFormatType::
  audioTrackConfiguration () const
  {
    return this->audioTrackConfiguration_;
  }

  audioFormatType::audioTrackConfiguration_optional& audioFormatType::
  audioTrackConfiguration ()
  {
    return this->audioTrackConfiguration_;
  }

  void audioFormatType::
  audioTrackConfiguration (const audioTrackConfiguration_type& x)
  {
    this->audioTrackConfiguration_.set (x);
  }

  void audioFormatType::
  audioTrackConfiguration (const audioTrackConfiguration_optional& x)
  {
    this->audioTrackConfiguration_ = x;
  }

  void audioFormatType::
  audioTrackConfiguration (::std::auto_ptr< audioTrackConfiguration_type > x)
  {
    this->audioTrackConfiguration_.set (x);
  }

  const audioFormatType::audioTrack_sequence& audioFormatType::
  audioTrack () const
  {
    return this->audioTrack_;
  }

  audioFormatType::audioTrack_sequence& audioFormatType::
  audioTrack ()
  {
    return this->audioTrack_;
  }

  void audioFormatType::
  audioTrack (const audioTrack_sequence& s)
  {
    this->audioTrack_ = s;
  }

  const audioFormatType::technicalAttributeString_sequence& audioFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  audioFormatType::technicalAttributeString_sequence& audioFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void audioFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const audioFormatType::technicalAttributeByte_sequence& audioFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  audioFormatType::technicalAttributeByte_sequence& audioFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void audioFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const audioFormatType::technicalAttributeShort_sequence& audioFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  audioFormatType::technicalAttributeShort_sequence& audioFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void audioFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const audioFormatType::technicalAttributeInteger_sequence& audioFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  audioFormatType::technicalAttributeInteger_sequence& audioFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void audioFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const audioFormatType::technicalAttributeLong_sequence& audioFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  audioFormatType::technicalAttributeLong_sequence& audioFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void audioFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const audioFormatType::technicalAttributeUnsignedByte_sequence& audioFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  audioFormatType::technicalAttributeUnsignedByte_sequence& audioFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void audioFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const audioFormatType::technicalAttributeUnsignedShort_sequence& audioFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  audioFormatType::technicalAttributeUnsignedShort_sequence& audioFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void audioFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const audioFormatType::technicalAttributeUnsignedInteger_sequence& audioFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  audioFormatType::technicalAttributeUnsignedInteger_sequence& audioFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void audioFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const audioFormatType::technicalAttributeUnsignedLong_sequence& audioFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  audioFormatType::technicalAttributeUnsignedLong_sequence& audioFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void audioFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const audioFormatType::technicalAttributeBoolean_sequence& audioFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  audioFormatType::technicalAttributeBoolean_sequence& audioFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void audioFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const audioFormatType::technicalAttributeFloat_sequence& audioFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  audioFormatType::technicalAttributeFloat_sequence& audioFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void audioFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const audioFormatType::technicalAttributeRational_sequence& audioFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  audioFormatType::technicalAttributeRational_sequence& audioFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void audioFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const audioFormatType::technicalAttributeUri_sequence& audioFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  audioFormatType::technicalAttributeUri_sequence& audioFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void audioFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const audioFormatType::audioFormatId_optional& audioFormatType::
  audioFormatId () const
  {
    return this->audioFormatId_;
  }

  audioFormatType::audioFormatId_optional& audioFormatType::
  audioFormatId ()
  {
    return this->audioFormatId_;
  }

  void audioFormatType::
  audioFormatId (const audioFormatId_type& x)
  {
    this->audioFormatId_.set (x);
  }

  void audioFormatType::
  audioFormatId (const audioFormatId_optional& x)
  {
    this->audioFormatId_ = x;
  }

  void audioFormatType::
  audioFormatId (::std::auto_ptr< audioFormatId_type > x)
  {
    this->audioFormatId_.set (x);
  }

  const audioFormatType::audioFormatName_optional& audioFormatType::
  audioFormatName () const
  {
    return this->audioFormatName_;
  }

  audioFormatType::audioFormatName_optional& audioFormatType::
  audioFormatName ()
  {
    return this->audioFormatName_;
  }

  void audioFormatType::
  audioFormatName (const audioFormatName_type& x)
  {
    this->audioFormatName_.set (x);
  }

  void audioFormatType::
  audioFormatName (const audioFormatName_optional& x)
  {
    this->audioFormatName_ = x;
  }

  void audioFormatType::
  audioFormatName (::std::auto_ptr< audioFormatName_type > x)
  {
    this->audioFormatName_.set (x);
  }

  const audioFormatType::audioFormatDefinition_optional& audioFormatType::
  audioFormatDefinition () const
  {
    return this->audioFormatDefinition_;
  }

  audioFormatType::audioFormatDefinition_optional& audioFormatType::
  audioFormatDefinition ()
  {
    return this->audioFormatDefinition_;
  }

  void audioFormatType::
  audioFormatDefinition (const audioFormatDefinition_type& x)
  {
    this->audioFormatDefinition_.set (x);
  }

  void audioFormatType::
  audioFormatDefinition (const audioFormatDefinition_optional& x)
  {
    this->audioFormatDefinition_ = x;
  }

  void audioFormatType::
  audioFormatDefinition (::std::auto_ptr< audioFormatDefinition_type > x)
  {
    this->audioFormatDefinition_.set (x);
  }


  // dataFormatType
  // 

  const dataFormatType::captioningFormat_sequence& dataFormatType::
  captioningFormat () const
  {
    return this->captioningFormat_;
  }

  dataFormatType::captioningFormat_sequence& dataFormatType::
  captioningFormat ()
  {
    return this->captioningFormat_;
  }

  void dataFormatType::
  captioningFormat (const captioningFormat_sequence& s)
  {
    this->captioningFormat_ = s;
  }

  const dataFormatType::ancillaryDataFormat_sequence& dataFormatType::
  ancillaryDataFormat () const
  {
    return this->ancillaryDataFormat_;
  }

  dataFormatType::ancillaryDataFormat_sequence& dataFormatType::
  ancillaryDataFormat ()
  {
    return this->ancillaryDataFormat_;
  }

  void dataFormatType::
  ancillaryDataFormat (const ancillaryDataFormat_sequence& s)
  {
    this->ancillaryDataFormat_ = s;
  }

  const dataFormatType::technicalAttributeString_sequence& dataFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  dataFormatType::technicalAttributeString_sequence& dataFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void dataFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const dataFormatType::technicalAttributeByte_sequence& dataFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  dataFormatType::technicalAttributeByte_sequence& dataFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void dataFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const dataFormatType::technicalAttributeShort_sequence& dataFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  dataFormatType::technicalAttributeShort_sequence& dataFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void dataFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const dataFormatType::technicalAttributeInteger_sequence& dataFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  dataFormatType::technicalAttributeInteger_sequence& dataFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void dataFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const dataFormatType::technicalAttributeLong_sequence& dataFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  dataFormatType::technicalAttributeLong_sequence& dataFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void dataFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const dataFormatType::technicalAttributeUnsignedByte_sequence& dataFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  dataFormatType::technicalAttributeUnsignedByte_sequence& dataFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void dataFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const dataFormatType::technicalAttributeUnsignedShort_sequence& dataFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  dataFormatType::technicalAttributeUnsignedShort_sequence& dataFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void dataFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const dataFormatType::technicalAttributeUnsignedInteger_sequence& dataFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  dataFormatType::technicalAttributeUnsignedInteger_sequence& dataFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void dataFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const dataFormatType::technicalAttributeUnsignedLong_sequence& dataFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  dataFormatType::technicalAttributeUnsignedLong_sequence& dataFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void dataFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const dataFormatType::technicalAttributeBoolean_sequence& dataFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  dataFormatType::technicalAttributeBoolean_sequence& dataFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void dataFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const dataFormatType::technicalAttributeFloat_sequence& dataFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  dataFormatType::technicalAttributeFloat_sequence& dataFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void dataFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const dataFormatType::technicalAttributeRational_sequence& dataFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  dataFormatType::technicalAttributeRational_sequence& dataFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void dataFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const dataFormatType::technicalAttributeUri_sequence& dataFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  dataFormatType::technicalAttributeUri_sequence& dataFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void dataFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const dataFormatType::dataFormatId_optional& dataFormatType::
  dataFormatId () const
  {
    return this->dataFormatId_;
  }

  dataFormatType::dataFormatId_optional& dataFormatType::
  dataFormatId ()
  {
    return this->dataFormatId_;
  }

  void dataFormatType::
  dataFormatId (const dataFormatId_type& x)
  {
    this->dataFormatId_.set (x);
  }

  void dataFormatType::
  dataFormatId (const dataFormatId_optional& x)
  {
    this->dataFormatId_ = x;
  }

  void dataFormatType::
  dataFormatId (::std::auto_ptr< dataFormatId_type > x)
  {
    this->dataFormatId_.set (x);
  }

  const dataFormatType::dataFormatName_optional& dataFormatType::
  dataFormatName () const
  {
    return this->dataFormatName_;
  }

  dataFormatType::dataFormatName_optional& dataFormatType::
  dataFormatName ()
  {
    return this->dataFormatName_;
  }

  void dataFormatType::
  dataFormatName (const dataFormatName_type& x)
  {
    this->dataFormatName_.set (x);
  }

  void dataFormatType::
  dataFormatName (const dataFormatName_optional& x)
  {
    this->dataFormatName_ = x;
  }

  void dataFormatType::
  dataFormatName (::std::auto_ptr< dataFormatName_type > x)
  {
    this->dataFormatName_.set (x);
  }

  const dataFormatType::dataFormatDefinition_optional& dataFormatType::
  dataFormatDefinition () const
  {
    return this->dataFormatDefinition_;
  }

  dataFormatType::dataFormatDefinition_optional& dataFormatType::
  dataFormatDefinition ()
  {
    return this->dataFormatDefinition_;
  }

  void dataFormatType::
  dataFormatDefinition (const dataFormatDefinition_type& x)
  {
    this->dataFormatDefinition_.set (x);
  }

  void dataFormatType::
  dataFormatDefinition (const dataFormatDefinition_optional& x)
  {
    this->dataFormatDefinition_ = x;
  }

  void dataFormatType::
  dataFormatDefinition (::std::auto_ptr< dataFormatDefinition_type > x)
  {
    this->dataFormatDefinition_.set (x);
  }


  // documentFormatType
  // 

  const documentFormatType::wordCount_optional& documentFormatType::
  wordCount () const
  {
    return this->wordCount_;
  }

  documentFormatType::wordCount_optional& documentFormatType::
  wordCount ()
  {
    return this->wordCount_;
  }

  void documentFormatType::
  wordCount (const wordCount_type& x)
  {
    this->wordCount_.set (x);
  }

  void documentFormatType::
  wordCount (const wordCount_optional& x)
  {
    this->wordCount_ = x;
  }

  const documentFormatType::regionDelimX_optional& documentFormatType::
  regionDelimX () const
  {
    return this->regionDelimX_;
  }

  documentFormatType::regionDelimX_optional& documentFormatType::
  regionDelimX ()
  {
    return this->regionDelimX_;
  }

  void documentFormatType::
  regionDelimX (const regionDelimX_type& x)
  {
    this->regionDelimX_.set (x);
  }

  void documentFormatType::
  regionDelimX (const regionDelimX_optional& x)
  {
    this->regionDelimX_ = x;
  }

  const documentFormatType::regionDelimY_optional& documentFormatType::
  regionDelimY () const
  {
    return this->regionDelimY_;
  }

  documentFormatType::regionDelimY_optional& documentFormatType::
  regionDelimY ()
  {
    return this->regionDelimY_;
  }

  void documentFormatType::
  regionDelimY (const regionDelimY_type& x)
  {
    this->regionDelimY_.set (x);
  }

  void documentFormatType::
  regionDelimY (const regionDelimY_optional& x)
  {
    this->regionDelimY_ = x;
  }

  const documentFormatType::width_optional& documentFormatType::
  width () const
  {
    return this->width_;
  }

  documentFormatType::width_optional& documentFormatType::
  width ()
  {
    return this->width_;
  }

  void documentFormatType::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void documentFormatType::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void documentFormatType::
  width (::std::auto_ptr< width_type > x)
  {
    this->width_.set (x);
  }

  const documentFormatType::height_optional& documentFormatType::
  height () const
  {
    return this->height_;
  }

  documentFormatType::height_optional& documentFormatType::
  height ()
  {
    return this->height_;
  }

  void documentFormatType::
  height (const height_type& x)
  {
    this->height_.set (x);
  }

  void documentFormatType::
  height (const height_optional& x)
  {
    this->height_ = x;
  }

  void documentFormatType::
  height (::std::auto_ptr< height_type > x)
  {
    this->height_.set (x);
  }

  const documentFormatType::technicalAttributeString_sequence& documentFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  documentFormatType::technicalAttributeString_sequence& documentFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void documentFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const documentFormatType::technicalAttributeByte_sequence& documentFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  documentFormatType::technicalAttributeByte_sequence& documentFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void documentFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const documentFormatType::technicalAttributeShort_sequence& documentFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  documentFormatType::technicalAttributeShort_sequence& documentFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void documentFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const documentFormatType::technicalAttributeInteger_sequence& documentFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  documentFormatType::technicalAttributeInteger_sequence& documentFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void documentFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const documentFormatType::technicalAttributeLong_sequence& documentFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  documentFormatType::technicalAttributeLong_sequence& documentFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void documentFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const documentFormatType::technicalAttributeUnsignedByte_sequence& documentFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  documentFormatType::technicalAttributeUnsignedByte_sequence& documentFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void documentFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const documentFormatType::technicalAttributeUnsignedShort_sequence& documentFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  documentFormatType::technicalAttributeUnsignedShort_sequence& documentFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void documentFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const documentFormatType::technicalAttributeUnsignedInteger_sequence& documentFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  documentFormatType::technicalAttributeUnsignedInteger_sequence& documentFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void documentFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const documentFormatType::technicalAttributeUnsignedLong_sequence& documentFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  documentFormatType::technicalAttributeUnsignedLong_sequence& documentFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void documentFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const documentFormatType::technicalAttributeBoolean_sequence& documentFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  documentFormatType::technicalAttributeBoolean_sequence& documentFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void documentFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const documentFormatType::technicalAttributeFloat_sequence& documentFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  documentFormatType::technicalAttributeFloat_sequence& documentFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void documentFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const documentFormatType::technicalAttributeRational_sequence& documentFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  documentFormatType::technicalAttributeRational_sequence& documentFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void documentFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const documentFormatType::technicalAttributeUri_sequence& documentFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  documentFormatType::technicalAttributeUri_sequence& documentFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void documentFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const documentFormatType::formatLabel_optional& documentFormatType::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  documentFormatType::formatLabel_optional& documentFormatType::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void documentFormatType::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void documentFormatType::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void documentFormatType::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const documentFormatType::formatDefinition_optional& documentFormatType::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  documentFormatType::formatDefinition_optional& documentFormatType::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void documentFormatType::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void documentFormatType::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void documentFormatType::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const documentFormatType::formatLink_optional& documentFormatType::
  formatLink () const
  {
    return this->formatLink_;
  }

  documentFormatType::formatLink_optional& documentFormatType::
  formatLink ()
  {
    return this->formatLink_;
  }

  void documentFormatType::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void documentFormatType::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void documentFormatType::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const documentFormatType::typeLabel_optional& documentFormatType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  documentFormatType::typeLabel_optional& documentFormatType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void documentFormatType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void documentFormatType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void documentFormatType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const documentFormatType::typeDefinition_optional& documentFormatType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  documentFormatType::typeDefinition_optional& documentFormatType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void documentFormatType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void documentFormatType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void documentFormatType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const documentFormatType::typeLink_optional& documentFormatType::
  typeLink () const
  {
    return this->typeLink_;
  }

  documentFormatType::typeLink_optional& documentFormatType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void documentFormatType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void documentFormatType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void documentFormatType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const documentFormatType::documentFormatId_optional& documentFormatType::
  documentFormatId () const
  {
    return this->documentFormatId_;
  }

  documentFormatType::documentFormatId_optional& documentFormatType::
  documentFormatId ()
  {
    return this->documentFormatId_;
  }

  void documentFormatType::
  documentFormatId (const documentFormatId_type& x)
  {
    this->documentFormatId_.set (x);
  }

  void documentFormatType::
  documentFormatId (const documentFormatId_optional& x)
  {
    this->documentFormatId_ = x;
  }

  void documentFormatType::
  documentFormatId (::std::auto_ptr< documentFormatId_type > x)
  {
    this->documentFormatId_.set (x);
  }

  const documentFormatType::documentFormatName_optional& documentFormatType::
  documentFormatName () const
  {
    return this->documentFormatName_;
  }

  documentFormatType::documentFormatName_optional& documentFormatType::
  documentFormatName ()
  {
    return this->documentFormatName_;
  }

  void documentFormatType::
  documentFormatName (const documentFormatName_type& x)
  {
    this->documentFormatName_.set (x);
  }

  void documentFormatType::
  documentFormatName (const documentFormatName_optional& x)
  {
    this->documentFormatName_ = x;
  }

  void documentFormatType::
  documentFormatName (::std::auto_ptr< documentFormatName_type > x)
  {
    this->documentFormatName_.set (x);
  }

  const documentFormatType::documentFormatDefinition_optional& documentFormatType::
  documentFormatDefinition () const
  {
    return this->documentFormatDefinition_;
  }

  documentFormatType::documentFormatDefinition_optional& documentFormatType::
  documentFormatDefinition ()
  {
    return this->documentFormatDefinition_;
  }

  void documentFormatType::
  documentFormatDefinition (const documentFormatDefinition_type& x)
  {
    this->documentFormatDefinition_.set (x);
  }

  void documentFormatType::
  documentFormatDefinition (const documentFormatDefinition_optional& x)
  {
    this->documentFormatDefinition_ = x;
  }

  void documentFormatType::
  documentFormatDefinition (::std::auto_ptr< documentFormatDefinition_type > x)
  {
    this->documentFormatDefinition_.set (x);
  }


  // timeType
  // 

  const timeType::timecode_optional& timeType::
  timecode () const
  {
    return this->timecode_;
  }

  timeType::timecode_optional& timeType::
  timecode ()
  {
    return this->timecode_;
  }

  void timeType::
  timecode (const timecode_type& x)
  {
    this->timecode_.set (x);
  }

  void timeType::
  timecode (const timecode_optional& x)
  {
    this->timecode_ = x;
  }

  void timeType::
  timecode (::std::auto_ptr< timecode_type > x)
  {
    this->timecode_.set (x);
  }

  const timeType::normalPlayTime_optional& timeType::
  normalPlayTime () const
  {
    return this->normalPlayTime_;
  }

  timeType::normalPlayTime_optional& timeType::
  normalPlayTime ()
  {
    return this->normalPlayTime_;
  }

  void timeType::
  normalPlayTime (const normalPlayTime_type& x)
  {
    this->normalPlayTime_.set (x);
  }

  void timeType::
  normalPlayTime (const normalPlayTime_optional& x)
  {
    this->normalPlayTime_ = x;
  }

  void timeType::
  normalPlayTime (::std::auto_ptr< normalPlayTime_type > x)
  {
    this->normalPlayTime_.set (x);
  }

  const timeType::editUnitNumber_optional& timeType::
  editUnitNumber () const
  {
    return this->editUnitNumber_;
  }

  timeType::editUnitNumber_optional& timeType::
  editUnitNumber ()
  {
    return this->editUnitNumber_;
  }

  void timeType::
  editUnitNumber (const editUnitNumber_type& x)
  {
    this->editUnitNumber_.set (x);
  }

  void timeType::
  editUnitNumber (const editUnitNumber_optional& x)
  {
    this->editUnitNumber_ = x;
  }

  void timeType::
  editUnitNumber (::std::auto_ptr< editUnitNumber_type > x)
  {
    this->editUnitNumber_.set (x);
  }

  const timeType::time_optional& timeType::
  time () const
  {
    return this->time_;
  }

  timeType::time_optional& timeType::
  time ()
  {
    return this->time_;
  }

  void timeType::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  void timeType::
  time (const time_optional& x)
  {
    this->time_ = x;
  }

  void timeType::
  time (::std::auto_ptr< time_type > x)
  {
    this->time_.set (x);
  }


  // durationType
  // 

  const durationType::timecode_optional& durationType::
  timecode () const
  {
    return this->timecode_;
  }

  durationType::timecode_optional& durationType::
  timecode ()
  {
    return this->timecode_;
  }

  void durationType::
  timecode (const timecode_type& x)
  {
    this->timecode_.set (x);
  }

  void durationType::
  timecode (const timecode_optional& x)
  {
    this->timecode_ = x;
  }

  void durationType::
  timecode (::std::auto_ptr< timecode_type > x)
  {
    this->timecode_.set (x);
  }

  const durationType::normalPlayTime_optional& durationType::
  normalPlayTime () const
  {
    return this->normalPlayTime_;
  }

  durationType::normalPlayTime_optional& durationType::
  normalPlayTime ()
  {
    return this->normalPlayTime_;
  }

  void durationType::
  normalPlayTime (const normalPlayTime_type& x)
  {
    this->normalPlayTime_.set (x);
  }

  void durationType::
  normalPlayTime (const normalPlayTime_optional& x)
  {
    this->normalPlayTime_ = x;
  }

  void durationType::
  normalPlayTime (::std::auto_ptr< normalPlayTime_type > x)
  {
    this->normalPlayTime_.set (x);
  }

  const durationType::editUnitNumber_optional& durationType::
  editUnitNumber () const
  {
    return this->editUnitNumber_;
  }

  durationType::editUnitNumber_optional& durationType::
  editUnitNumber ()
  {
    return this->editUnitNumber_;
  }

  void durationType::
  editUnitNumber (const editUnitNumber_type& x)
  {
    this->editUnitNumber_.set (x);
  }

  void durationType::
  editUnitNumber (const editUnitNumber_optional& x)
  {
    this->editUnitNumber_ = x;
  }

  void durationType::
  editUnitNumber (::std::auto_ptr< editUnitNumber_type > x)
  {
    this->editUnitNumber_.set (x);
  }

  const durationType::time_optional& durationType::
  time () const
  {
    return this->time_;
  }

  durationType::time_optional& durationType::
  time ()
  {
    return this->time_;
  }

  void durationType::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  void durationType::
  time (const time_optional& x)
  {
    this->time_ = x;
  }

  void durationType::
  time (::std::auto_ptr< time_type > x)
  {
    this->time_.set (x);
  }


  // String
  // 

  const String::typeLabel_optional& String::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  String::typeLabel_optional& String::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void String::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void String::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void String::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const String::typeDefinition_optional& String::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  String::typeDefinition_optional& String::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void String::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void String::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void String::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const String::typeLink_optional& String::
  typeLink () const
  {
    return this->typeLink_;
  }

  String::typeLink_optional& String::
  typeLink ()
  {
    return this->typeLink_;
  }

  void String::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void String::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void String::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const String::formatLabel_optional& String::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  String::formatLabel_optional& String::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void String::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void String::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void String::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const String::formatDefinition_optional& String::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  String::formatDefinition_optional& String::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void String::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void String::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void String::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const String::formatLink_optional& String::
  formatLink () const
  {
    return this->formatLink_;
  }

  String::formatLink_optional& String::
  formatLink ()
  {
    return this->formatLink_;
  }

  void String::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void String::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void String::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }


  // Boolean
  // 

  const Boolean::typeLabel_optional& Boolean::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Boolean::typeLabel_optional& Boolean::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Boolean::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Boolean::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Boolean::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Boolean::typeDefinition_optional& Boolean::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Boolean::typeDefinition_optional& Boolean::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Boolean::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Boolean::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Boolean::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Boolean::typeLink_optional& Boolean::
  typeLink () const
  {
    return this->typeLink_;
  }

  Boolean::typeLink_optional& Boolean::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Boolean::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Boolean::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Boolean::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // Float
  // 

  const Float::typeLabel_optional& Float::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Float::typeLabel_optional& Float::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Float::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Float::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Float::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Float::typeDefinition_optional& Float::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Float::typeDefinition_optional& Float::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Float::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Float::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Float::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Float::typeLink_optional& Float::
  typeLink () const
  {
    return this->typeLink_;
  }

  Float::typeLink_optional& Float::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Float::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Float::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Float::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // Int8
  // 

  const Int8::typeLabel_optional& Int8::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Int8::typeLabel_optional& Int8::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Int8::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Int8::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Int8::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Int8::typeDefinition_optional& Int8::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Int8::typeDefinition_optional& Int8::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Int8::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Int8::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Int8::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Int8::typeLink_optional& Int8::
  typeLink () const
  {
    return this->typeLink_;
  }

  Int8::typeLink_optional& Int8::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Int8::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Int8::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Int8::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // Int16
  // 

  const Int16::typeLabel_optional& Int16::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Int16::typeLabel_optional& Int16::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Int16::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Int16::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Int16::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Int16::typeDefinition_optional& Int16::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Int16::typeDefinition_optional& Int16::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Int16::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Int16::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Int16::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Int16::typeLink_optional& Int16::
  typeLink () const
  {
    return this->typeLink_;
  }

  Int16::typeLink_optional& Int16::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Int16::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Int16::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Int16::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // Int32
  // 

  const Int32::typeLabel_optional& Int32::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Int32::typeLabel_optional& Int32::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Int32::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Int32::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Int32::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Int32::typeDefinition_optional& Int32::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Int32::typeDefinition_optional& Int32::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Int32::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Int32::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Int32::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Int32::typeLink_optional& Int32::
  typeLink () const
  {
    return this->typeLink_;
  }

  Int32::typeLink_optional& Int32::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Int32::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Int32::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Int32::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // Int64
  // 

  const Int64::typeLabel_optional& Int64::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Int64::typeLabel_optional& Int64::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Int64::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Int64::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Int64::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Int64::typeDefinition_optional& Int64::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Int64::typeDefinition_optional& Int64::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Int64::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Int64::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Int64::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Int64::typeLink_optional& Int64::
  typeLink () const
  {
    return this->typeLink_;
  }

  Int64::typeLink_optional& Int64::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Int64::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Int64::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Int64::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // UInt8
  // 

  const UInt8::typeLabel_optional& UInt8::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  UInt8::typeLabel_optional& UInt8::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void UInt8::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void UInt8::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void UInt8::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const UInt8::typeDefinition_optional& UInt8::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  UInt8::typeDefinition_optional& UInt8::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void UInt8::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void UInt8::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void UInt8::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const UInt8::typeLink_optional& UInt8::
  typeLink () const
  {
    return this->typeLink_;
  }

  UInt8::typeLink_optional& UInt8::
  typeLink ()
  {
    return this->typeLink_;
  }

  void UInt8::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void UInt8::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void UInt8::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // UInt16
  // 

  const UInt16::typeLabel_optional& UInt16::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  UInt16::typeLabel_optional& UInt16::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void UInt16::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void UInt16::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void UInt16::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const UInt16::typeDefinition_optional& UInt16::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  UInt16::typeDefinition_optional& UInt16::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void UInt16::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void UInt16::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void UInt16::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const UInt16::typeLink_optional& UInt16::
  typeLink () const
  {
    return this->typeLink_;
  }

  UInt16::typeLink_optional& UInt16::
  typeLink ()
  {
    return this->typeLink_;
  }

  void UInt16::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void UInt16::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void UInt16::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // UInt32
  // 

  const UInt32::typeLabel_optional& UInt32::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  UInt32::typeLabel_optional& UInt32::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void UInt32::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void UInt32::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void UInt32::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const UInt32::typeDefinition_optional& UInt32::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  UInt32::typeDefinition_optional& UInt32::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void UInt32::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void UInt32::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void UInt32::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const UInt32::typeLink_optional& UInt32::
  typeLink () const
  {
    return this->typeLink_;
  }

  UInt32::typeLink_optional& UInt32::
  typeLink ()
  {
    return this->typeLink_;
  }

  void UInt32::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void UInt32::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void UInt32::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // UInt64
  // 

  const UInt64::typeLabel_optional& UInt64::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  UInt64::typeLabel_optional& UInt64::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void UInt64::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void UInt64::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void UInt64::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const UInt64::typeDefinition_optional& UInt64::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  UInt64::typeDefinition_optional& UInt64::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void UInt64::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void UInt64::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void UInt64::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const UInt64::typeLink_optional& UInt64::
  typeLink () const
  {
    return this->typeLink_;
  }

  UInt64::typeLink_optional& UInt64::
  typeLink ()
  {
    return this->typeLink_;
  }

  void UInt64::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void UInt64::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void UInt64::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // technicalAttributeRationalType
  // 

  const technicalAttributeRationalType::factorNumerator_type& technicalAttributeRationalType::
  factorNumerator () const
  {
    return this->factorNumerator_.get ();
  }

  technicalAttributeRationalType::factorNumerator_type& technicalAttributeRationalType::
  factorNumerator ()
  {
    return this->factorNumerator_.get ();
  }

  void technicalAttributeRationalType::
  factorNumerator (const factorNumerator_type& x)
  {
    this->factorNumerator_.set (x);
  }

  technicalAttributeRationalType::factorNumerator_type technicalAttributeRationalType::
  factorNumerator_default_value ()
  {
    return factorNumerator_type (1LL);
  }

  const technicalAttributeRationalType::factorDenominator_type& technicalAttributeRationalType::
  factorDenominator () const
  {
    return this->factorDenominator_.get ();
  }

  technicalAttributeRationalType::factorDenominator_type& technicalAttributeRationalType::
  factorDenominator ()
  {
    return this->factorDenominator_.get ();
  }

  void technicalAttributeRationalType::
  factorDenominator (const factorDenominator_type& x)
  {
    this->factorDenominator_.set (x);
  }

  technicalAttributeRationalType::factorDenominator_type technicalAttributeRationalType::
  factorDenominator_default_value ()
  {
    return factorDenominator_type (1LL);
  }

  const technicalAttributeRationalType::typeLabel_optional& technicalAttributeRationalType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  technicalAttributeRationalType::typeLabel_optional& technicalAttributeRationalType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void technicalAttributeRationalType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void technicalAttributeRationalType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void technicalAttributeRationalType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const technicalAttributeRationalType::typeDefinition_optional& technicalAttributeRationalType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  technicalAttributeRationalType::typeDefinition_optional& technicalAttributeRationalType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void technicalAttributeRationalType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void technicalAttributeRationalType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void technicalAttributeRationalType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const technicalAttributeRationalType::typeLink_optional& technicalAttributeRationalType::
  typeLink () const
  {
    return this->typeLink_;
  }

  technicalAttributeRationalType::typeLink_optional& technicalAttributeRationalType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void technicalAttributeRationalType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void technicalAttributeRationalType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void technicalAttributeRationalType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // technicalAttributeUriType
  // 

  const technicalAttributeUriType::typeLabel_optional& technicalAttributeUriType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  technicalAttributeUriType::typeLabel_optional& technicalAttributeUriType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void technicalAttributeUriType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void technicalAttributeUriType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void technicalAttributeUriType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const technicalAttributeUriType::typeDefinition_optional& technicalAttributeUriType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  technicalAttributeUriType::typeDefinition_optional& technicalAttributeUriType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void technicalAttributeUriType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void technicalAttributeUriType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void technicalAttributeUriType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const technicalAttributeUriType::typeLink_optional& technicalAttributeUriType::
  typeLink () const
  {
    return this->typeLink_;
  }

  technicalAttributeUriType::typeLink_optional& technicalAttributeUriType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void technicalAttributeUriType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void technicalAttributeUriType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void technicalAttributeUriType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // hasTrackPart
  // 

  const hasTrackPart::trackPartTitle_type& hasTrackPart::
  trackPartTitle () const
  {
    return this->trackPartTitle_.get ();
  }

  hasTrackPart::trackPartTitle_type& hasTrackPart::
  trackPartTitle ()
  {
    return this->trackPartTitle_.get ();
  }

  void hasTrackPart::
  trackPartTitle (const trackPartTitle_type& x)
  {
    this->trackPartTitle_.set (x);
  }

  void hasTrackPart::
  trackPartTitle (::std::auto_ptr< trackPartTitle_type > x)
  {
    this->trackPartTitle_.set (x);
  }

  const hasTrackPart::destinationStart_optional& hasTrackPart::
  destinationStart () const
  {
    return this->destinationStart_;
  }

  hasTrackPart::destinationStart_optional& hasTrackPart::
  destinationStart ()
  {
    return this->destinationStart_;
  }

  void hasTrackPart::
  destinationStart (const destinationStart_type& x)
  {
    this->destinationStart_.set (x);
  }

  void hasTrackPart::
  destinationStart (const destinationStart_optional& x)
  {
    this->destinationStart_ = x;
  }

  void hasTrackPart::
  destinationStart (::std::auto_ptr< destinationStart_type > x)
  {
    this->destinationStart_.set (x);
  }

  const hasTrackPart::destinationEnd_optional& hasTrackPart::
  destinationEnd () const
  {
    return this->destinationEnd_;
  }

  hasTrackPart::destinationEnd_optional& hasTrackPart::
  destinationEnd ()
  {
    return this->destinationEnd_;
  }

  void hasTrackPart::
  destinationEnd (const destinationEnd_type& x)
  {
    this->destinationEnd_.set (x);
  }

  void hasTrackPart::
  destinationEnd (const destinationEnd_optional& x)
  {
    this->destinationEnd_ = x;
  }

  void hasTrackPart::
  destinationEnd (::std::auto_ptr< destinationEnd_type > x)
  {
    this->destinationEnd_.set (x);
  }

  const hasTrackPart::sourceStart_optional& hasTrackPart::
  sourceStart () const
  {
    return this->sourceStart_;
  }

  hasTrackPart::sourceStart_optional& hasTrackPart::
  sourceStart ()
  {
    return this->sourceStart_;
  }

  void hasTrackPart::
  sourceStart (const sourceStart_type& x)
  {
    this->sourceStart_.set (x);
  }

  void hasTrackPart::
  sourceStart (const sourceStart_optional& x)
  {
    this->sourceStart_ = x;
  }

  void hasTrackPart::
  sourceStart (::std::auto_ptr< sourceStart_type > x)
  {
    this->sourceStart_.set (x);
  }

  const hasTrackPart::sourceEnd_optional& hasTrackPart::
  sourceEnd () const
  {
    return this->sourceEnd_;
  }

  hasTrackPart::sourceEnd_optional& hasTrackPart::
  sourceEnd ()
  {
    return this->sourceEnd_;
  }

  void hasTrackPart::
  sourceEnd (const sourceEnd_type& x)
  {
    this->sourceEnd_.set (x);
  }

  void hasTrackPart::
  sourceEnd (const sourceEnd_optional& x)
  {
    this->sourceEnd_ = x;
  }

  void hasTrackPart::
  sourceEnd (::std::auto_ptr< sourceEnd_type > x)
  {
    this->sourceEnd_.set (x);
  }


  // part
  // 

  const part::partId_optional& part::
  partId () const
  {
    return this->partId_;
  }

  part::partId_optional& part::
  partId ()
  {
    return this->partId_;
  }

  void part::
  partId (const partId_type& x)
  {
    this->partId_.set (x);
  }

  void part::
  partId (const partId_optional& x)
  {
    this->partId_ = x;
  }

  void part::
  partId (::std::auto_ptr< partId_type > x)
  {
    this->partId_.set (x);
  }

  const part::partName_optional& part::
  partName () const
  {
    return this->partName_;
  }

  part::partName_optional& part::
  partName ()
  {
    return this->partName_;
  }

  void part::
  partName (const partName_type& x)
  {
    this->partName_.set (x);
  }

  void part::
  partName (const partName_optional& x)
  {
    this->partName_ = x;
  }

  void part::
  partName (::std::auto_ptr< partName_type > x)
  {
    this->partName_.set (x);
  }


  // genre
  // 

  const genre::typeLabel_optional& genre::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  genre::typeLabel_optional& genre::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void genre::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void genre::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void genre::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const genre::typeDefinition_optional& genre::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  genre::typeDefinition_optional& genre::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void genre::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void genre::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void genre::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const genre::typeLink_optional& genre::
  typeLink () const
  {
    return this->typeLink_;
  }

  genre::typeLink_optional& genre::
  typeLink ()
  {
    return this->typeLink_;
  }

  void genre::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void genre::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void genre::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // objectType
  // 

  const objectType::typeLabel_optional& objectType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  objectType::typeLabel_optional& objectType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void objectType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void objectType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void objectType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const objectType::typeDefinition_optional& objectType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  objectType::typeDefinition_optional& objectType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void objectType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void objectType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void objectType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const objectType::typeLink_optional& objectType::
  typeLink () const
  {
    return this->typeLink_;
  }

  objectType::typeLink_optional& objectType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void objectType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void objectType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void objectType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // targetAudience
  // 

  const targetAudience::typeLabel_optional& targetAudience::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  targetAudience::typeLabel_optional& targetAudience::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void targetAudience::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void targetAudience::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void targetAudience::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const targetAudience::typeDefinition_optional& targetAudience::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  targetAudience::typeDefinition_optional& targetAudience::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void targetAudience::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void targetAudience::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void targetAudience::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const targetAudience::typeLink_optional& targetAudience::
  typeLink () const
  {
    return this->typeLink_;
  }

  targetAudience::typeLink_optional& targetAudience::
  typeLink ()
  {
    return this->typeLink_;
  }

  void targetAudience::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void targetAudience::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void targetAudience::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // temporal
  // 

  const temporal::PeriodOfTime_optional& temporal::
  PeriodOfTime () const
  {
    return this->PeriodOfTime_;
  }

  temporal::PeriodOfTime_optional& temporal::
  PeriodOfTime ()
  {
    return this->PeriodOfTime_;
  }

  void temporal::
  PeriodOfTime (const PeriodOfTime_type& x)
  {
    this->PeriodOfTime_.set (x);
  }

  void temporal::
  PeriodOfTime (const PeriodOfTime_optional& x)
  {
    this->PeriodOfTime_ = x;
  }

  void temporal::
  PeriodOfTime (::std::auto_ptr< PeriodOfTime_type > x)
  {
    this->PeriodOfTime_.set (x);
  }

  const temporal::typeLabel_optional& temporal::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  temporal::typeLabel_optional& temporal::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void temporal::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void temporal::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void temporal::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const temporal::typeDefinition_optional& temporal::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  temporal::typeDefinition_optional& temporal::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void temporal::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void temporal::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void temporal::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const temporal::typeLink_optional& temporal::
  typeLink () const
  {
    return this->typeLink_;
  }

  temporal::typeLink_optional& temporal::
  typeLink ()
  {
    return this->typeLink_;
  }

  void temporal::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void temporal::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void temporal::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const temporal::note_optional& temporal::
  note () const
  {
    return this->note_;
  }

  temporal::note_optional& temporal::
  note ()
  {
    return this->note_;
  }

  void temporal::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void temporal::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void temporal::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }

  const temporal::periodId_optional& temporal::
  periodId () const
  {
    return this->periodId_;
  }

  temporal::periodId_optional& temporal::
  periodId ()
  {
    return this->periodId_;
  }

  void temporal::
  periodId (const periodId_type& x)
  {
    this->periodId_.set (x);
  }

  void temporal::
  periodId (const periodId_optional& x)
  {
    this->periodId_ = x;
  }

  void temporal::
  periodId (::std::auto_ptr< periodId_type > x)
  {
    this->periodId_.set (x);
  }


  // spatial
  // 

  const spatial::location_sequence& spatial::
  location () const
  {
    return this->location_;
  }

  spatial::location_sequence& spatial::
  location ()
  {
    return this->location_;
  }

  void spatial::
  location (const location_sequence& s)
  {
    this->location_ = s;
  }


  // medium
  // 

  const medium::typeLabel_optional& medium::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  medium::typeLabel_optional& medium::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void medium::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void medium::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void medium::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const medium::typeDefinition_optional& medium::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  medium::typeDefinition_optional& medium::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void medium::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void medium::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void medium::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const medium::typeLink_optional& medium::
  typeLink () const
  {
    return this->typeLink_;
  }

  medium::typeLink_optional& medium::
  typeLink ()
  {
    return this->typeLink_;
  }

  void medium::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void medium::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void medium::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // mimeType
  // 

  const mimeType::typeLabel_optional& mimeType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  mimeType::typeLabel_optional& mimeType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void mimeType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void mimeType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void mimeType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const mimeType::typeDefinition_optional& mimeType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  mimeType::typeDefinition_optional& mimeType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void mimeType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void mimeType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void mimeType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const mimeType::typeLink_optional& mimeType::
  typeLink () const
  {
    return this->typeLink_;
  }

  mimeType::typeLink_optional& mimeType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void mimeType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void mimeType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void mimeType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // containerFormat
  // 

  const containerFormat::formatLabel_optional& containerFormat::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  containerFormat::formatLabel_optional& containerFormat::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void containerFormat::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void containerFormat::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void containerFormat::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const containerFormat::formatDefinition_optional& containerFormat::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  containerFormat::formatDefinition_optional& containerFormat::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void containerFormat::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void containerFormat::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void containerFormat::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const containerFormat::formatLink_optional& containerFormat::
  formatLink () const
  {
    return this->formatLink_;
  }

  containerFormat::formatLink_optional& containerFormat::
  formatLink ()
  {
    return this->formatLink_;
  }

  void containerFormat::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void containerFormat::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void containerFormat::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }


  // signingFormat
  // 

  const signingFormat::trackId_optional& signingFormat::
  trackId () const
  {
    return this->trackId_;
  }

  signingFormat::trackId_optional& signingFormat::
  trackId ()
  {
    return this->trackId_;
  }

  void signingFormat::
  trackId (const trackId_type& x)
  {
    this->trackId_.set (x);
  }

  void signingFormat::
  trackId (const trackId_optional& x)
  {
    this->trackId_ = x;
  }

  void signingFormat::
  trackId (::std::auto_ptr< trackId_type > x)
  {
    this->trackId_.set (x);
  }

  const signingFormat::trackName_optional& signingFormat::
  trackName () const
  {
    return this->trackName_;
  }

  signingFormat::trackName_optional& signingFormat::
  trackName ()
  {
    return this->trackName_;
  }

  void signingFormat::
  trackName (const trackName_type& x)
  {
    this->trackName_.set (x);
  }

  void signingFormat::
  trackName (const trackName_optional& x)
  {
    this->trackName_ = x;
  }

  void signingFormat::
  trackName (::std::auto_ptr< trackName_type > x)
  {
    this->trackName_.set (x);
  }

  const signingFormat::language_optional& signingFormat::
  language () const
  {
    return this->language_;
  }

  signingFormat::language_optional& signingFormat::
  language ()
  {
    return this->language_;
  }

  void signingFormat::
  language (const language_type& x)
  {
    this->language_.set (x);
  }

  void signingFormat::
  language (const language_optional& x)
  {
    this->language_ = x;
  }

  void signingFormat::
  language (::std::auto_ptr< language_type > x)
  {
    this->language_.set (x);
  }

  const signingFormat::typeLabel_optional& signingFormat::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  signingFormat::typeLabel_optional& signingFormat::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void signingFormat::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void signingFormat::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void signingFormat::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const signingFormat::typeDefinition_optional& signingFormat::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  signingFormat::typeDefinition_optional& signingFormat::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void signingFormat::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void signingFormat::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void signingFormat::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const signingFormat::typeLink_optional& signingFormat::
  typeLink () const
  {
    return this->typeLink_;
  }

  signingFormat::typeLink_optional& signingFormat::
  typeLink ()
  {
    return this->typeLink_;
  }

  void signingFormat::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void signingFormat::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void signingFormat::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const signingFormat::formatLabel_optional& signingFormat::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  signingFormat::formatLabel_optional& signingFormat::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void signingFormat::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void signingFormat::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void signingFormat::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const signingFormat::formatDefinition_optional& signingFormat::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  signingFormat::formatDefinition_optional& signingFormat::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void signingFormat::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void signingFormat::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void signingFormat::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const signingFormat::formatLink_optional& signingFormat::
  formatLink () const
  {
    return this->formatLink_;
  }

  signingFormat::formatLink_optional& signingFormat::
  formatLink ()
  {
    return this->formatLink_;
  }

  void signingFormat::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void signingFormat::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void signingFormat::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const signingFormat::signingSourceUri_optional& signingFormat::
  signingSourceUri () const
  {
    return this->signingSourceUri_;
  }

  signingFormat::signingSourceUri_optional& signingFormat::
  signingSourceUri ()
  {
    return this->signingSourceUri_;
  }

  void signingFormat::
  signingSourceUri (const signingSourceUri_type& x)
  {
    this->signingSourceUri_.set (x);
  }

  void signingFormat::
  signingSourceUri (const signingSourceUri_optional& x)
  {
    this->signingSourceUri_ = x;
  }

  void signingFormat::
  signingSourceUri (::std::auto_ptr< signingSourceUri_type > x)
  {
    this->signingSourceUri_.set (x);
  }

  const signingFormat::signingFormatId_optional& signingFormat::
  signingFormatId () const
  {
    return this->signingFormatId_;
  }

  signingFormat::signingFormatId_optional& signingFormat::
  signingFormatId ()
  {
    return this->signingFormatId_;
  }

  void signingFormat::
  signingFormatId (const signingFormatId_type& x)
  {
    this->signingFormatId_.set (x);
  }

  void signingFormat::
  signingFormatId (const signingFormatId_optional& x)
  {
    this->signingFormatId_ = x;
  }

  void signingFormat::
  signingFormatId (::std::auto_ptr< signingFormatId_type > x)
  {
    this->signingFormatId_.set (x);
  }

  const signingFormat::signingFormatName_optional& signingFormat::
  signingFormatName () const
  {
    return this->signingFormatName_;
  }

  signingFormat::signingFormatName_optional& signingFormat::
  signingFormatName ()
  {
    return this->signingFormatName_;
  }

  void signingFormat::
  signingFormatName (const signingFormatName_type& x)
  {
    this->signingFormatName_.set (x);
  }

  void signingFormat::
  signingFormatName (const signingFormatName_optional& x)
  {
    this->signingFormatName_ = x;
  }

  void signingFormat::
  signingFormatName (::std::auto_ptr< signingFormatName_type > x)
  {
    this->signingFormatName_.set (x);
  }

  const signingFormat::signingFormatDefinition_optional& signingFormat::
  signingFormatDefinition () const
  {
    return this->signingFormatDefinition_;
  }

  signingFormat::signingFormatDefinition_optional& signingFormat::
  signingFormatDefinition ()
  {
    return this->signingFormatDefinition_;
  }

  void signingFormat::
  signingFormatDefinition (const signingFormatDefinition_type& x)
  {
    this->signingFormatDefinition_.set (x);
  }

  void signingFormat::
  signingFormatDefinition (const signingFormatDefinition_optional& x)
  {
    this->signingFormatDefinition_ = x;
  }

  void signingFormat::
  signingFormatDefinition (::std::auto_ptr< signingFormatDefinition_type > x)
  {
    this->signingFormatDefinition_.set (x);
  }


  // locator
  // 

  const locator::typeLabel_optional& locator::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  locator::typeLabel_optional& locator::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void locator::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void locator::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void locator::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const locator::typeDefinition_optional& locator::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  locator::typeDefinition_optional& locator::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void locator::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void locator::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void locator::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const locator::typeLink_optional& locator::
  typeLink () const
  {
    return this->typeLink_;
  }

  locator::typeLink_optional& locator::
  typeLink ()
  {
    return this->typeLink_;
  }

  void locator::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void locator::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void locator::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // dateCreated
  // 

  const dateCreated::startYear_optional& dateCreated::
  startYear () const
  {
    return this->startYear_;
  }

  dateCreated::startYear_optional& dateCreated::
  startYear ()
  {
    return this->startYear_;
  }

  void dateCreated::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void dateCreated::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void dateCreated::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const dateCreated::startDate_optional& dateCreated::
  startDate () const
  {
    return this->startDate_;
  }

  dateCreated::startDate_optional& dateCreated::
  startDate ()
  {
    return this->startDate_;
  }

  void dateCreated::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void dateCreated::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void dateCreated::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const dateCreated::startTime_optional& dateCreated::
  startTime () const
  {
    return this->startTime_;
  }

  dateCreated::startTime_optional& dateCreated::
  startTime ()
  {
    return this->startTime_;
  }

  void dateCreated::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void dateCreated::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void dateCreated::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const dateCreated::endYear_optional& dateCreated::
  endYear () const
  {
    return this->endYear_;
  }

  dateCreated::endYear_optional& dateCreated::
  endYear ()
  {
    return this->endYear_;
  }

  void dateCreated::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void dateCreated::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void dateCreated::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const dateCreated::endDate_optional& dateCreated::
  endDate () const
  {
    return this->endDate_;
  }

  dateCreated::endDate_optional& dateCreated::
  endDate ()
  {
    return this->endDate_;
  }

  void dateCreated::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void dateCreated::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void dateCreated::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const dateCreated::endTime_optional& dateCreated::
  endTime () const
  {
    return this->endTime_;
  }

  dateCreated::endTime_optional& dateCreated::
  endTime ()
  {
    return this->endTime_;
  }

  void dateCreated::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void dateCreated::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void dateCreated::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const dateCreated::period_optional& dateCreated::
  period () const
  {
    return this->period_;
  }

  dateCreated::period_optional& dateCreated::
  period ()
  {
    return this->period_;
  }

  void dateCreated::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void dateCreated::
  period (const period_optional& x)
  {
    this->period_ = x;
  }

  void dateCreated::
  period (::std::auto_ptr< period_type > x)
  {
    this->period_.set (x);
  }


  // dateModified
  // 

  const dateModified::startYear_optional& dateModified::
  startYear () const
  {
    return this->startYear_;
  }

  dateModified::startYear_optional& dateModified::
  startYear ()
  {
    return this->startYear_;
  }

  void dateModified::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void dateModified::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void dateModified::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const dateModified::startDate_optional& dateModified::
  startDate () const
  {
    return this->startDate_;
  }

  dateModified::startDate_optional& dateModified::
  startDate ()
  {
    return this->startDate_;
  }

  void dateModified::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void dateModified::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void dateModified::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const dateModified::startTime_optional& dateModified::
  startTime () const
  {
    return this->startTime_;
  }

  dateModified::startTime_optional& dateModified::
  startTime ()
  {
    return this->startTime_;
  }

  void dateModified::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void dateModified::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void dateModified::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const dateModified::endYear_optional& dateModified::
  endYear () const
  {
    return this->endYear_;
  }

  dateModified::endYear_optional& dateModified::
  endYear ()
  {
    return this->endYear_;
  }

  void dateModified::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void dateModified::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void dateModified::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const dateModified::endDate_optional& dateModified::
  endDate () const
  {
    return this->endDate_;
  }

  dateModified::endDate_optional& dateModified::
  endDate ()
  {
    return this->endDate_;
  }

  void dateModified::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void dateModified::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void dateModified::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const dateModified::endTime_optional& dateModified::
  endTime () const
  {
    return this->endTime_;
  }

  dateModified::endTime_optional& dateModified::
  endTime ()
  {
    return this->endTime_;
  }

  void dateModified::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void dateModified::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void dateModified::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const dateModified::period_optional& dateModified::
  period () const
  {
    return this->period_;
  }

  dateModified::period_optional& dateModified::
  period ()
  {
    return this->period_;
  }

  void dateModified::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void dateModified::
  period (const period_optional& x)
  {
    this->period_ = x;
  }

  void dateModified::
  period (::std::auto_ptr< period_type > x)
  {
    this->period_.set (x);
  }


  // created
  // 

  const created::startYear_optional& created::
  startYear () const
  {
    return this->startYear_;
  }

  created::startYear_optional& created::
  startYear ()
  {
    return this->startYear_;
  }

  void created::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void created::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void created::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const created::startDate_optional& created::
  startDate () const
  {
    return this->startDate_;
  }

  created::startDate_optional& created::
  startDate ()
  {
    return this->startDate_;
  }

  void created::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void created::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void created::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const created::startTime_optional& created::
  startTime () const
  {
    return this->startTime_;
  }

  created::startTime_optional& created::
  startTime ()
  {
    return this->startTime_;
  }

  void created::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void created::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void created::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const created::endYear_optional& created::
  endYear () const
  {
    return this->endYear_;
  }

  created::endYear_optional& created::
  endYear ()
  {
    return this->endYear_;
  }

  void created::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void created::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void created::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const created::endDate_optional& created::
  endDate () const
  {
    return this->endDate_;
  }

  created::endDate_optional& created::
  endDate ()
  {
    return this->endDate_;
  }

  void created::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void created::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void created::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const created::endTime_optional& created::
  endTime () const
  {
    return this->endTime_;
  }

  created::endTime_optional& created::
  endTime ()
  {
    return this->endTime_;
  }

  void created::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void created::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void created::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const created::period_optional& created::
  period () const
  {
    return this->period_;
  }

  created::period_optional& created::
  period ()
  {
    return this->period_;
  }

  void created::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void created::
  period (const period_optional& x)
  {
    this->period_ = x;
  }

  void created::
  period (::std::auto_ptr< period_type > x)
  {
    this->period_.set (x);
  }


  // issued
  // 

  const issued::startYear_optional& issued::
  startYear () const
  {
    return this->startYear_;
  }

  issued::startYear_optional& issued::
  startYear ()
  {
    return this->startYear_;
  }

  void issued::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void issued::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void issued::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const issued::startDate_optional& issued::
  startDate () const
  {
    return this->startDate_;
  }

  issued::startDate_optional& issued::
  startDate ()
  {
    return this->startDate_;
  }

  void issued::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void issued::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void issued::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const issued::startTime_optional& issued::
  startTime () const
  {
    return this->startTime_;
  }

  issued::startTime_optional& issued::
  startTime ()
  {
    return this->startTime_;
  }

  void issued::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void issued::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void issued::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const issued::endYear_optional& issued::
  endYear () const
  {
    return this->endYear_;
  }

  issued::endYear_optional& issued::
  endYear ()
  {
    return this->endYear_;
  }

  void issued::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void issued::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void issued::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const issued::endDate_optional& issued::
  endDate () const
  {
    return this->endDate_;
  }

  issued::endDate_optional& issued::
  endDate ()
  {
    return this->endDate_;
  }

  void issued::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void issued::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void issued::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const issued::endTime_optional& issued::
  endTime () const
  {
    return this->endTime_;
  }

  issued::endTime_optional& issued::
  endTime ()
  {
    return this->endTime_;
  }

  void issued::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void issued::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void issued::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const issued::period_optional& issued::
  period () const
  {
    return this->period_;
  }

  issued::period_optional& issued::
  period ()
  {
    return this->period_;
  }

  void issued::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void issued::
  period (const period_optional& x)
  {
    this->period_ = x;
  }

  void issued::
  period (::std::auto_ptr< period_type > x)
  {
    this->period_.set (x);
  }


  // modified
  // 

  const modified::startYear_optional& modified::
  startYear () const
  {
    return this->startYear_;
  }

  modified::startYear_optional& modified::
  startYear ()
  {
    return this->startYear_;
  }

  void modified::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void modified::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void modified::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const modified::startDate_optional& modified::
  startDate () const
  {
    return this->startDate_;
  }

  modified::startDate_optional& modified::
  startDate ()
  {
    return this->startDate_;
  }

  void modified::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void modified::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void modified::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const modified::startTime_optional& modified::
  startTime () const
  {
    return this->startTime_;
  }

  modified::startTime_optional& modified::
  startTime ()
  {
    return this->startTime_;
  }

  void modified::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void modified::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void modified::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const modified::endYear_optional& modified::
  endYear () const
  {
    return this->endYear_;
  }

  modified::endYear_optional& modified::
  endYear ()
  {
    return this->endYear_;
  }

  void modified::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void modified::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void modified::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const modified::endDate_optional& modified::
  endDate () const
  {
    return this->endDate_;
  }

  modified::endDate_optional& modified::
  endDate ()
  {
    return this->endDate_;
  }

  void modified::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void modified::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void modified::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const modified::endTime_optional& modified::
  endTime () const
  {
    return this->endTime_;
  }

  modified::endTime_optional& modified::
  endTime ()
  {
    return this->endTime_;
  }

  void modified::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void modified::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void modified::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const modified::period_optional& modified::
  period () const
  {
    return this->period_;
  }

  modified::period_optional& modified::
  period ()
  {
    return this->period_;
  }

  void modified::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void modified::
  period (const period_optional& x)
  {
    this->period_ = x;
  }

  void modified::
  period (::std::auto_ptr< period_type > x)
  {
    this->period_.set (x);
  }


  // digitised
  // 

  const digitised::startYear_optional& digitised::
  startYear () const
  {
    return this->startYear_;
  }

  digitised::startYear_optional& digitised::
  startYear ()
  {
    return this->startYear_;
  }

  void digitised::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void digitised::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void digitised::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const digitised::startDate_optional& digitised::
  startDate () const
  {
    return this->startDate_;
  }

  digitised::startDate_optional& digitised::
  startDate ()
  {
    return this->startDate_;
  }

  void digitised::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void digitised::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void digitised::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const digitised::startTime_optional& digitised::
  startTime () const
  {
    return this->startTime_;
  }

  digitised::startTime_optional& digitised::
  startTime ()
  {
    return this->startTime_;
  }

  void digitised::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void digitised::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void digitised::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const digitised::endYear_optional& digitised::
  endYear () const
  {
    return this->endYear_;
  }

  digitised::endYear_optional& digitised::
  endYear ()
  {
    return this->endYear_;
  }

  void digitised::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void digitised::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void digitised::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const digitised::endDate_optional& digitised::
  endDate () const
  {
    return this->endDate_;
  }

  digitised::endDate_optional& digitised::
  endDate ()
  {
    return this->endDate_;
  }

  void digitised::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void digitised::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void digitised::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const digitised::endTime_optional& digitised::
  endTime () const
  {
    return this->endTime_;
  }

  digitised::endTime_optional& digitised::
  endTime ()
  {
    return this->endTime_;
  }

  void digitised::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void digitised::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void digitised::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const digitised::period_optional& digitised::
  period () const
  {
    return this->period_;
  }

  digitised::period_optional& digitised::
  period ()
  {
    return this->period_;
  }

  void digitised::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void digitised::
  period (const period_optional& x)
  {
    this->period_ = x;
  }

  void digitised::
  period (::std::auto_ptr< period_type > x)
  {
    this->period_.set (x);
  }


  // alternative
  // 

  const alternative::startYear_optional& alternative::
  startYear () const
  {
    return this->startYear_;
  }

  alternative::startYear_optional& alternative::
  startYear ()
  {
    return this->startYear_;
  }

  void alternative::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void alternative::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void alternative::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const alternative::startDate_optional& alternative::
  startDate () const
  {
    return this->startDate_;
  }

  alternative::startDate_optional& alternative::
  startDate ()
  {
    return this->startDate_;
  }

  void alternative::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void alternative::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void alternative::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const alternative::startTime_optional& alternative::
  startTime () const
  {
    return this->startTime_;
  }

  alternative::startTime_optional& alternative::
  startTime ()
  {
    return this->startTime_;
  }

  void alternative::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void alternative::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void alternative::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const alternative::endYear_optional& alternative::
  endYear () const
  {
    return this->endYear_;
  }

  alternative::endYear_optional& alternative::
  endYear ()
  {
    return this->endYear_;
  }

  void alternative::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void alternative::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void alternative::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const alternative::endDate_optional& alternative::
  endDate () const
  {
    return this->endDate_;
  }

  alternative::endDate_optional& alternative::
  endDate ()
  {
    return this->endDate_;
  }

  void alternative::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void alternative::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void alternative::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const alternative::endTime_optional& alternative::
  endTime () const
  {
    return this->endTime_;
  }

  alternative::endTime_optional& alternative::
  endTime ()
  {
    return this->endTime_;
  }

  void alternative::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void alternative::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void alternative::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const alternative::period_optional& alternative::
  period () const
  {
    return this->period_;
  }

  alternative::period_optional& alternative::
  period ()
  {
    return this->period_;
  }

  void alternative::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void alternative::
  period (const period_optional& x)
  {
    this->period_ = x;
  }

  void alternative::
  period (::std::auto_ptr< period_type > x)
  {
    this->period_.set (x);
  }

  const alternative::typeLabel_optional& alternative::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  alternative::typeLabel_optional& alternative::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void alternative::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void alternative::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void alternative::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const alternative::typeDefinition_optional& alternative::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  alternative::typeDefinition_optional& alternative::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void alternative::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void alternative::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void alternative::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const alternative::typeLink_optional& alternative::
  typeLink () const
  {
    return this->typeLink_;
  }

  alternative::typeLink_optional& alternative::
  typeLink ()
  {
    return this->typeLink_;
  }

  void alternative::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void alternative::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void alternative::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // firstPublicationChannel
  // 

  const firstPublicationChannel::formatIdRef_optional& firstPublicationChannel::
  formatIdRef () const
  {
    return this->formatIdRef_;
  }

  firstPublicationChannel::formatIdRef_optional& firstPublicationChannel::
  formatIdRef ()
  {
    return this->formatIdRef_;
  }

  void firstPublicationChannel::
  formatIdRef (const formatIdRef_type& x)
  {
    this->formatIdRef_.set (x);
  }

  void firstPublicationChannel::
  formatIdRef (const formatIdRef_optional& x)
  {
    this->formatIdRef_ = x;
  }

  void firstPublicationChannel::
  formatIdRef (::std::auto_ptr< formatIdRef_type > x)
  {
    this->formatIdRef_.set (x);
  }


  // repeatChannel
  // 

  const repeatChannel::formatIdRef_optional& repeatChannel::
  formatIdRef () const
  {
    return this->formatIdRef_;
  }

  repeatChannel::formatIdRef_optional& repeatChannel::
  formatIdRef ()
  {
    return this->formatIdRef_;
  }

  void repeatChannel::
  formatIdRef (const formatIdRef_type& x)
  {
    this->formatIdRef_.set (x);
  }

  void repeatChannel::
  formatIdRef (const formatIdRef_optional& x)
  {
    this->formatIdRef_ = x;
  }

  void repeatChannel::
  formatIdRef (::std::auto_ptr< formatIdRef_type > x)
  {
    this->formatIdRef_.set (x);
  }


  // role
  // 

  const role::typeLabel_optional& role::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  role::typeLabel_optional& role::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void role::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void role::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void role::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const role::typeDefinition_optional& role::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  role::typeDefinition_optional& role::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void role::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void role::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void role::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const role::typeLink_optional& role::
  typeLink () const
  {
    return this->typeLink_;
  }

  role::typeLink_optional& role::
  typeLink ()
  {
    return this->typeLink_;
  }

  void role::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void role::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void role::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // organisationDepartment
  // 

  const organisationDepartment::departmentId_optional& organisationDepartment::
  departmentId () const
  {
    return this->departmentId_;
  }

  organisationDepartment::departmentId_optional& organisationDepartment::
  departmentId ()
  {
    return this->departmentId_;
  }

  void organisationDepartment::
  departmentId (const departmentId_type& x)
  {
    this->departmentId_.set (x);
  }

  void organisationDepartment::
  departmentId (const departmentId_optional& x)
  {
    this->departmentId_ = x;
  }

  void organisationDepartment::
  departmentId (::std::auto_ptr< departmentId_type > x)
  {
    this->departmentId_.set (x);
  }


  // country
  // 

  const country::typeLabel_optional& country::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  country::typeLabel_optional& country::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void country::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void country::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void country::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const country::typeDefinition_optional& country::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  country::typeDefinition_optional& country::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void country::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void country::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void country::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const country::typeLink_optional& country::
  typeLink () const
  {
    return this->typeLink_;
  }

  country::typeLink_optional& country::
  typeLink ()
  {
    return this->typeLink_;
  }

  void country::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void country::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void country::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // orientation
  // 

  orientation::
  orientation (value v)
  : ::xml_schema::string (_xsd_orientation_literals_[v])
  {
  }

  orientation::
  orientation (const char* v)
  : ::xml_schema::string (v)
  {
  }

  orientation::
  orientation (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  orientation::
  orientation (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  orientation::
  orientation (const orientation& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  orientation& orientation::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_orientation_literals_[v]);

    return *this;
  }


  // imageEncoding
  // 

  const imageEncoding::typeLabel_optional& imageEncoding::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  imageEncoding::typeLabel_optional& imageEncoding::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void imageEncoding::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void imageEncoding::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void imageEncoding::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const imageEncoding::typeDefinition_optional& imageEncoding::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  imageEncoding::typeDefinition_optional& imageEncoding::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void imageEncoding::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void imageEncoding::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void imageEncoding::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const imageEncoding::typeLink_optional& imageEncoding::
  typeLink () const
  {
    return this->typeLink_;
  }

  imageEncoding::typeLink_optional& imageEncoding::
  typeLink ()
  {
    return this->typeLink_;
  }

  void imageEncoding::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void imageEncoding::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void imageEncoding::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // aspectRatio
  // 

  const aspectRatio::formatLabel_optional& aspectRatio::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  aspectRatio::formatLabel_optional& aspectRatio::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void aspectRatio::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void aspectRatio::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void aspectRatio::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const aspectRatio::formatDefinition_optional& aspectRatio::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  aspectRatio::formatDefinition_optional& aspectRatio::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void aspectRatio::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void aspectRatio::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void aspectRatio::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const aspectRatio::formatLink_optional& aspectRatio::
  formatLink () const
  {
    return this->formatLink_;
  }

  aspectRatio::formatLink_optional& aspectRatio::
  formatLink ()
  {
    return this->formatLink_;
  }

  void aspectRatio::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void aspectRatio::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void aspectRatio::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const aspectRatio::note_optional& aspectRatio::
  note () const
  {
    return this->note_;
  }

  aspectRatio::note_optional& aspectRatio::
  note ()
  {
    return this->note_;
  }

  void aspectRatio::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void aspectRatio::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void aspectRatio::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // videoEncoding
  // 

  const videoEncoding::typeLabel_optional& videoEncoding::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  videoEncoding::typeLabel_optional& videoEncoding::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void videoEncoding::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void videoEncoding::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void videoEncoding::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const videoEncoding::typeDefinition_optional& videoEncoding::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  videoEncoding::typeDefinition_optional& videoEncoding::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void videoEncoding::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void videoEncoding::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void videoEncoding::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const videoEncoding::typeLink_optional& videoEncoding::
  typeLink () const
  {
    return this->typeLink_;
  }

  videoEncoding::typeLink_optional& videoEncoding::
  typeLink ()
  {
    return this->typeLink_;
  }

  void videoEncoding::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void videoEncoding::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void videoEncoding::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // videoTrack
  // 

  const videoTrack::trackId_optional& videoTrack::
  trackId () const
  {
    return this->trackId_;
  }

  videoTrack::trackId_optional& videoTrack::
  trackId ()
  {
    return this->trackId_;
  }

  void videoTrack::
  trackId (const trackId_type& x)
  {
    this->trackId_.set (x);
  }

  void videoTrack::
  trackId (const trackId_optional& x)
  {
    this->trackId_ = x;
  }

  void videoTrack::
  trackId (::std::auto_ptr< trackId_type > x)
  {
    this->trackId_.set (x);
  }

  const videoTrack::trackName_optional& videoTrack::
  trackName () const
  {
    return this->trackName_;
  }

  videoTrack::trackName_optional& videoTrack::
  trackName ()
  {
    return this->trackName_;
  }

  void videoTrack::
  trackName (const trackName_type& x)
  {
    this->trackName_.set (x);
  }

  void videoTrack::
  trackName (const trackName_optional& x)
  {
    this->trackName_ = x;
  }

  void videoTrack::
  trackName (::std::auto_ptr< trackName_type > x)
  {
    this->trackName_.set (x);
  }

  const videoTrack::typeLabel_optional& videoTrack::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  videoTrack::typeLabel_optional& videoTrack::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void videoTrack::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void videoTrack::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void videoTrack::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const videoTrack::typeDefinition_optional& videoTrack::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  videoTrack::typeDefinition_optional& videoTrack::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void videoTrack::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void videoTrack::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void videoTrack::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const videoTrack::typeLink_optional& videoTrack::
  typeLink () const
  {
    return this->typeLink_;
  }

  videoTrack::typeLink_optional& videoTrack::
  typeLink ()
  {
    return this->typeLink_;
  }

  void videoTrack::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void videoTrack::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void videoTrack::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // audioEncoding
  // 

  const audioEncoding::typeLabel_optional& audioEncoding::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  audioEncoding::typeLabel_optional& audioEncoding::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void audioEncoding::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void audioEncoding::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void audioEncoding::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const audioEncoding::typeDefinition_optional& audioEncoding::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  audioEncoding::typeDefinition_optional& audioEncoding::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void audioEncoding::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void audioEncoding::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void audioEncoding::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const audioEncoding::typeLink_optional& audioEncoding::
  typeLink () const
  {
    return this->typeLink_;
  }

  audioEncoding::typeLink_optional& audioEncoding::
  typeLink ()
  {
    return this->typeLink_;
  }

  void audioEncoding::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void audioEncoding::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void audioEncoding::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // audioTrackConfiguration
  // 

  const audioTrackConfiguration::typeLabel_optional& audioTrackConfiguration::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  audioTrackConfiguration::typeLabel_optional& audioTrackConfiguration::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void audioTrackConfiguration::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void audioTrackConfiguration::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void audioTrackConfiguration::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const audioTrackConfiguration::typeDefinition_optional& audioTrackConfiguration::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  audioTrackConfiguration::typeDefinition_optional& audioTrackConfiguration::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void audioTrackConfiguration::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void audioTrackConfiguration::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void audioTrackConfiguration::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const audioTrackConfiguration::typeLink_optional& audioTrackConfiguration::
  typeLink () const
  {
    return this->typeLink_;
  }

  audioTrackConfiguration::typeLink_optional& audioTrackConfiguration::
  typeLink ()
  {
    return this->typeLink_;
  }

  void audioTrackConfiguration::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void audioTrackConfiguration::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void audioTrackConfiguration::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // audioTrack
  // 

  const audioTrack::trackLanguage_optional& audioTrack::
  trackLanguage () const
  {
    return this->trackLanguage_;
  }

  audioTrack::trackLanguage_optional& audioTrack::
  trackLanguage ()
  {
    return this->trackLanguage_;
  }

  void audioTrack::
  trackLanguage (const trackLanguage_type& x)
  {
    this->trackLanguage_.set (x);
  }

  void audioTrack::
  trackLanguage (const trackLanguage_optional& x)
  {
    this->trackLanguage_ = x;
  }

  void audioTrack::
  trackLanguage (::std::auto_ptr< trackLanguage_type > x)
  {
    this->trackLanguage_.set (x);
  }

  const audioTrack::trackId_optional& audioTrack::
  trackId () const
  {
    return this->trackId_;
  }

  audioTrack::trackId_optional& audioTrack::
  trackId ()
  {
    return this->trackId_;
  }

  void audioTrack::
  trackId (const trackId_type& x)
  {
    this->trackId_.set (x);
  }

  void audioTrack::
  trackId (const trackId_optional& x)
  {
    this->trackId_ = x;
  }

  void audioTrack::
  trackId (::std::auto_ptr< trackId_type > x)
  {
    this->trackId_.set (x);
  }

  const audioTrack::trackName_optional& audioTrack::
  trackName () const
  {
    return this->trackName_;
  }

  audioTrack::trackName_optional& audioTrack::
  trackName ()
  {
    return this->trackName_;
  }

  void audioTrack::
  trackName (const trackName_type& x)
  {
    this->trackName_.set (x);
  }

  void audioTrack::
  trackName (const trackName_optional& x)
  {
    this->trackName_ = x;
  }

  void audioTrack::
  trackName (::std::auto_ptr< trackName_type > x)
  {
    this->trackName_.set (x);
  }

  const audioTrack::typeLabel_optional& audioTrack::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  audioTrack::typeLabel_optional& audioTrack::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void audioTrack::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void audioTrack::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void audioTrack::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const audioTrack::typeDefinition_optional& audioTrack::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  audioTrack::typeDefinition_optional& audioTrack::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void audioTrack::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void audioTrack::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void audioTrack::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const audioTrack::typeLink_optional& audioTrack::
  typeLink () const
  {
    return this->typeLink_;
  }

  audioTrack::typeLink_optional& audioTrack::
  typeLink ()
  {
    return this->typeLink_;
  }

  void audioTrack::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void audioTrack::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void audioTrack::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }


  // captioningFormat
  // 

  const captioningFormat::trackId_optional& captioningFormat::
  trackId () const
  {
    return this->trackId_;
  }

  captioningFormat::trackId_optional& captioningFormat::
  trackId ()
  {
    return this->trackId_;
  }

  void captioningFormat::
  trackId (const trackId_type& x)
  {
    this->trackId_.set (x);
  }

  void captioningFormat::
  trackId (const trackId_optional& x)
  {
    this->trackId_ = x;
  }

  void captioningFormat::
  trackId (::std::auto_ptr< trackId_type > x)
  {
    this->trackId_.set (x);
  }

  const captioningFormat::trackName_optional& captioningFormat::
  trackName () const
  {
    return this->trackName_;
  }

  captioningFormat::trackName_optional& captioningFormat::
  trackName ()
  {
    return this->trackName_;
  }

  void captioningFormat::
  trackName (const trackName_type& x)
  {
    this->trackName_.set (x);
  }

  void captioningFormat::
  trackName (const trackName_optional& x)
  {
    this->trackName_ = x;
  }

  void captioningFormat::
  trackName (::std::auto_ptr< trackName_type > x)
  {
    this->trackName_.set (x);
  }

  const captioningFormat::language_optional& captioningFormat::
  language () const
  {
    return this->language_;
  }

  captioningFormat::language_optional& captioningFormat::
  language ()
  {
    return this->language_;
  }

  void captioningFormat::
  language (const language_type& x)
  {
    this->language_.set (x);
  }

  void captioningFormat::
  language (const language_optional& x)
  {
    this->language_ = x;
  }

  void captioningFormat::
  language (::std::auto_ptr< language_type > x)
  {
    this->language_.set (x);
  }

  const captioningFormat::typeLabel_optional& captioningFormat::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  captioningFormat::typeLabel_optional& captioningFormat::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void captioningFormat::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void captioningFormat::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void captioningFormat::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const captioningFormat::typeDefinition_optional& captioningFormat::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  captioningFormat::typeDefinition_optional& captioningFormat::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void captioningFormat::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void captioningFormat::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void captioningFormat::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const captioningFormat::typeLink_optional& captioningFormat::
  typeLink () const
  {
    return this->typeLink_;
  }

  captioningFormat::typeLink_optional& captioningFormat::
  typeLink ()
  {
    return this->typeLink_;
  }

  void captioningFormat::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void captioningFormat::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void captioningFormat::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const captioningFormat::formatLabel_optional& captioningFormat::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  captioningFormat::formatLabel_optional& captioningFormat::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void captioningFormat::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void captioningFormat::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void captioningFormat::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const captioningFormat::formatDefinition_optional& captioningFormat::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  captioningFormat::formatDefinition_optional& captioningFormat::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void captioningFormat::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void captioningFormat::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void captioningFormat::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const captioningFormat::formatLink_optional& captioningFormat::
  formatLink () const
  {
    return this->formatLink_;
  }

  captioningFormat::formatLink_optional& captioningFormat::
  formatLink ()
  {
    return this->formatLink_;
  }

  void captioningFormat::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void captioningFormat::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void captioningFormat::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const captioningFormat::captioningSourceUri_optional& captioningFormat::
  captioningSourceUri () const
  {
    return this->captioningSourceUri_;
  }

  captioningFormat::captioningSourceUri_optional& captioningFormat::
  captioningSourceUri ()
  {
    return this->captioningSourceUri_;
  }

  void captioningFormat::
  captioningSourceUri (const captioningSourceUri_type& x)
  {
    this->captioningSourceUri_.set (x);
  }

  void captioningFormat::
  captioningSourceUri (const captioningSourceUri_optional& x)
  {
    this->captioningSourceUri_ = x;
  }

  void captioningFormat::
  captioningSourceUri (::std::auto_ptr< captioningSourceUri_type > x)
  {
    this->captioningSourceUri_.set (x);
  }

  const captioningFormat::captioningFormatId_optional& captioningFormat::
  captioningFormatId () const
  {
    return this->captioningFormatId_;
  }

  captioningFormat::captioningFormatId_optional& captioningFormat::
  captioningFormatId ()
  {
    return this->captioningFormatId_;
  }

  void captioningFormat::
  captioningFormatId (const captioningFormatId_type& x)
  {
    this->captioningFormatId_.set (x);
  }

  void captioningFormat::
  captioningFormatId (const captioningFormatId_optional& x)
  {
    this->captioningFormatId_ = x;
  }

  void captioningFormat::
  captioningFormatId (::std::auto_ptr< captioningFormatId_type > x)
  {
    this->captioningFormatId_.set (x);
  }

  const captioningFormat::captioningFormatName_optional& captioningFormat::
  captioningFormatName () const
  {
    return this->captioningFormatName_;
  }

  captioningFormat::captioningFormatName_optional& captioningFormat::
  captioningFormatName ()
  {
    return this->captioningFormatName_;
  }

  void captioningFormat::
  captioningFormatName (const captioningFormatName_type& x)
  {
    this->captioningFormatName_.set (x);
  }

  void captioningFormat::
  captioningFormatName (const captioningFormatName_optional& x)
  {
    this->captioningFormatName_ = x;
  }

  void captioningFormat::
  captioningFormatName (::std::auto_ptr< captioningFormatName_type > x)
  {
    this->captioningFormatName_.set (x);
  }


  // ancillaryDataFormat
  // 

  const ancillaryDataFormat::DID_optional& ancillaryDataFormat::
  DID () const
  {
    return this->DID_;
  }

  ancillaryDataFormat::DID_optional& ancillaryDataFormat::
  DID ()
  {
    return this->DID_;
  }

  void ancillaryDataFormat::
  DID (const DID_type& x)
  {
    this->DID_.set (x);
  }

  void ancillaryDataFormat::
  DID (const DID_optional& x)
  {
    this->DID_ = x;
  }

  const ancillaryDataFormat::SDID_optional& ancillaryDataFormat::
  SDID () const
  {
    return this->SDID_;
  }

  ancillaryDataFormat::SDID_optional& ancillaryDataFormat::
  SDID ()
  {
    return this->SDID_;
  }

  void ancillaryDataFormat::
  SDID (const SDID_type& x)
  {
    this->SDID_.set (x);
  }

  void ancillaryDataFormat::
  SDID (const SDID_optional& x)
  {
    this->SDID_ = x;
  }

  const ancillaryDataFormat::lineNumber_sequence& ancillaryDataFormat::
  lineNumber () const
  {
    return this->lineNumber_;
  }

  ancillaryDataFormat::lineNumber_sequence& ancillaryDataFormat::
  lineNumber ()
  {
    return this->lineNumber_;
  }

  void ancillaryDataFormat::
  lineNumber (const lineNumber_sequence& s)
  {
    this->lineNumber_ = s;
  }

  const ancillaryDataFormat::wrappingType_optional& ancillaryDataFormat::
  wrappingType () const
  {
    return this->wrappingType_;
  }

  ancillaryDataFormat::wrappingType_optional& ancillaryDataFormat::
  wrappingType ()
  {
    return this->wrappingType_;
  }

  void ancillaryDataFormat::
  wrappingType (const wrappingType_type& x)
  {
    this->wrappingType_.set (x);
  }

  void ancillaryDataFormat::
  wrappingType (const wrappingType_optional& x)
  {
    this->wrappingType_ = x;
  }

  const ancillaryDataFormat::ancillaryDataFormatId_optional& ancillaryDataFormat::
  ancillaryDataFormatId () const
  {
    return this->ancillaryDataFormatId_;
  }

  ancillaryDataFormat::ancillaryDataFormatId_optional& ancillaryDataFormat::
  ancillaryDataFormatId ()
  {
    return this->ancillaryDataFormatId_;
  }

  void ancillaryDataFormat::
  ancillaryDataFormatId (const ancillaryDataFormatId_type& x)
  {
    this->ancillaryDataFormatId_.set (x);
  }

  void ancillaryDataFormat::
  ancillaryDataFormatId (const ancillaryDataFormatId_optional& x)
  {
    this->ancillaryDataFormatId_ = x;
  }

  void ancillaryDataFormat::
  ancillaryDataFormatId (::std::auto_ptr< ancillaryDataFormatId_type > x)
  {
    this->ancillaryDataFormatId_.set (x);
  }

  const ancillaryDataFormat::ancillaryDataFormatName_optional& ancillaryDataFormat::
  ancillaryDataFormatName () const
  {
    return this->ancillaryDataFormatName_;
  }

  ancillaryDataFormat::ancillaryDataFormatName_optional& ancillaryDataFormat::
  ancillaryDataFormatName ()
  {
    return this->ancillaryDataFormatName_;
  }

  void ancillaryDataFormat::
  ancillaryDataFormatName (const ancillaryDataFormatName_type& x)
  {
    this->ancillaryDataFormatName_.set (x);
  }

  void ancillaryDataFormat::
  ancillaryDataFormatName (const ancillaryDataFormatName_optional& x)
  {
    this->ancillaryDataFormatName_ = x;
  }

  void ancillaryDataFormat::
  ancillaryDataFormatName (::std::auto_ptr< ancillaryDataFormatName_type > x)
  {
    this->ancillaryDataFormatName_.set (x);
  }


  // timecode
  // 


  // time
  // 

  const time::formatLabel_optional& time::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  time::formatLabel_optional& time::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void time::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void time::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void time::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const time::formatDefinition_optional& time::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  time::formatDefinition_optional& time::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void time::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void time::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void time::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const time::formatLink_optional& time::
  formatLink () const
  {
    return this->formatLink_;
  }

  time::formatLink_optional& time::
  formatLink ()
  {
    return this->formatLink_;
  }

  void time::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void time::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void time::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }


  // timecode1
  // 


  // time1
  // 

  const time1::formatLabel_optional& time1::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  time1::formatLabel_optional& time1::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void time1::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void time1::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void time1::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const time1::formatDefinition_optional& time1::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  time1::formatDefinition_optional& time1::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void time1::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void time1::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void time1::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const time1::formatLink_optional& time1::
  formatLink () const
  {
    return this->formatLink_;
  }

  time1::formatLink_optional& time1::
  formatLink ()
  {
    return this->formatLink_;
  }

  void time1::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void time1::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void time1::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }


  // PeriodOfTime
  // 

  const PeriodOfTime::startYear_optional& PeriodOfTime::
  startYear () const
  {
    return this->startYear_;
  }

  PeriodOfTime::startYear_optional& PeriodOfTime::
  startYear ()
  {
    return this->startYear_;
  }

  void PeriodOfTime::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void PeriodOfTime::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void PeriodOfTime::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const PeriodOfTime::startDate_optional& PeriodOfTime::
  startDate () const
  {
    return this->startDate_;
  }

  PeriodOfTime::startDate_optional& PeriodOfTime::
  startDate ()
  {
    return this->startDate_;
  }

  void PeriodOfTime::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void PeriodOfTime::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void PeriodOfTime::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const PeriodOfTime::startTime_optional& PeriodOfTime::
  startTime () const
  {
    return this->startTime_;
  }

  PeriodOfTime::startTime_optional& PeriodOfTime::
  startTime ()
  {
    return this->startTime_;
  }

  void PeriodOfTime::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void PeriodOfTime::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void PeriodOfTime::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const PeriodOfTime::endYear_optional& PeriodOfTime::
  endYear () const
  {
    return this->endYear_;
  }

  PeriodOfTime::endYear_optional& PeriodOfTime::
  endYear ()
  {
    return this->endYear_;
  }

  void PeriodOfTime::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void PeriodOfTime::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void PeriodOfTime::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const PeriodOfTime::endDate_optional& PeriodOfTime::
  endDate () const
  {
    return this->endDate_;
  }

  PeriodOfTime::endDate_optional& PeriodOfTime::
  endDate ()
  {
    return this->endDate_;
  }

  void PeriodOfTime::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void PeriodOfTime::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void PeriodOfTime::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const PeriodOfTime::endTime_optional& PeriodOfTime::
  endTime () const
  {
    return this->endTime_;
  }

  PeriodOfTime::endTime_optional& PeriodOfTime::
  endTime ()
  {
    return this->endTime_;
  }

  void PeriodOfTime::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void PeriodOfTime::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void PeriodOfTime::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const PeriodOfTime::period_optional& PeriodOfTime::
  period () const
  {
    return this->period_;
  }

  PeriodOfTime::period_optional& PeriodOfTime::
  period ()
  {
    return this->period_;
  }

  void PeriodOfTime::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  void PeriodOfTime::
  period (const period_optional& x)
  {
    this->period_ = x;
  }

  void PeriodOfTime::
  period (::std::auto_ptr< period_type > x)
  {
    this->period_.set (x);
  }


  // location
  // 

  const location::name_optional& location::
  name () const
  {
    return this->name_;
  }

  location::name_optional& location::
  name ()
  {
    return this->name_;
  }

  void location::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void location::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void location::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const location::coordinates_optional& location::
  coordinates () const
  {
    return this->coordinates_;
  }

  location::coordinates_optional& location::
  coordinates ()
  {
    return this->coordinates_;
  }

  void location::
  coordinates (const coordinates_type& x)
  {
    this->coordinates_.set (x);
  }

  void location::
  coordinates (const coordinates_optional& x)
  {
    this->coordinates_ = x;
  }

  void location::
  coordinates (::std::auto_ptr< coordinates_type > x)
  {
    this->coordinates_.set (x);
  }

  const location::code_optional& location::
  code () const
  {
    return this->code_;
  }

  location::code_optional& location::
  code ()
  {
    return this->code_;
  }

  void location::
  code (const code_type& x)
  {
    this->code_.set (x);
  }

  void location::
  code (const code_optional& x)
  {
    this->code_ = x;
  }

  void location::
  code (::std::auto_ptr< code_type > x)
  {
    this->code_.set (x);
  }

  const location::typeLabel_optional& location::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  location::typeLabel_optional& location::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void location::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void location::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void location::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const location::typeDefinition_optional& location::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  location::typeDefinition_optional& location::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void location::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void location::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void location::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const location::typeLink_optional& location::
  typeLink () const
  {
    return this->typeLink_;
  }

  location::typeLink_optional& location::
  typeLink ()
  {
    return this->typeLink_;
  }

  void location::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void location::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void location::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const location::note_optional& location::
  note () const
  {
    return this->note_;
  }

  location::note_optional& location::
  note ()
  {
    return this->note_;
  }

  void location::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void location::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void location::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }

  const location::locationId_optional& location::
  locationId () const
  {
    return this->locationId_;
  }

  location::locationId_optional& location::
  locationId ()
  {
    return this->locationId_;
  }

  void location::
  locationId (const locationId_type& x)
  {
    this->locationId_.set (x);
  }

  void location::
  locationId (const locationId_optional& x)
  {
    this->locationId_ = x;
  }

  void location::
  locationId (::std::auto_ptr< locationId_type > x)
  {
    this->locationId_.set (x);
  }


  // coordinates
  // 

  const coordinates::posy_type& coordinates::
  posy () const
  {
    return this->posy_.get ();
  }

  coordinates::posy_type& coordinates::
  posy ()
  {
    return this->posy_.get ();
  }

  void coordinates::
  posy (const posy_type& x)
  {
    this->posy_.set (x);
  }

  const coordinates::posx_type& coordinates::
  posx () const
  {
    return this->posx_.get ();
  }

  coordinates::posx_type& coordinates::
  posx ()
  {
    return this->posx_.get ();
  }

  void coordinates::
  posx (const posx_type& x)
  {
    this->posx_.set (x);
  }

  const coordinates::formatLabel_optional& coordinates::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  coordinates::formatLabel_optional& coordinates::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void coordinates::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void coordinates::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void coordinates::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const coordinates::formatDefinition_optional& coordinates::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  coordinates::formatDefinition_optional& coordinates::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void coordinates::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void coordinates::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void coordinates::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const coordinates::formatLink_optional& coordinates::
  formatLink () const
  {
    return this->formatLink_;
  }

  coordinates::formatLink_optional& coordinates::
  formatLink ()
  {
    return this->formatLink_;
  }

  void coordinates::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void coordinates::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void coordinates::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace ebuCore_2011
{
  // ebuCoreMainType
  //

  const ebuCoreMainType::schema_type ebuCoreMainType::schema_default_value_ (
    ::xml_schema::simple_type ("EBU_CORE_20110531.xsd"));

  const ebuCoreMainType::version_type ebuCoreMainType::version_default_value_ (
    ::xml_schema::simple_type ("1.3"));

  ebuCoreMainType::
  ebuCoreMainType (const coreMetadata_type& coreMetadata)
  : ::xml_schema::type (),
    coreMetadata_ (coreMetadata, ::xml_schema::flags (), this),
    metadataProvider_ (::xml_schema::flags (), this),
    schema_ (schema_default_value (), ::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this),
    dateLastModified_ (::xml_schema::flags (), this),
    documentId_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ebuCoreMainType::
  ebuCoreMainType (::std::auto_ptr< coreMetadata_type >& coreMetadata)
  : ::xml_schema::type (),
    coreMetadata_ (coreMetadata, ::xml_schema::flags (), this),
    metadataProvider_ (::xml_schema::flags (), this),
    schema_ (schema_default_value (), ::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this),
    dateLastModified_ (::xml_schema::flags (), this),
    documentId_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ebuCoreMainType::
  ebuCoreMainType (const ebuCoreMainType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    coreMetadata_ (x.coreMetadata_, f, this),
    metadataProvider_ (x.metadataProvider_, f, this),
    schema_ (x.schema_, f, this),
    version_ (x.version_, f, this),
    dateLastModified_ (x.dateLastModified_, f, this),
    documentId_ (x.documentId_, f, this),
    lang_ (x.lang_, f, this)
  {
  }

  ebuCoreMainType::
  ebuCoreMainType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    coreMetadata_ (f, this),
    metadataProvider_ (f, this),
    schema_ (f, this),
    version_ (f, this),
    dateLastModified_ (f, this),
    documentId_ (f, this),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ebuCoreMainType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // coreMetadata
      //
      if (n.name () == "coreMetadata" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< coreMetadata_type > r (
          coreMetadata_traits::create (i, f, this));

        if (!coreMetadata_.present ())
        {
          this->coreMetadata_.set (r);
          continue;
        }
      }

      // metadataProvider
      //
      if (n.name () == "metadataProvider" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< metadataProvider_type > r (
          metadataProvider_traits::create (i, f, this));

        if (!this->metadataProvider_)
        {
          this->metadataProvider_.set (r);
          continue;
        }
      }

      break;
    }

    if (!coreMetadata_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "coreMetadata",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "schema" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< schema_type > r (
          schema_traits::create (i, f, this));

        this->schema_.set (r);
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }

      if (n.name () == "dateLastModified" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dateLastModified_type > r (
          dateLastModified_traits::create (i, f, this));

        this->dateLastModified_.set (r);
        continue;
      }

      if (n.name () == "documentId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentId_type > r (
          documentId_traits::create (i, f, this));

        this->documentId_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }

    if (!schema_.present ())
    {
      this->schema_.set (schema_default_value ());
    }

    if (!version_.present ())
    {
      this->version_.set (version_default_value ());
    }
  }

  ebuCoreMainType* ebuCoreMainType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ebuCoreMainType (*this, f, c);
  }

  ebuCoreMainType::
  ~ebuCoreMainType ()
  {
  }

  // coreMetadataType
  //

  coreMetadataType::
  coreMetadataType ()
  : ::xml_schema::type (),
    title_ (::xml_schema::flags (), this),
    alternativeTitle_ (::xml_schema::flags (), this),
    creator_ (::xml_schema::flags (), this),
    subject_ (::xml_schema::flags (), this),
    description_ (::xml_schema::flags (), this),
    publisher_ (::xml_schema::flags (), this),
    contributor_ (::xml_schema::flags (), this),
    date_ (::xml_schema::flags (), this),
    type_ (::xml_schema::flags (), this),
    format_ (::xml_schema::flags (), this),
    identifier_ (::xml_schema::flags (), this),
    source_ (::xml_schema::flags (), this),
    language_ (::xml_schema::flags (), this),
    relation_ (::xml_schema::flags (), this),
    isVersionOf_ (::xml_schema::flags (), this),
    hasVersion_ (::xml_schema::flags (), this),
    isReplacedBy_ (::xml_schema::flags (), this),
    replaces_ (::xml_schema::flags (), this),
    isRequiredBy_ (::xml_schema::flags (), this),
    requires_ (::xml_schema::flags (), this),
    isPartOf_ (::xml_schema::flags (), this),
    hasPart_ (::xml_schema::flags (), this),
    hasTrackPart_ (::xml_schema::flags (), this),
    isReferencedBy_ (::xml_schema::flags (), this),
    references_ (::xml_schema::flags (), this),
    isFormatOf_ (::xml_schema::flags (), this),
    hasFormat_ (::xml_schema::flags (), this),
    isEpisodeOf_ (::xml_schema::flags (), this),
    isMemberOf_ (::xml_schema::flags (), this),
    coverage_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this),
    version_ (::xml_schema::flags (), this),
    publicationHistory_ (::xml_schema::flags (), this),
    rating_ (::xml_schema::flags (), this),
    part_ (::xml_schema::flags (), this)
  {
  }

  coreMetadataType::
  coreMetadataType (const coreMetadataType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    title_ (x.title_, f, this),
    alternativeTitle_ (x.alternativeTitle_, f, this),
    creator_ (x.creator_, f, this),
    subject_ (x.subject_, f, this),
    description_ (x.description_, f, this),
    publisher_ (x.publisher_, f, this),
    contributor_ (x.contributor_, f, this),
    date_ (x.date_, f, this),
    type_ (x.type_, f, this),
    format_ (x.format_, f, this),
    identifier_ (x.identifier_, f, this),
    source_ (x.source_, f, this),
    language_ (x.language_, f, this),
    relation_ (x.relation_, f, this),
    isVersionOf_ (x.isVersionOf_, f, this),
    hasVersion_ (x.hasVersion_, f, this),
    isReplacedBy_ (x.isReplacedBy_, f, this),
    replaces_ (x.replaces_, f, this),
    isRequiredBy_ (x.isRequiredBy_, f, this),
    requires_ (x.requires_, f, this),
    isPartOf_ (x.isPartOf_, f, this),
    hasPart_ (x.hasPart_, f, this),
    hasTrackPart_ (x.hasTrackPart_, f, this),
    isReferencedBy_ (x.isReferencedBy_, f, this),
    references_ (x.references_, f, this),
    isFormatOf_ (x.isFormatOf_, f, this),
    hasFormat_ (x.hasFormat_, f, this),
    isEpisodeOf_ (x.isEpisodeOf_, f, this),
    isMemberOf_ (x.isMemberOf_, f, this),
    coverage_ (x.coverage_, f, this),
    rights_ (x.rights_, f, this),
    version_ (x.version_, f, this),
    publicationHistory_ (x.publicationHistory_, f, this),
    rating_ (x.rating_, f, this),
    part_ (x.part_, f, this)
  {
  }

  coreMetadataType::
  coreMetadataType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    title_ (f, this),
    alternativeTitle_ (f, this),
    creator_ (f, this),
    subject_ (f, this),
    description_ (f, this),
    publisher_ (f, this),
    contributor_ (f, this),
    date_ (f, this),
    type_ (f, this),
    format_ (f, this),
    identifier_ (f, this),
    source_ (f, this),
    language_ (f, this),
    relation_ (f, this),
    isVersionOf_ (f, this),
    hasVersion_ (f, this),
    isReplacedBy_ (f, this),
    replaces_ (f, this),
    isRequiredBy_ (f, this),
    requires_ (f, this),
    isPartOf_ (f, this),
    hasPart_ (f, this),
    hasTrackPart_ (f, this),
    isReferencedBy_ (f, this),
    references_ (f, this),
    isFormatOf_ (f, this),
    hasFormat_ (f, this),
    isEpisodeOf_ (f, this),
    isMemberOf_ (f, this),
    coverage_ (f, this),
    rights_ (f, this),
    version_ (f, this),
    publicationHistory_ (f, this),
    rating_ (f, this),
    part_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void coreMetadataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // title
      //
      if (n.name () == "title" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< title_type > r (
          title_traits::create (i, f, this));

        this->title_.push_back (r);
        continue;
      }

      // alternativeTitle
      //
      if (n.name () == "alternativeTitle" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< alternativeTitle_type > r (
          alternativeTitle_traits::create (i, f, this));

        this->alternativeTitle_.push_back (r);
        continue;
      }

      // creator
      //
      if (n.name () == "creator" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< creator_type > r (
          creator_traits::create (i, f, this));

        this->creator_.push_back (r);
        continue;
      }

      // subject
      //
      if (n.name () == "subject" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< subject_type > r (
          subject_traits::create (i, f, this));

        this->subject_.push_back (r);
        continue;
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        this->description_.push_back (r);
        continue;
      }

      // publisher
      //
      if (n.name () == "publisher" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< publisher_type > r (
          publisher_traits::create (i, f, this));

        this->publisher_.push_back (r);
        continue;
      }

      // contributor
      //
      if (n.name () == "contributor" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< contributor_type > r (
          contributor_traits::create (i, f, this));

        this->contributor_.push_back (r);
        continue;
      }

      // date
      //
      if (n.name () == "date" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< date_type > r (
          date_traits::create (i, f, this));

        this->date_.push_back (r);
        continue;
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.push_back (r);
        continue;
      }

      // format
      //
      if (n.name () == "format" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< format_type > r (
          format_traits::create (i, f, this));

        this->format_.push_back (r);
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        this->identifier_.push_back (r);
        continue;
      }

      // source
      //
      if (n.name () == "source" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< source_type > r (
          source_traits::create (i, f, this));

        this->source_.push_back (r);
        continue;
      }

      // language
      //
      if (n.name () == "language" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< language_type > r (
          language_traits::create (i, f, this));

        this->language_.push_back (r);
        continue;
      }

      // relation
      //
      if (n.name () == "relation" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< relation_type > r (
          relation_traits::create (i, f, this));

        this->relation_.push_back (r);
        continue;
      }

      // isVersionOf
      //
      if (n.name () == "isVersionOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< isVersionOf_type > r (
          isVersionOf_traits::create (i, f, this));

        this->isVersionOf_.push_back (r);
        continue;
      }

      // hasVersion
      //
      if (n.name () == "hasVersion" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< hasVersion_type > r (
          hasVersion_traits::create (i, f, this));

        this->hasVersion_.push_back (r);
        continue;
      }

      // isReplacedBy
      //
      if (n.name () == "isReplacedBy" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< isReplacedBy_type > r (
          isReplacedBy_traits::create (i, f, this));

        this->isReplacedBy_.push_back (r);
        continue;
      }

      // replaces
      //
      if (n.name () == "replaces" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< replaces_type > r (
          replaces_traits::create (i, f, this));

        this->replaces_.push_back (r);
        continue;
      }

      // isRequiredBy
      //
      if (n.name () == "isRequiredBy" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< isRequiredBy_type > r (
          isRequiredBy_traits::create (i, f, this));

        this->isRequiredBy_.push_back (r);
        continue;
      }

      // requires
      //
      if (n.name () == "requires" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< requires_type > r (
          requires_traits::create (i, f, this));

        this->requires_.push_back (r);
        continue;
      }

      // isPartOf
      //
      if (n.name () == "isPartOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< isPartOf_type > r (
          isPartOf_traits::create (i, f, this));

        this->isPartOf_.push_back (r);
        continue;
      }

      // hasPart
      //
      if (n.name () == "hasPart" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< hasPart_type > r (
          hasPart_traits::create (i, f, this));

        this->hasPart_.push_back (r);
        continue;
      }

      // hasTrackPart
      //
      if (n.name () == "hasTrackPart" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< hasTrackPart_type > r (
          hasTrackPart_traits::create (i, f, this));

        this->hasTrackPart_.push_back (r);
        continue;
      }

      // isReferencedBy
      //
      if (n.name () == "isReferencedBy" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< isReferencedBy_type > r (
          isReferencedBy_traits::create (i, f, this));

        this->isReferencedBy_.push_back (r);
        continue;
      }

      // references
      //
      if (n.name () == "references" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< references_type > r (
          references_traits::create (i, f, this));

        this->references_.push_back (r);
        continue;
      }

      // isFormatOf
      //
      if (n.name () == "isFormatOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< isFormatOf_type > r (
          isFormatOf_traits::create (i, f, this));

        this->isFormatOf_.push_back (r);
        continue;
      }

      // hasFormat
      //
      if (n.name () == "hasFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< hasFormat_type > r (
          hasFormat_traits::create (i, f, this));

        this->hasFormat_.push_back (r);
        continue;
      }

      // isEpisodeOf
      //
      if (n.name () == "isEpisodeOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< isEpisodeOf_type > r (
          isEpisodeOf_traits::create (i, f, this));

        this->isEpisodeOf_.push_back (r);
        continue;
      }

      // isMemberOf
      //
      if (n.name () == "isMemberOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< isMemberOf_type > r (
          isMemberOf_traits::create (i, f, this));

        this->isMemberOf_.push_back (r);
        continue;
      }

      // coverage
      //
      if (n.name () == "coverage" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< coverage_type > r (
          coverage_traits::create (i, f, this));

        this->coverage_.push_back (r);
        continue;
      }

      // rights
      //
      if (n.name () == "rights" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< rights_type > r (
          rights_traits::create (i, f, this));

        this->rights_.push_back (r);
        continue;
      }

      // version
      //
      if (n.name () == "version" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        if (!this->version_)
        {
          this->version_.set (r);
          continue;
        }
      }

      // publicationHistory
      //
      if (n.name () == "publicationHistory" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< publicationHistory_type > r (
          publicationHistory_traits::create (i, f, this));

        if (!this->publicationHistory_)
        {
          this->publicationHistory_.set (r);
          continue;
        }
      }

      // rating
      //
      if (n.name () == "rating" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< rating_type > r (
          rating_traits::create (i, f, this));

        this->rating_.push_back (r);
        continue;
      }

      // part
      //
      if (n.name () == "part" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< part_type > r (
          part_traits::create (i, f, this));

        this->part_.push_back (r);
        continue;
      }

      break;
    }
  }

  coreMetadataType* coreMetadataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class coreMetadataType (*this, f, c);
  }

  coreMetadataType::
  ~coreMetadataType ()
  {
  }

  // titleType
  //

  titleType::
  titleType (const title_type& title)
  : ::xml_schema::type (),
    title_ (title, ::xml_schema::flags (), this),
    attributiondate_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  titleType::
  titleType (::std::auto_ptr< title_type >& title)
  : ::xml_schema::type (),
    title_ (title, ::xml_schema::flags (), this),
    attributiondate_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  titleType::
  titleType (const titleType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    title_ (x.title_, f, this),
    attributiondate_ (x.attributiondate_, f, this),
    note_ (x.note_, f, this)
  {
  }

  titleType::
  titleType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    title_ (f, this),
    attributiondate_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void titleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // title
      //
      if (n.name () == "title" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< title_type > r (
          title_traits::create (i, f, this));

        if (!title_.present ())
        {
          this->title_.set (r);
          continue;
        }
      }

      break;
    }

    if (!title_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "title",
        "http://purl.org/dc/elements/1.1/");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "attributiondate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< attributiondate_type > r (
          attributiondate_traits::create (i, f, this));

        this->attributiondate_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  titleType* titleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class titleType (*this, f, c);
  }

  titleType::
  ~titleType ()
  {
  }

  // alternativeTitleType
  //

  alternativeTitleType::
  alternativeTitleType (const title_type& title)
  : ::xml_schema::type (),
    title_ (title, ::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    statusLabel_ (::xml_schema::flags (), this),
    statusDefinition_ (::xml_schema::flags (), this),
    statusLink_ (::xml_schema::flags (), this),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  alternativeTitleType::
  alternativeTitleType (::std::auto_ptr< title_type >& title)
  : ::xml_schema::type (),
    title_ (title, ::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    statusLabel_ (::xml_schema::flags (), this),
    statusDefinition_ (::xml_schema::flags (), this),
    statusLink_ (::xml_schema::flags (), this),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  alternativeTitleType::
  alternativeTitleType (const alternativeTitleType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    title_ (x.title_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    statusLabel_ (x.statusLabel_, f, this),
    statusDefinition_ (x.statusDefinition_, f, this),
    statusLink_ (x.statusLink_, f, this),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    period_ (x.period_, f, this),
    note_ (x.note_, f, this)
  {
  }

  alternativeTitleType::
  alternativeTitleType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    title_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    statusLabel_ (f, this),
    statusDefinition_ (f, this),
    statusLink_ (f, this),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    period_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void alternativeTitleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // title
      //
      if (n.name () == "title" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< title_type > r (
          title_traits::create (i, f, this));

        if (!title_.present ())
        {
          this->title_.set (r);
          continue;
        }
      }

      break;
    }

    if (!title_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "title",
        "http://purl.org/dc/elements/1.1/");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "statusLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< statusLabel_type > r (
          statusLabel_traits::create (i, f, this));

        this->statusLabel_.set (r);
        continue;
      }

      if (n.name () == "statusDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< statusDefinition_type > r (
          statusDefinition_traits::create (i, f, this));

        this->statusDefinition_.set (r);
        continue;
      }

      if (n.name () == "statusLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< statusLink_type > r (
          statusLink_traits::create (i, f, this));

        this->statusLink_.set (r);
        continue;
      }

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  alternativeTitleType* alternativeTitleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class alternativeTitleType (*this, f, c);
  }

  alternativeTitleType::
  ~alternativeTitleType ()
  {
  }

  // identifierType
  //

  identifierType::
  identifierType (const identifier_type& identifier)
  : ::xml_schema::type (),
    identifier_ (identifier, ::xml_schema::flags (), this),
    attributor_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  identifierType::
  identifierType (::std::auto_ptr< identifier_type >& identifier)
  : ::xml_schema::type (),
    identifier_ (identifier, ::xml_schema::flags (), this),
    attributor_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  identifierType::
  identifierType (const identifierType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    attributor_ (x.attributor_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    note_ (x.note_, f, this)
  {
  }

  identifierType::
  identifierType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (f, this),
    attributor_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void identifierType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!identifier_.present ())
        {
          this->identifier_.set (r);
          continue;
        }
      }

      // attributor
      //
      if (n.name () == "attributor" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< attributor_type > r (
          attributor_traits::create (i, f, this));

        if (!this->attributor_)
        {
          this->attributor_.set (r);
          continue;
        }
      }

      break;
    }

    if (!identifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "identifier",
        "http://purl.org/dc/elements/1.1/");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  identifierType* identifierType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class identifierType (*this, f, c);
  }

  identifierType::
  ~identifierType ()
  {
  }

  // subjectType
  //

  subjectType::
  subjectType (const subject_type& subject)
  : ::xml_schema::type (),
    subject_ (subject, ::xml_schema::flags (), this),
    subjectCode_ (::xml_schema::flags (), this),
    subjectDefinition_ (::xml_schema::flags (), this),
    attributor_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  subjectType::
  subjectType (::std::auto_ptr< subject_type >& subject)
  : ::xml_schema::type (),
    subject_ (subject, ::xml_schema::flags (), this),
    subjectCode_ (::xml_schema::flags (), this),
    subjectDefinition_ (::xml_schema::flags (), this),
    attributor_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  subjectType::
  subjectType (const subjectType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    subject_ (x.subject_, f, this),
    subjectCode_ (x.subjectCode_, f, this),
    subjectDefinition_ (x.subjectDefinition_, f, this),
    attributor_ (x.attributor_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    note_ (x.note_, f, this)
  {
  }

  subjectType::
  subjectType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    subject_ (f, this),
    subjectCode_ (f, this),
    subjectDefinition_ (f, this),
    attributor_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void subjectType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // subject
      //
      if (n.name () == "subject" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< subject_type > r (
          subject_traits::create (i, f, this));

        if (!subject_.present ())
        {
          this->subject_.set (r);
          continue;
        }
      }

      // subjectCode
      //
      if (n.name () == "subjectCode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< subjectCode_type > r (
          subjectCode_traits::create (i, f, this));

        if (!this->subjectCode_)
        {
          this->subjectCode_.set (r);
          continue;
        }
      }

      // subjectDefinition
      //
      if (n.name () == "subjectDefinition" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< subjectDefinition_type > r (
          subjectDefinition_traits::create (i, f, this));

        if (!this->subjectDefinition_)
        {
          this->subjectDefinition_.set (r);
          continue;
        }
      }

      // attributor
      //
      if (n.name () == "attributor" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< attributor_type > r (
          attributor_traits::create (i, f, this));

        if (!this->attributor_)
        {
          this->attributor_.set (r);
          continue;
        }
      }

      break;
    }

    if (!subject_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "subject",
        "http://purl.org/dc/elements/1.1/");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  subjectType* subjectType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subjectType (*this, f, c);
  }

  subjectType::
  ~subjectType ()
  {
  }

  // typeType
  //

  typeType::
  typeType ()
  : ::xml_schema::type (),
    type_ (::xml_schema::flags (), this),
    genre_ (::xml_schema::flags (), this),
    objectType_ (::xml_schema::flags (), this),
    targetAudience_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  typeType::
  typeType (const typeType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    genre_ (x.genre_, f, this),
    objectType_ (x.objectType_, f, this),
    targetAudience_ (x.targetAudience_, f, this),
    note_ (x.note_, f, this)
  {
  }

  typeType::
  typeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    genre_ (f, this),
    objectType_ (f, this),
    targetAudience_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void typeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.push_back (r);
        continue;
      }

      // genre
      //
      if (n.name () == "genre" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< genre_type > r (
          genre_traits::create (i, f, this));

        this->genre_.push_back (r);
        continue;
      }

      // objectType
      //
      if (n.name () == "objectType" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< objectType_type > r (
          objectType_traits::create (i, f, this));

        this->objectType_.push_back (r);
        continue;
      }

      // targetAudience
      //
      if (n.name () == "targetAudience" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< targetAudience_type > r (
          targetAudience_traits::create (i, f, this));

        this->targetAudience_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  typeType* typeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class typeType (*this, f, c);
  }

  typeType::
  ~typeType ()
  {
  }

  // descriptionType
  //

  descriptionType::
  descriptionType (const description_type& description)
  : ::xml_schema::type (),
    description_ (description, ::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  descriptionType::
  descriptionType (::std::auto_ptr< description_type >& description)
  : ::xml_schema::type (),
    description_ (description, ::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  descriptionType::
  descriptionType (const descriptionType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    description_ (x.description_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    note_ (x.note_, f, this)
  {
  }

  descriptionType::
  descriptionType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    description_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void descriptionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (r);
          continue;
        }
      }

      break;
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "http://purl.org/dc/elements/1.1/");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  descriptionType* descriptionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class descriptionType (*this, f, c);
  }

  descriptionType::
  ~descriptionType ()
  {
  }

  // coverageType
  //

  coverageType::
  coverageType ()
  : ::xml_schema::type (),
    coverage_ (::xml_schema::flags (), this),
    temporal_ (::xml_schema::flags (), this),
    spatial_ (::xml_schema::flags (), this)
  {
  }

  coverageType::
  coverageType (const coverageType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    coverage_ (x.coverage_, f, this),
    temporal_ (x.temporal_, f, this),
    spatial_ (x.spatial_, f, this)
  {
  }

  coverageType::
  coverageType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    coverage_ (f, this),
    temporal_ (f, this),
    spatial_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void coverageType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // coverage
      //
      if (n.name () == "coverage" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< coverage_type > r (
          coverage_traits::create (i, f, this));

        if (!this->coverage_)
        {
          this->coverage_.set (r);
          continue;
        }
      }

      // temporal
      //
      if (n.name () == "temporal" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< temporal_type > r (
          temporal_traits::create (i, f, this));

        if (!this->temporal_)
        {
          this->temporal_.set (r);
          continue;
        }
      }

      // spatial
      //
      if (n.name () == "spatial" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< spatial_type > r (
          spatial_traits::create (i, f, this));

        if (!this->spatial_)
        {
          this->spatial_.set (r);
          continue;
        }
      }

      break;
    }
  }

  coverageType* coverageType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class coverageType (*this, f, c);
  }

  coverageType::
  ~coverageType ()
  {
  }

  // rightsType
  //

  rightsType::
  rightsType ()
  : ::xml_schema::type (),
    rights_ (::xml_schema::flags (), this),
    rightsLink_ (::xml_schema::flags (), this),
    rightsHolder_ (::xml_schema::flags (), this),
    exploitationIssues_ (::xml_schema::flags (), this),
    coverage_ (::xml_schema::flags (), this),
    rightsClearanceFlag_ (::xml_schema::flags (), this),
    disclaimer_ (::xml_schema::flags (), this),
    rightsId_ (::xml_schema::flags (), this),
    contactDetails_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this),
    formatIDRefs_ (::xml_schema::flags (), this)
  {
  }

  rightsType::
  rightsType (const rightsType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    rights_ (x.rights_, f, this),
    rightsLink_ (x.rightsLink_, f, this),
    rightsHolder_ (x.rightsHolder_, f, this),
    exploitationIssues_ (x.exploitationIssues_, f, this),
    coverage_ (x.coverage_, f, this),
    rightsClearanceFlag_ (x.rightsClearanceFlag_, f, this),
    disclaimer_ (x.disclaimer_, f, this),
    rightsId_ (x.rightsId_, f, this),
    contactDetails_ (x.contactDetails_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    note_ (x.note_, f, this),
    formatIDRefs_ (x.formatIDRefs_, f, this)
  {
  }

  rightsType::
  rightsType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    rights_ (f, this),
    rightsLink_ (f, this),
    rightsHolder_ (f, this),
    exploitationIssues_ (f, this),
    coverage_ (f, this),
    rightsClearanceFlag_ (f, this),
    disclaimer_ (f, this),
    rightsId_ (f, this),
    contactDetails_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    note_ (f, this),
    formatIDRefs_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void rightsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // rights
      //
      if (n.name () == "rights" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< rights_type > r (
          rights_traits::create (i, f, this));

        if (!this->rights_)
        {
          this->rights_.set (r);
          continue;
        }
      }

      // rightsLink
      //
      if (n.name () == "rightsLink" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< rightsLink_type > r (
          rightsLink_traits::create (i, f, this));

        if (!this->rightsLink_)
        {
          this->rightsLink_.set (r);
          continue;
        }
      }

      // rightsHolder
      //
      if (n.name () == "rightsHolder" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< rightsHolder_type > r (
          rightsHolder_traits::create (i, f, this));

        if (!this->rightsHolder_)
        {
          this->rightsHolder_.set (r);
          continue;
        }
      }

      // exploitationIssues
      //
      if (n.name () == "exploitationIssues" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< exploitationIssues_type > r (
          exploitationIssues_traits::create (i, f, this));

        if (!this->exploitationIssues_)
        {
          this->exploitationIssues_.set (r);
          continue;
        }
      }

      // coverage
      //
      if (n.name () == "coverage" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< coverage_type > r (
          coverage_traits::create (i, f, this));

        if (!this->coverage_)
        {
          this->coverage_.set (r);
          continue;
        }
      }

      // rightsClearanceFlag
      //
      if (n.name () == "rightsClearanceFlag" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->rightsClearanceFlag_)
        {
          this->rightsClearanceFlag_.set (rightsClearanceFlag_traits::create (i, f, this));
          continue;
        }
      }

      // disclaimer
      //
      if (n.name () == "disclaimer" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< disclaimer_type > r (
          disclaimer_traits::create (i, f, this));

        this->disclaimer_.push_back (r);
        continue;
      }

      // rightsId
      //
      if (n.name () == "rightsId" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< rightsId_type > r (
          rightsId_traits::create (i, f, this));

        this->rightsId_.push_back (r);
        continue;
      }

      // contactDetails
      //
      if (n.name () == "contactDetails" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< contactDetails_type > r (
          contactDetails_traits::create (i, f, this));

        this->contactDetails_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }

      if (n.name () == "formatIDRefs" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatIDRefs_type > r (
          formatIDRefs_traits::create (i, f, this));

        this->formatIDRefs_.set (r);
        continue;
      }
    }
  }

  rightsType* rightsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class rightsType (*this, f, c);
  }

  rightsType::
  ~rightsType ()
  {
  }

  // formatType
  //

  formatType::
  formatType ()
  : ::xml_schema::type (),
    format_ (::xml_schema::flags (), this),
    regionDelimX_ (::xml_schema::flags (), this),
    regionDelimY_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    height_ (::xml_schema::flags (), this),
    medium_ (::xml_schema::flags (), this),
    mimeType_ (::xml_schema::flags (), this),
    imageFormat_ (::xml_schema::flags (), this),
    videoFormat_ (::xml_schema::flags (), this),
    audioFormat_ (::xml_schema::flags (), this),
    containerFormat_ (::xml_schema::flags (), this),
    dataFormat_ (::xml_schema::flags (), this),
    signingFormat_ (::xml_schema::flags (), this),
    start_ (::xml_schema::flags (), this),
    end_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    fileSize_ (::xml_schema::flags (), this),
    filename_ (::xml_schema::flags (), this),
    locator_ (::xml_schema::flags (), this),
    documentFormat_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    dateCreated_ (::xml_schema::flags (), this),
    dateModified_ (::xml_schema::flags (), this),
    formatId_ (::xml_schema::flags (), this),
    formatName_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this)
  {
  }

  formatType::
  formatType (const formatType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    format_ (x.format_, f, this),
    regionDelimX_ (x.regionDelimX_, f, this),
    regionDelimY_ (x.regionDelimY_, f, this),
    width_ (x.width_, f, this),
    height_ (x.height_, f, this),
    medium_ (x.medium_, f, this),
    mimeType_ (x.mimeType_, f, this),
    imageFormat_ (x.imageFormat_, f, this),
    videoFormat_ (x.videoFormat_, f, this),
    audioFormat_ (x.audioFormat_, f, this),
    containerFormat_ (x.containerFormat_, f, this),
    dataFormat_ (x.dataFormat_, f, this),
    signingFormat_ (x.signingFormat_, f, this),
    start_ (x.start_, f, this),
    end_ (x.end_, f, this),
    duration_ (x.duration_, f, this),
    fileSize_ (x.fileSize_, f, this),
    filename_ (x.filename_, f, this),
    locator_ (x.locator_, f, this),
    documentFormat_ (x.documentFormat_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    dateCreated_ (x.dateCreated_, f, this),
    dateModified_ (x.dateModified_, f, this),
    formatId_ (x.formatId_, f, this),
    formatName_ (x.formatName_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this)
  {
  }

  formatType::
  formatType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    format_ (f, this),
    regionDelimX_ (f, this),
    regionDelimY_ (f, this),
    width_ (f, this),
    height_ (f, this),
    medium_ (f, this),
    mimeType_ (f, this),
    imageFormat_ (f, this),
    videoFormat_ (f, this),
    audioFormat_ (f, this),
    containerFormat_ (f, this),
    dataFormat_ (f, this),
    signingFormat_ (f, this),
    start_ (f, this),
    end_ (f, this),
    duration_ (f, this),
    fileSize_ (f, this),
    filename_ (f, this),
    locator_ (f, this),
    documentFormat_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    dateCreated_ (f, this),
    dateModified_ (f, this),
    formatId_ (f, this),
    formatName_ (f, this),
    formatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void formatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // format
      //
      if (n.name () == "format" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< format_type > r (
          format_traits::create (i, f, this));

        if (!this->format_)
        {
          this->format_.set (r);
          continue;
        }
      }

      // regionDelimX
      //
      if (n.name () == "regionDelimX" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->regionDelimX_)
        {
          this->regionDelimX_.set (regionDelimX_traits::create (i, f, this));
          continue;
        }
      }

      // regionDelimY
      //
      if (n.name () == "regionDelimY" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->regionDelimY_)
        {
          this->regionDelimY_.set (regionDelimY_traits::create (i, f, this));
          continue;
        }
      }

      // width
      //
      if (n.name () == "width" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< width_type > r (
          width_traits::create (i, f, this));

        if (!this->width_)
        {
          this->width_.set (r);
          continue;
        }
      }

      // height
      //
      if (n.name () == "height" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< height_type > r (
          height_traits::create (i, f, this));

        if (!this->height_)
        {
          this->height_.set (r);
          continue;
        }
      }

      // medium
      //
      if (n.name () == "medium" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< medium_type > r (
          medium_traits::create (i, f, this));

        this->medium_.push_back (r);
        continue;
      }

      // mimeType
      //
      if (n.name () == "mimeType" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< mimeType_type > r (
          mimeType_traits::create (i, f, this));

        this->mimeType_.push_back (r);
        continue;
      }

      // imageFormat
      //
      if (n.name () == "imageFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< imageFormat_type > r (
          imageFormat_traits::create (i, f, this));

        this->imageFormat_.push_back (r);
        continue;
      }

      // videoFormat
      //
      if (n.name () == "videoFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< videoFormat_type > r (
          videoFormat_traits::create (i, f, this));

        this->videoFormat_.push_back (r);
        continue;
      }

      // audioFormat
      //
      if (n.name () == "audioFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< audioFormat_type > r (
          audioFormat_traits::create (i, f, this));

        this->audioFormat_.push_back (r);
        continue;
      }

      // containerFormat
      //
      if (n.name () == "containerFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< containerFormat_type > r (
          containerFormat_traits::create (i, f, this));

        this->containerFormat_.push_back (r);
        continue;
      }

      // dataFormat
      //
      if (n.name () == "dataFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< dataFormat_type > r (
          dataFormat_traits::create (i, f, this));

        this->dataFormat_.push_back (r);
        continue;
      }

      // signingFormat
      //
      if (n.name () == "signingFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< signingFormat_type > r (
          signingFormat_traits::create (i, f, this));

        this->signingFormat_.push_back (r);
        continue;
      }

      // start
      //
      if (n.name () == "start" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< start_type > r (
          start_traits::create (i, f, this));

        if (!this->start_)
        {
          this->start_.set (r);
          continue;
        }
      }

      // end
      //
      if (n.name () == "end" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< end_type > r (
          end_traits::create (i, f, this));

        if (!this->end_)
        {
          this->end_.set (r);
          continue;
        }
      }

      // duration
      //
      if (n.name () == "duration" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        if (!this->duration_)
        {
          this->duration_.set (r);
          continue;
        }
      }

      // fileSize
      //
      if (n.name () == "fileSize" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->fileSize_)
        {
          this->fileSize_.set (fileSize_traits::create (i, f, this));
          continue;
        }
      }

      // filename
      //
      if (n.name () == "filename" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< filename_type > r (
          filename_traits::create (i, f, this));

        if (!this->filename_)
        {
          this->filename_.set (r);
          continue;
        }
      }

      // locator
      //
      if (n.name () == "locator" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< locator_type > r (
          locator_traits::create (i, f, this));

        if (!this->locator_)
        {
          this->locator_.set (r);
          continue;
        }
      }

      // documentFormat
      //
      if (n.name () == "documentFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< documentFormat_type > r (
          documentFormat_traits::create (i, f, this));

        if (!this->documentFormat_)
        {
          this->documentFormat_.set (r);
          continue;
        }
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      // dateCreated
      //
      if (n.name () == "dateCreated" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< dateCreated_type > r (
          dateCreated_traits::create (i, f, this));

        if (!this->dateCreated_)
        {
          this->dateCreated_.set (r);
          continue;
        }
      }

      // dateModified
      //
      if (n.name () == "dateModified" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< dateModified_type > r (
          dateModified_traits::create (i, f, this));

        if (!this->dateModified_)
        {
          this->dateModified_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatId_type > r (
          formatId_traits::create (i, f, this));

        this->formatId_.set (r);
        continue;
      }

      if (n.name () == "formatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatName_type > r (
          formatName_traits::create (i, f, this));

        this->formatName_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }
    }
  }

  formatType* formatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class formatType (*this, f, c);
  }

  formatType::
  ~formatType ()
  {
  }

  // relationType
  //

  relationType::
  relationType ()
  : ::xml_schema::type (),
    relation_ (::xml_schema::flags (), this),
    relationIdentifier_ (::xml_schema::flags (), this),
    relationLink_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    runningOrderNumber_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  relationType::
  relationType (const relationType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    relation_ (x.relation_, f, this),
    relationIdentifier_ (x.relationIdentifier_, f, this),
    relationLink_ (x.relationLink_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    runningOrderNumber_ (x.runningOrderNumber_, f, this),
    note_ (x.note_, f, this)
  {
  }

  relationType::
  relationType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    relation_ (f, this),
    relationIdentifier_ (f, this),
    relationLink_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    runningOrderNumber_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void relationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // relation
      //
      if (n.name () == "relation" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< relation_type > r (
          relation_traits::create (i, f, this));

        if (!this->relation_)
        {
          this->relation_.set (r);
          continue;
        }
      }

      // relationIdentifier
      //
      if (n.name () == "relationIdentifier" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< relationIdentifier_type > r (
          relationIdentifier_traits::create (i, f, this));

        if (!this->relationIdentifier_)
        {
          this->relationIdentifier_.set (r);
          continue;
        }
      }

      // relationLink
      //
      if (n.name () == "relationLink" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< relationLink_type > r (
          relationLink_traits::create (i, f, this));

        if (!this->relationLink_)
        {
          this->relationLink_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "runningOrderNumber" && n.namespace_ ().empty ())
      {
        this->runningOrderNumber_.set (runningOrderNumber_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  relationType* relationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class relationType (*this, f, c);
  }

  relationType::
  ~relationType ()
  {
  }

  // languageType
  //

  languageType::
  languageType ()
  : ::xml_schema::type (),
    language_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  languageType::
  languageType (const languageType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    language_ (x.language_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    note_ (x.note_, f, this)
  {
  }

  languageType::
  languageType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    language_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void languageType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // language
      //
      if (n.name () == "language" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< language_type > r (
          language_traits::create (i, f, this));

        if (!this->language_)
        {
          this->language_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  languageType* languageType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class languageType (*this, f, c);
  }

  languageType::
  ~languageType ()
  {
  }

  // dateType
  //

  dateType::
  dateType ()
  : ::xml_schema::type (),
    date_ (::xml_schema::flags (), this),
    created_ (::xml_schema::flags (), this),
    issued_ (::xml_schema::flags (), this),
    modified_ (::xml_schema::flags (), this),
    digitised_ (::xml_schema::flags (), this),
    alternative_ (::xml_schema::flags (), this)
  {
  }

  dateType::
  dateType (const dateType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    date_ (x.date_, f, this),
    created_ (x.created_, f, this),
    issued_ (x.issued_, f, this),
    modified_ (x.modified_, f, this),
    digitised_ (x.digitised_, f, this),
    alternative_ (x.alternative_, f, this)
  {
  }

  dateType::
  dateType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    date_ (f, this),
    created_ (f, this),
    issued_ (f, this),
    modified_ (f, this),
    digitised_ (f, this),
    alternative_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void dateType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // date
      //
      if (n.name () == "date" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< date_type > r (
          date_traits::create (i, f, this));

        this->date_.push_back (r);
        continue;
      }

      // created
      //
      if (n.name () == "created" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< created_type > r (
          created_traits::create (i, f, this));

        if (!this->created_)
        {
          this->created_.set (r);
          continue;
        }
      }

      // issued
      //
      if (n.name () == "issued" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< issued_type > r (
          issued_traits::create (i, f, this));

        if (!this->issued_)
        {
          this->issued_.set (r);
          continue;
        }
      }

      // modified
      //
      if (n.name () == "modified" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< modified_type > r (
          modified_traits::create (i, f, this));

        if (!this->modified_)
        {
          this->modified_.set (r);
          continue;
        }
      }

      // digitised
      //
      if (n.name () == "digitised" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< digitised_type > r (
          digitised_traits::create (i, f, this));

        if (!this->digitised_)
        {
          this->digitised_.set (r);
          continue;
        }
      }

      // alternative
      //
      if (n.name () == "alternative" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< alternative_type > r (
          alternative_traits::create (i, f, this));

        this->alternative_.push_back (r);
        continue;
      }

      break;
    }
  }

  dateType* dateType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dateType (*this, f, c);
  }

  dateType::
  ~dateType ()
  {
  }

  // publicationHistoryType
  //

  publicationHistoryType::
  publicationHistoryType ()
  : ::xml_schema::type (),
    firstPublicationDate_ (::xml_schema::flags (), this),
    firstPublicationTime_ (::xml_schema::flags (), this),
    firstPublicationChannel_ (::xml_schema::flags (), this),
    repeatDate_ (::xml_schema::flags (), this),
    repeatTime_ (::xml_schema::flags (), this),
    repeatChannel_ (::xml_schema::flags (), this)
  {
  }

  publicationHistoryType::
  publicationHistoryType (const publicationHistoryType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    firstPublicationDate_ (x.firstPublicationDate_, f, this),
    firstPublicationTime_ (x.firstPublicationTime_, f, this),
    firstPublicationChannel_ (x.firstPublicationChannel_, f, this),
    repeatDate_ (x.repeatDate_, f, this),
    repeatTime_ (x.repeatTime_, f, this),
    repeatChannel_ (x.repeatChannel_, f, this)
  {
  }

  publicationHistoryType::
  publicationHistoryType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    firstPublicationDate_ (f, this),
    firstPublicationTime_ (f, this),
    firstPublicationChannel_ (f, this),
    repeatDate_ (f, this),
    repeatTime_ (f, this),
    repeatChannel_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void publicationHistoryType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // firstPublicationDate
      //
      if (n.name () == "firstPublicationDate" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< firstPublicationDate_type > r (
          firstPublicationDate_traits::create (i, f, this));

        if (!this->firstPublicationDate_)
        {
          this->firstPublicationDate_.set (r);
          continue;
        }
      }

      // firstPublicationTime
      //
      if (n.name () == "firstPublicationTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< firstPublicationTime_type > r (
          firstPublicationTime_traits::create (i, f, this));

        if (!this->firstPublicationTime_)
        {
          this->firstPublicationTime_.set (r);
          continue;
        }
      }

      // firstPublicationChannel
      //
      if (n.name () == "firstPublicationChannel" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< firstPublicationChannel_type > r (
          firstPublicationChannel_traits::create (i, f, this));

        if (!this->firstPublicationChannel_)
        {
          this->firstPublicationChannel_.set (r);
          continue;
        }
      }

      // repeatDate
      //
      if (n.name () == "repeatDate" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< repeatDate_type > r (
          repeatDate_traits::create (i, f, this));

        this->repeatDate_.push_back (r);
        continue;
      }

      // repeatTime
      //
      if (n.name () == "repeatTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< repeatTime_type > r (
          repeatTime_traits::create (i, f, this));

        this->repeatTime_.push_back (r);
        continue;
      }

      // repeatChannel
      //
      if (n.name () == "repeatChannel" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< repeatChannel_type > r (
          repeatChannel_traits::create (i, f, this));

        this->repeatChannel_.push_back (r);
        continue;
      }

      break;
    }
  }

  publicationHistoryType* publicationHistoryType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class publicationHistoryType (*this, f, c);
  }

  publicationHistoryType::
  ~publicationHistoryType ()
  {
  }

  // entityType
  //

  entityType::
  entityType ()
  : ::xml_schema::type (),
    contactDetails_ (::xml_schema::flags (), this),
    organisationDetails_ (::xml_schema::flags (), this),
    role_ (::xml_schema::flags (), this),
    entityId_ (::xml_schema::flags (), this)
  {
  }

  entityType::
  entityType (const entityType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    contactDetails_ (x.contactDetails_, f, this),
    organisationDetails_ (x.organisationDetails_, f, this),
    role_ (x.role_, f, this),
    entityId_ (x.entityId_, f, this)
  {
  }

  entityType::
  entityType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    contactDetails_ (f, this),
    organisationDetails_ (f, this),
    role_ (f, this),
    entityId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void entityType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // contactDetails
      //
      if (n.name () == "contactDetails" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< contactDetails_type > r (
          contactDetails_traits::create (i, f, this));

        this->contactDetails_.push_back (r);
        continue;
      }

      // organisationDetails
      //
      if (n.name () == "organisationDetails" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< organisationDetails_type > r (
          organisationDetails_traits::create (i, f, this));

        if (!this->organisationDetails_)
        {
          this->organisationDetails_.set (r);
          continue;
        }
      }

      // role
      //
      if (n.name () == "role" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< role_type > r (
          role_traits::create (i, f, this));

        this->role_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "entityId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< entityId_type > r (
          entityId_traits::create (i, f, this));

        this->entityId_.set (r);
        continue;
      }
    }
  }

  entityType* entityType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class entityType (*this, f, c);
  }

  entityType::
  ~entityType ()
  {
  }

  // contactDetailsType
  //

  contactDetailsType::
  contactDetailsType ()
  : ::xml_schema::type (),
    name_ (::xml_schema::flags (), this),
    givenName_ (::xml_schema::flags (), this),
    familyName_ (::xml_schema::flags (), this),
    username_ (::xml_schema::flags (), this),
    occupation_ (::xml_schema::flags (), this),
    details_ (::xml_schema::flags (), this),
    stageName_ (::xml_schema::flags (), this),
    relatedContacts_ (::xml_schema::flags (), this),
    contactId_ (::xml_schema::flags (), this)
  {
  }

  contactDetailsType::
  contactDetailsType (const contactDetailsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    givenName_ (x.givenName_, f, this),
    familyName_ (x.familyName_, f, this),
    username_ (x.username_, f, this),
    occupation_ (x.occupation_, f, this),
    details_ (x.details_, f, this),
    stageName_ (x.stageName_, f, this),
    relatedContacts_ (x.relatedContacts_, f, this),
    contactId_ (x.contactId_, f, this)
  {
  }

  contactDetailsType::
  contactDetailsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    givenName_ (f, this),
    familyName_ (f, this),
    username_ (f, this),
    occupation_ (f, this),
    details_ (f, this),
    stageName_ (f, this),
    relatedContacts_ (f, this),
    contactId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void contactDetailsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (r);
          continue;
        }
      }

      // givenName
      //
      if (n.name () == "givenName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< givenName_type > r (
          givenName_traits::create (i, f, this));

        if (!this->givenName_)
        {
          this->givenName_.set (r);
          continue;
        }
      }

      // familyName
      //
      if (n.name () == "familyName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< familyName_type > r (
          familyName_traits::create (i, f, this));

        if (!this->familyName_)
        {
          this->familyName_.set (r);
          continue;
        }
      }

      // username
      //
      if (n.name () == "username" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< username_type > r (
          username_traits::create (i, f, this));

        if (!this->username_)
        {
          this->username_.set (r);
          continue;
        }
      }

      // occupation
      //
      if (n.name () == "occupation" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< occupation_type > r (
          occupation_traits::create (i, f, this));

        if (!this->occupation_)
        {
          this->occupation_.set (r);
          continue;
        }
      }

      // details
      //
      if (n.name () == "details" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< details_type > r (
          details_traits::create (i, f, this));

        this->details_.push_back (r);
        continue;
      }

      // stageName
      //
      if (n.name () == "stageName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< stageName_type > r (
          stageName_traits::create (i, f, this));

        this->stageName_.push_back (r);
        continue;
      }

      // relatedContacts
      //
      if (n.name () == "relatedContacts" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< relatedContacts_type > r (
          relatedContacts_traits::create (i, f, this));

        this->relatedContacts_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "contactId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< contactId_type > r (
          contactId_traits::create (i, f, this));

        this->contactId_.set (r);
        continue;
      }
    }
  }

  contactDetailsType* contactDetailsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class contactDetailsType (*this, f, c);
  }

  contactDetailsType::
  ~contactDetailsType ()
  {
  }

  // organisationDetailsType
  //

  organisationDetailsType::
  organisationDetailsType (const organisationName_type& organisationName)
  : ::xml_schema::type (),
    organisationName_ (organisationName, ::xml_schema::flags (), this),
    organisationDepartment_ (::xml_schema::flags (), this),
    details_ (::xml_schema::flags (), this),
    contacts_ (::xml_schema::flags (), this),
    organisationId_ (::xml_schema::flags (), this)
  {
  }

  organisationDetailsType::
  organisationDetailsType (::std::auto_ptr< organisationName_type >& organisationName)
  : ::xml_schema::type (),
    organisationName_ (organisationName, ::xml_schema::flags (), this),
    organisationDepartment_ (::xml_schema::flags (), this),
    details_ (::xml_schema::flags (), this),
    contacts_ (::xml_schema::flags (), this),
    organisationId_ (::xml_schema::flags (), this)
  {
  }

  organisationDetailsType::
  organisationDetailsType (const organisationDetailsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    organisationName_ (x.organisationName_, f, this),
    organisationDepartment_ (x.organisationDepartment_, f, this),
    details_ (x.details_, f, this),
    contacts_ (x.contacts_, f, this),
    organisationId_ (x.organisationId_, f, this)
  {
  }

  organisationDetailsType::
  organisationDetailsType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    organisationName_ (f, this),
    organisationDepartment_ (f, this),
    details_ (f, this),
    contacts_ (f, this),
    organisationId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void organisationDetailsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // organisationName
      //
      if (n.name () == "organisationName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< organisationName_type > r (
          organisationName_traits::create (i, f, this));

        if (!organisationName_.present ())
        {
          this->organisationName_.set (r);
          continue;
        }
      }

      // organisationDepartment
      //
      if (n.name () == "organisationDepartment" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< organisationDepartment_type > r (
          organisationDepartment_traits::create (i, f, this));

        if (!this->organisationDepartment_)
        {
          this->organisationDepartment_.set (r);
          continue;
        }
      }

      // details
      //
      if (n.name () == "details" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< details_type > r (
          details_traits::create (i, f, this));

        this->details_.push_back (r);
        continue;
      }

      // contacts
      //
      if (n.name () == "contacts" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< contacts_type > r (
          contacts_traits::create (i, f, this));

        this->contacts_.push_back (r);
        continue;
      }

      break;
    }

    if (!organisationName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "organisationName",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "organisationId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< organisationId_type > r (
          organisationId_traits::create (i, f, this));

        this->organisationId_.set (r);
        continue;
      }
    }
  }

  organisationDetailsType* organisationDetailsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class organisationDetailsType (*this, f, c);
  }

  organisationDetailsType::
  ~organisationDetailsType ()
  {
  }

  // detailsType
  //

  detailsType::
  detailsType ()
  : ::xml_schema::type (),
    emailAddress_ (::xml_schema::flags (), this),
    webAddress_ (::xml_schema::flags (), this),
    address_ (::xml_schema::flags (), this),
    telephoneNumber_ (::xml_schema::flags (), this),
    mobileTelephoneNumber_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  detailsType::
  detailsType (const detailsType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    emailAddress_ (x.emailAddress_, f, this),
    webAddress_ (x.webAddress_, f, this),
    address_ (x.address_, f, this),
    telephoneNumber_ (x.telephoneNumber_, f, this),
    mobileTelephoneNumber_ (x.mobileTelephoneNumber_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  detailsType::
  detailsType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    emailAddress_ (f, this),
    webAddress_ (f, this),
    address_ (f, this),
    telephoneNumber_ (f, this),
    mobileTelephoneNumber_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void detailsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // emailAddress
      //
      if (n.name () == "emailAddress" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< emailAddress_type > r (
          emailAddress_traits::create (i, f, this));

        if (!this->emailAddress_)
        {
          this->emailAddress_.set (r);
          continue;
        }
      }

      // webAddress
      //
      if (n.name () == "webAddress" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< webAddress_type > r (
          webAddress_traits::create (i, f, this));

        if (!this->webAddress_)
        {
          this->webAddress_.set (r);
          continue;
        }
      }

      // address
      //
      if (n.name () == "address" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< address_type > r (
          address_traits::create (i, f, this));

        if (!this->address_)
        {
          this->address_.set (r);
          continue;
        }
      }

      // telephoneNumber
      //
      if (n.name () == "telephoneNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< telephoneNumber_type > r (
          telephoneNumber_traits::create (i, f, this));

        if (!this->telephoneNumber_)
        {
          this->telephoneNumber_.set (r);
          continue;
        }
      }

      // mobileTelephoneNumber
      //
      if (n.name () == "mobileTelephoneNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< mobileTelephoneNumber_type > r (
          mobileTelephoneNumber_traits::create (i, f, this));

        if (!this->mobileTelephoneNumber_)
        {
          this->mobileTelephoneNumber_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  detailsType* detailsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class detailsType (*this, f, c);
  }

  detailsType::
  ~detailsType ()
  {
  }

  // addressType
  //

  addressType::
  addressType ()
  : ::xml_schema::type (),
    addressLine_ (::xml_schema::flags (), this),
    addressTownCity_ (::xml_schema::flags (), this),
    addressCountyState_ (::xml_schema::flags (), this),
    addressDeliveryCode_ (::xml_schema::flags (), this),
    country_ (::xml_schema::flags (), this)
  {
  }

  addressType::
  addressType (const addressType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    addressLine_ (x.addressLine_, f, this),
    addressTownCity_ (x.addressTownCity_, f, this),
    addressCountyState_ (x.addressCountyState_, f, this),
    addressDeliveryCode_ (x.addressDeliveryCode_, f, this),
    country_ (x.country_, f, this)
  {
  }

  addressType::
  addressType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    addressLine_ (f, this),
    addressTownCity_ (f, this),
    addressCountyState_ (f, this),
    addressDeliveryCode_ (f, this),
    country_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void addressType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // addressLine
      //
      if (n.name () == "addressLine" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< addressLine_type > r (
          addressLine_traits::create (i, f, this));

        this->addressLine_.push_back (r);
        continue;
      }

      // addressTownCity
      //
      if (n.name () == "addressTownCity" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< addressTownCity_type > r (
          addressTownCity_traits::create (i, f, this));

        if (!this->addressTownCity_)
        {
          this->addressTownCity_.set (r);
          continue;
        }
      }

      // addressCountyState
      //
      if (n.name () == "addressCountyState" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< addressCountyState_type > r (
          addressCountyState_traits::create (i, f, this));

        if (!this->addressCountyState_)
        {
          this->addressCountyState_.set (r);
          continue;
        }
      }

      // addressDeliveryCode
      //
      if (n.name () == "addressDeliveryCode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< addressDeliveryCode_type > r (
          addressDeliveryCode_traits::create (i, f, this));

        if (!this->addressDeliveryCode_)
        {
          this->addressDeliveryCode_.set (r);
          continue;
        }
      }

      // country
      //
      if (n.name () == "country" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< country_type > r (
          country_traits::create (i, f, this));

        if (!this->country_)
        {
          this->country_.set (r);
          continue;
        }
      }

      break;
    }
  }

  addressType* addressType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class addressType (*this, f, c);
  }

  addressType::
  ~addressType ()
  {
  }

  // editUnitNumberType
  //

  editUnitNumberType::
  editUnitNumberType (const ::xml_schema::long_& _xsd_long__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (_xsd_long__base),
    editRate_ (::xml_schema::flags (), this),
    factorNumerator_ (factorNumerator_default_value (), ::xml_schema::flags (), this),
    factorDenominator_ (factorDenominator_default_value (), ::xml_schema::flags (), this)
  {
  }

  editUnitNumberType::
  editUnitNumberType (const editUnitNumberType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c),
    editRate_ (x.editRate_, f, this),
    factorNumerator_ (x.factorNumerator_, f, this),
    factorDenominator_ (x.factorDenominator_, f, this)
  {
  }

  editUnitNumberType::
  editUnitNumberType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    editRate_ (f, this),
    factorNumerator_ (f, this),
    factorDenominator_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void editUnitNumberType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "editRate" && n.namespace_ ().empty ())
      {
        this->editRate_.set (editRate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "factorNumerator" && n.namespace_ ().empty ())
      {
        this->factorNumerator_.set (factorNumerator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "factorDenominator" && n.namespace_ ().empty ())
      {
        this->factorDenominator_.set (factorDenominator_traits::create (i, f, this));
        continue;
      }
    }

    if (!factorNumerator_.present ())
    {
      this->factorNumerator_.set (factorNumerator_default_value ());
    }

    if (!factorDenominator_.present ())
    {
      this->factorDenominator_.set (factorDenominator_default_value ());
    }
  }

  editUnitNumberType* editUnitNumberType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class editUnitNumberType (*this, f, c);
  }

  editUnitNumberType::
  ~editUnitNumberType ()
  {
  }

  // ratingType
  //

  ratingType::
  ratingType (const ratingValue_type& ratingValue,
              const ratingScaleMaxValue_type& ratingScaleMaxValue,
              const ratingScaleMinValue_type& ratingScaleMinValue,
              const ratingProvider_type& ratingProvider)
  : ::xml_schema::type (),
    ratingValue_ (ratingValue, ::xml_schema::flags (), this),
    ratingScaleMaxValue_ (ratingScaleMaxValue, ::xml_schema::flags (), this),
    ratingScaleMinValue_ (ratingScaleMinValue, ::xml_schema::flags (), this),
    ratingProvider_ (ratingProvider, ::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  ratingType::
  ratingType (const ratingValue_type& ratingValue,
              const ratingScaleMaxValue_type& ratingScaleMaxValue,
              const ratingScaleMinValue_type& ratingScaleMinValue,
              ::std::auto_ptr< ratingProvider_type >& ratingProvider)
  : ::xml_schema::type (),
    ratingValue_ (ratingValue, ::xml_schema::flags (), this),
    ratingScaleMaxValue_ (ratingScaleMaxValue, ::xml_schema::flags (), this),
    ratingScaleMinValue_ (ratingScaleMinValue, ::xml_schema::flags (), this),
    ratingProvider_ (ratingProvider, ::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  ratingType::
  ratingType (const ratingType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ratingValue_ (x.ratingValue_, f, this),
    ratingScaleMaxValue_ (x.ratingScaleMaxValue_, f, this),
    ratingScaleMinValue_ (x.ratingScaleMinValue_, f, this),
    ratingProvider_ (x.ratingProvider_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this)
  {
  }

  ratingType::
  ratingType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ratingValue_ (f, this),
    ratingScaleMaxValue_ (f, this),
    ratingScaleMinValue_ (f, this),
    ratingProvider_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ratingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ratingValue
      //
      if (n.name () == "ratingValue" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< ratingValue_type > r (
          ratingValue_traits::create (i, f, this));

        if (!ratingValue_.present ())
        {
          this->ratingValue_.set (r);
          continue;
        }
      }

      // ratingScaleMaxValue
      //
      if (n.name () == "ratingScaleMaxValue" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< ratingScaleMaxValue_type > r (
          ratingScaleMaxValue_traits::create (i, f, this));

        if (!ratingScaleMaxValue_.present ())
        {
          this->ratingScaleMaxValue_.set (r);
          continue;
        }
      }

      // ratingScaleMinValue
      //
      if (n.name () == "ratingScaleMinValue" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< ratingScaleMinValue_type > r (
          ratingScaleMinValue_traits::create (i, f, this));

        if (!ratingScaleMinValue_.present ())
        {
          this->ratingScaleMinValue_.set (r);
          continue;
        }
      }

      // ratingProvider
      //
      if (n.name () == "ratingProvider" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< ratingProvider_type > r (
          ratingProvider_traits::create (i, f, this));

        if (!ratingProvider_.present ())
        {
          this->ratingProvider_.set (r);
          continue;
        }
      }

      break;
    }

    if (!ratingValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ratingValue",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }

    if (!ratingScaleMaxValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ratingScaleMaxValue",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }

    if (!ratingScaleMinValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ratingScaleMinValue",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }

    if (!ratingProvider_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ratingProvider",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }
    }
  }

  ratingType* ratingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ratingType (*this, f, c);
  }

  ratingType::
  ~ratingType ()
  {
  }

  // lengthType
  //

  lengthType::
  lengthType (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base),
    unit_ (::xml_schema::flags (), this)
  {
  }

  lengthType::
  lengthType (const lengthType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c),
    unit_ (x.unit_, f, this)
  {
  }

  lengthType::
  lengthType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    unit_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void lengthType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }
    }
  }

  lengthType* lengthType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class lengthType (*this, f, c);
  }

  lengthType::
  ~lengthType ()
  {
  }

  // imageFormatType
  //

  imageFormatType::
  imageFormatType ()
  : ::xml_schema::type (),
    regionDelimX_ (::xml_schema::flags (), this),
    regionDelimY_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    height_ (::xml_schema::flags (), this),
    orientation_ (::xml_schema::flags (), this),
    imageEncoding_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    imageFormatId_ (::xml_schema::flags (), this),
    imageFormatName_ (::xml_schema::flags (), this),
    imageFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  imageFormatType::
  imageFormatType (const imageFormatType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    regionDelimX_ (x.regionDelimX_, f, this),
    regionDelimY_ (x.regionDelimY_, f, this),
    width_ (x.width_, f, this),
    height_ (x.height_, f, this),
    orientation_ (x.orientation_, f, this),
    imageEncoding_ (x.imageEncoding_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    imageFormatId_ (x.imageFormatId_, f, this),
    imageFormatName_ (x.imageFormatName_, f, this),
    imageFormatDefinition_ (x.imageFormatDefinition_, f, this)
  {
  }

  imageFormatType::
  imageFormatType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    regionDelimX_ (f, this),
    regionDelimY_ (f, this),
    width_ (f, this),
    height_ (f, this),
    orientation_ (f, this),
    imageEncoding_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    imageFormatId_ (f, this),
    imageFormatName_ (f, this),
    imageFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void imageFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // regionDelimX
      //
      if (n.name () == "regionDelimX" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->regionDelimX_)
        {
          this->regionDelimX_.set (regionDelimX_traits::create (i, f, this));
          continue;
        }
      }

      // regionDelimY
      //
      if (n.name () == "regionDelimY" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->regionDelimY_)
        {
          this->regionDelimY_.set (regionDelimY_traits::create (i, f, this));
          continue;
        }
      }

      // width
      //
      if (n.name () == "width" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< width_type > r (
          width_traits::create (i, f, this));

        if (!this->width_)
        {
          this->width_.set (r);
          continue;
        }
      }

      // height
      //
      if (n.name () == "height" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< height_type > r (
          height_traits::create (i, f, this));

        if (!this->height_)
        {
          this->height_.set (r);
          continue;
        }
      }

      // orientation
      //
      if (n.name () == "orientation" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< orientation_type > r (
          orientation_traits::create (i, f, this));

        if (!this->orientation_)
        {
          this->orientation_.set (r);
          continue;
        }
      }

      // imageEncoding
      //
      if (n.name () == "imageEncoding" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< imageEncoding_type > r (
          imageEncoding_traits::create (i, f, this));

        this->imageEncoding_.push_back (r);
        continue;
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "imageFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< imageFormatId_type > r (
          imageFormatId_traits::create (i, f, this));

        this->imageFormatId_.set (r);
        continue;
      }

      if (n.name () == "imageFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< imageFormatName_type > r (
          imageFormatName_traits::create (i, f, this));

        this->imageFormatName_.set (r);
        continue;
      }

      if (n.name () == "imageFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< imageFormatDefinition_type > r (
          imageFormatDefinition_traits::create (i, f, this));

        this->imageFormatDefinition_.set (r);
        continue;
      }
    }
  }

  imageFormatType* imageFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class imageFormatType (*this, f, c);
  }

  imageFormatType::
  ~imageFormatType ()
  {
  }

  // videoFormatType
  //

  videoFormatType::
  videoFormatType ()
  : ::xml_schema::type (),
    regionDelimX_ (::xml_schema::flags (), this),
    regionDelimY_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    height_ (::xml_schema::flags (), this),
    aspectRatio_ (::xml_schema::flags (), this),
    videoEncoding_ (::xml_schema::flags (), this),
    videoTrack_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    videoFormatId_ (::xml_schema::flags (), this),
    videoFormatName_ (::xml_schema::flags (), this),
    videoFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  videoFormatType::
  videoFormatType (const videoFormatType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    regionDelimX_ (x.regionDelimX_, f, this),
    regionDelimY_ (x.regionDelimY_, f, this),
    width_ (x.width_, f, this),
    height_ (x.height_, f, this),
    aspectRatio_ (x.aspectRatio_, f, this),
    videoEncoding_ (x.videoEncoding_, f, this),
    videoTrack_ (x.videoTrack_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    videoFormatId_ (x.videoFormatId_, f, this),
    videoFormatName_ (x.videoFormatName_, f, this),
    videoFormatDefinition_ (x.videoFormatDefinition_, f, this)
  {
  }

  videoFormatType::
  videoFormatType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    regionDelimX_ (f, this),
    regionDelimY_ (f, this),
    width_ (f, this),
    height_ (f, this),
    aspectRatio_ (f, this),
    videoEncoding_ (f, this),
    videoTrack_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    videoFormatId_ (f, this),
    videoFormatName_ (f, this),
    videoFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void videoFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // regionDelimX
      //
      if (n.name () == "regionDelimX" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->regionDelimX_)
        {
          this->regionDelimX_.set (regionDelimX_traits::create (i, f, this));
          continue;
        }
      }

      // regionDelimY
      //
      if (n.name () == "regionDelimY" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->regionDelimY_)
        {
          this->regionDelimY_.set (regionDelimY_traits::create (i, f, this));
          continue;
        }
      }

      // width
      //
      if (n.name () == "width" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< width_type > r (
          width_traits::create (i, f, this));

        if (!this->width_)
        {
          this->width_.set (r);
          continue;
        }
      }

      // height
      //
      if (n.name () == "height" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< height_type > r (
          height_traits::create (i, f, this));

        if (!this->height_)
        {
          this->height_.set (r);
          continue;
        }
      }

      // aspectRatio
      //
      if (n.name () == "aspectRatio" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< aspectRatio_type > r (
          aspectRatio_traits::create (i, f, this));

        if (!this->aspectRatio_)
        {
          this->aspectRatio_.set (r);
          continue;
        }
      }

      // videoEncoding
      //
      if (n.name () == "videoEncoding" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< videoEncoding_type > r (
          videoEncoding_traits::create (i, f, this));

        this->videoEncoding_.push_back (r);
        continue;
      }

      // videoTrack
      //
      if (n.name () == "videoTrack" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< videoTrack_type > r (
          videoTrack_traits::create (i, f, this));

        this->videoTrack_.push_back (r);
        continue;
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "videoFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< videoFormatId_type > r (
          videoFormatId_traits::create (i, f, this));

        this->videoFormatId_.set (r);
        continue;
      }

      if (n.name () == "videoFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< videoFormatName_type > r (
          videoFormatName_traits::create (i, f, this));

        this->videoFormatName_.set (r);
        continue;
      }

      if (n.name () == "videoFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< videoFormatDefinition_type > r (
          videoFormatDefinition_traits::create (i, f, this));

        this->videoFormatDefinition_.set (r);
        continue;
      }
    }
  }

  videoFormatType* videoFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class videoFormatType (*this, f, c);
  }

  videoFormatType::
  ~videoFormatType ()
  {
  }

  // audioFormatType
  //

  audioFormatType::
  audioFormatType ()
  : ::xml_schema::type (),
    audioEncoding_ (::xml_schema::flags (), this),
    audioTrackConfiguration_ (::xml_schema::flags (), this),
    audioTrack_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    audioFormatId_ (::xml_schema::flags (), this),
    audioFormatName_ (::xml_schema::flags (), this),
    audioFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  audioFormatType::
  audioFormatType (const audioFormatType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    audioEncoding_ (x.audioEncoding_, f, this),
    audioTrackConfiguration_ (x.audioTrackConfiguration_, f, this),
    audioTrack_ (x.audioTrack_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    audioFormatId_ (x.audioFormatId_, f, this),
    audioFormatName_ (x.audioFormatName_, f, this),
    audioFormatDefinition_ (x.audioFormatDefinition_, f, this)
  {
  }

  audioFormatType::
  audioFormatType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    audioEncoding_ (f, this),
    audioTrackConfiguration_ (f, this),
    audioTrack_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    audioFormatId_ (f, this),
    audioFormatName_ (f, this),
    audioFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void audioFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // audioEncoding
      //
      if (n.name () == "audioEncoding" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< audioEncoding_type > r (
          audioEncoding_traits::create (i, f, this));

        this->audioEncoding_.push_back (r);
        continue;
      }

      // audioTrackConfiguration
      //
      if (n.name () == "audioTrackConfiguration" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< audioTrackConfiguration_type > r (
          audioTrackConfiguration_traits::create (i, f, this));

        if (!this->audioTrackConfiguration_)
        {
          this->audioTrackConfiguration_.set (r);
          continue;
        }
      }

      // audioTrack
      //
      if (n.name () == "audioTrack" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< audioTrack_type > r (
          audioTrack_traits::create (i, f, this));

        this->audioTrack_.push_back (r);
        continue;
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "audioFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< audioFormatId_type > r (
          audioFormatId_traits::create (i, f, this));

        this->audioFormatId_.set (r);
        continue;
      }

      if (n.name () == "audioFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< audioFormatName_type > r (
          audioFormatName_traits::create (i, f, this));

        this->audioFormatName_.set (r);
        continue;
      }

      if (n.name () == "audioFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< audioFormatDefinition_type > r (
          audioFormatDefinition_traits::create (i, f, this));

        this->audioFormatDefinition_.set (r);
        continue;
      }
    }
  }

  audioFormatType* audioFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class audioFormatType (*this, f, c);
  }

  audioFormatType::
  ~audioFormatType ()
  {
  }

  // dataFormatType
  //

  dataFormatType::
  dataFormatType ()
  : ::xml_schema::type (),
    captioningFormat_ (::xml_schema::flags (), this),
    ancillaryDataFormat_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    dataFormatId_ (::xml_schema::flags (), this),
    dataFormatName_ (::xml_schema::flags (), this),
    dataFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  dataFormatType::
  dataFormatType (const dataFormatType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    captioningFormat_ (x.captioningFormat_, f, this),
    ancillaryDataFormat_ (x.ancillaryDataFormat_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    dataFormatId_ (x.dataFormatId_, f, this),
    dataFormatName_ (x.dataFormatName_, f, this),
    dataFormatDefinition_ (x.dataFormatDefinition_, f, this)
  {
  }

  dataFormatType::
  dataFormatType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    captioningFormat_ (f, this),
    ancillaryDataFormat_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    dataFormatId_ (f, this),
    dataFormatName_ (f, this),
    dataFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void dataFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // captioningFormat
      //
      if (n.name () == "captioningFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< captioningFormat_type > r (
          captioningFormat_traits::create (i, f, this));

        this->captioningFormat_.push_back (r);
        continue;
      }

      // ancillaryDataFormat
      //
      if (n.name () == "ancillaryDataFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< ancillaryDataFormat_type > r (
          ancillaryDataFormat_traits::create (i, f, this));

        this->ancillaryDataFormat_.push_back (r);
        continue;
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dataFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataFormatId_type > r (
          dataFormatId_traits::create (i, f, this));

        this->dataFormatId_.set (r);
        continue;
      }

      if (n.name () == "dataFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataFormatName_type > r (
          dataFormatName_traits::create (i, f, this));

        this->dataFormatName_.set (r);
        continue;
      }

      if (n.name () == "dataFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataFormatDefinition_type > r (
          dataFormatDefinition_traits::create (i, f, this));

        this->dataFormatDefinition_.set (r);
        continue;
      }
    }
  }

  dataFormatType* dataFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dataFormatType (*this, f, c);
  }

  dataFormatType::
  ~dataFormatType ()
  {
  }

  // documentFormatType
  //

  documentFormatType::
  documentFormatType ()
  : ::xml_schema::type (),
    wordCount_ (::xml_schema::flags (), this),
    regionDelimX_ (::xml_schema::flags (), this),
    regionDelimY_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    height_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    documentFormatId_ (::xml_schema::flags (), this),
    documentFormatName_ (::xml_schema::flags (), this),
    documentFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  documentFormatType::
  documentFormatType (const documentFormatType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    wordCount_ (x.wordCount_, f, this),
    regionDelimX_ (x.regionDelimX_, f, this),
    regionDelimY_ (x.regionDelimY_, f, this),
    width_ (x.width_, f, this),
    height_ (x.height_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    documentFormatId_ (x.documentFormatId_, f, this),
    documentFormatName_ (x.documentFormatName_, f, this),
    documentFormatDefinition_ (x.documentFormatDefinition_, f, this)
  {
  }

  documentFormatType::
  documentFormatType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    wordCount_ (f, this),
    regionDelimX_ (f, this),
    regionDelimY_ (f, this),
    width_ (f, this),
    height_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    documentFormatId_ (f, this),
    documentFormatName_ (f, this),
    documentFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void documentFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // wordCount
      //
      if (n.name () == "wordCount" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->wordCount_)
        {
          this->wordCount_.set (wordCount_traits::create (i, f, this));
          continue;
        }
      }

      // regionDelimX
      //
      if (n.name () == "regionDelimX" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->regionDelimX_)
        {
          this->regionDelimX_.set (regionDelimX_traits::create (i, f, this));
          continue;
        }
      }

      // regionDelimY
      //
      if (n.name () == "regionDelimY" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->regionDelimY_)
        {
          this->regionDelimY_.set (regionDelimY_traits::create (i, f, this));
          continue;
        }
      }

      // width
      //
      if (n.name () == "width" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< width_type > r (
          width_traits::create (i, f, this));

        if (!this->width_)
        {
          this->width_.set (r);
          continue;
        }
      }

      // height
      //
      if (n.name () == "height" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< height_type > r (
          height_traits::create (i, f, this));

        if (!this->height_)
        {
          this->height_.set (r);
          continue;
        }
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "documentFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentFormatId_type > r (
          documentFormatId_traits::create (i, f, this));

        this->documentFormatId_.set (r);
        continue;
      }

      if (n.name () == "documentFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentFormatName_type > r (
          documentFormatName_traits::create (i, f, this));

        this->documentFormatName_.set (r);
        continue;
      }

      if (n.name () == "documentFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentFormatDefinition_type > r (
          documentFormatDefinition_traits::create (i, f, this));

        this->documentFormatDefinition_.set (r);
        continue;
      }
    }
  }

  documentFormatType* documentFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class documentFormatType (*this, f, c);
  }

  documentFormatType::
  ~documentFormatType ()
  {
  }

  // timeType
  //

  timeType::
  timeType ()
  : ::xml_schema::type (),
    timecode_ (::xml_schema::flags (), this),
    normalPlayTime_ (::xml_schema::flags (), this),
    editUnitNumber_ (::xml_schema::flags (), this),
    time_ (::xml_schema::flags (), this)
  {
  }

  timeType::
  timeType (const timeType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    timecode_ (x.timecode_, f, this),
    normalPlayTime_ (x.normalPlayTime_, f, this),
    editUnitNumber_ (x.editUnitNumber_, f, this),
    time_ (x.time_, f, this)
  {
  }

  timeType::
  timeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    timecode_ (f, this),
    normalPlayTime_ (f, this),
    editUnitNumber_ (f, this),
    time_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void timeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timecode
      //
      if (n.name () == "timecode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< timecode_type > r (
          timecode_traits::create (i, f, this));

        if (!this->timecode_)
        {
          this->timecode_.set (r);
          continue;
        }
      }

      // normalPlayTime
      //
      if (n.name () == "normalPlayTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< normalPlayTime_type > r (
          normalPlayTime_traits::create (i, f, this));

        if (!this->normalPlayTime_)
        {
          this->normalPlayTime_.set (r);
          continue;
        }
      }

      // editUnitNumber
      //
      if (n.name () == "editUnitNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< editUnitNumber_type > r (
          editUnitNumber_traits::create (i, f, this));

        if (!this->editUnitNumber_)
        {
          this->editUnitNumber_.set (r);
          continue;
        }
      }

      // time
      //
      if (n.name () == "time" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< time_type > r (
          time_traits::create (i, f, this));

        if (!this->time_)
        {
          this->time_.set (r);
          continue;
        }
      }

      break;
    }
  }

  timeType* timeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class timeType (*this, f, c);
  }

  timeType::
  ~timeType ()
  {
  }

  // durationType
  //

  durationType::
  durationType ()
  : ::xml_schema::type (),
    timecode_ (::xml_schema::flags (), this),
    normalPlayTime_ (::xml_schema::flags (), this),
    editUnitNumber_ (::xml_schema::flags (), this),
    time_ (::xml_schema::flags (), this)
  {
  }

  durationType::
  durationType (const durationType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    timecode_ (x.timecode_, f, this),
    normalPlayTime_ (x.normalPlayTime_, f, this),
    editUnitNumber_ (x.editUnitNumber_, f, this),
    time_ (x.time_, f, this)
  {
  }

  durationType::
  durationType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    timecode_ (f, this),
    normalPlayTime_ (f, this),
    editUnitNumber_ (f, this),
    time_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void durationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timecode
      //
      if (n.name () == "timecode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< timecode_type > r (
          timecode_traits::create (i, f, this));

        if (!this->timecode_)
        {
          this->timecode_.set (r);
          continue;
        }
      }

      // normalPlayTime
      //
      if (n.name () == "normalPlayTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< normalPlayTime_type > r (
          normalPlayTime_traits::create (i, f, this));

        if (!this->normalPlayTime_)
        {
          this->normalPlayTime_.set (r);
          continue;
        }
      }

      // editUnitNumber
      //
      if (n.name () == "editUnitNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< editUnitNumber_type > r (
          editUnitNumber_traits::create (i, f, this));

        if (!this->editUnitNumber_)
        {
          this->editUnitNumber_.set (r);
          continue;
        }
      }

      // time
      //
      if (n.name () == "time" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< time_type > r (
          time_traits::create (i, f, this));

        if (!this->time_)
        {
          this->time_.set (r);
          continue;
        }
      }

      break;
    }
  }

  durationType* durationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class durationType (*this, f, c);
  }

  durationType::
  ~durationType ()
  {
  }

  // String
  //

  String::
  String ()
  : ::xml_schema::string (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  String::
  String (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  String::
  String (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  String::
  String (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  String::
  String (const String& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this)
  {
  }

  String::
  String (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void String::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }
    }
  }

  String* String::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class String (*this, f, c);
  }

  String::
  ~String ()
  {
  }

  // Boolean
  //

  Boolean::
  Boolean (const ::xml_schema::boolean& _xsd_boolean_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (_xsd_boolean_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  Boolean::
  Boolean (const Boolean& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  Boolean::
  Boolean (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Boolean::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  Boolean* Boolean::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Boolean (*this, f, c);
  }

  Boolean::
  ~Boolean ()
  {
  }

  // Float
  //

  Float::
  Float (const ::xml_schema::double_& _xsd_double__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  Float::
  Float (const Float& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  Float::
  Float (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Float::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  Float* Float::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Float (*this, f, c);
  }

  Float::
  ~Float ()
  {
  }

  // Int8
  //

  Int8::
  Int8 (const ::xml_schema::byte& _xsd_byte_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type > (_xsd_byte_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  Int8::
  Int8 (const Int8& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  Int8::
  Int8 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Int8::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  Int8* Int8::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int8 (*this, f, c);
  }

  Int8::
  ~Int8 ()
  {
  }

  // Int16
  //

  Int16::
  Int16 (const ::xml_schema::short_& _xsd_short__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type > (_xsd_short__base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  Int16::
  Int16 (const Int16& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  Int16::
  Int16 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Int16::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  Int16* Int16::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int16 (*this, f, c);
  }

  Int16::
  ~Int16 ()
  {
  }

  // Int32
  //

  Int32::
  Int32 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  Int32::
  Int32 (const Int32& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  Int32::
  Int32 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Int32::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  Int32* Int32::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int32 (*this, f, c);
  }

  Int32::
  ~Int32 ()
  {
  }

  // Int64
  //

  Int64::
  Int64 (const ::xml_schema::long_& _xsd_long__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (_xsd_long__base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  Int64::
  Int64 (const Int64& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  Int64::
  Int64 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Int64::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  Int64* Int64::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int64 (*this, f, c);
  }

  Int64::
  ~Int64 ()
  {
  }

  // UInt8
  //

  UInt8::
  UInt8 (const ::xml_schema::unsigned_byte& _xsd_unsigned_byte_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (_xsd_unsigned_byte_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  UInt8::
  UInt8 (const UInt8& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  UInt8::
  UInt8 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void UInt8::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  UInt8* UInt8::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UInt8 (*this, f, c);
  }

  UInt8::
  ~UInt8 ()
  {
  }

  // UInt16
  //

  UInt16::
  UInt16 (const ::xml_schema::unsigned_short& _xsd_unsigned_short_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (_xsd_unsigned_short_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  UInt16::
  UInt16 (const UInt16& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  UInt16::
  UInt16 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void UInt16::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  UInt16* UInt16::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UInt16 (*this, f, c);
  }

  UInt16::
  ~UInt16 ()
  {
  }

  // UInt32
  //

  UInt32::
  UInt32 (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  UInt32::
  UInt32 (const UInt32& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  UInt32::
  UInt32 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void UInt32::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  UInt32* UInt32::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UInt32 (*this, f, c);
  }

  UInt32::
  ~UInt32 ()
  {
  }

  // UInt64
  //

  UInt64::
  UInt64 (const ::xml_schema::unsigned_long& _xsd_unsigned_long_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type > (_xsd_unsigned_long_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  UInt64::
  UInt64 (const UInt64& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  UInt64::
  UInt64 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void UInt64::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  UInt64* UInt64::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UInt64 (*this, f, c);
  }

  UInt64::
  ~UInt64 ()
  {
  }

  // technicalAttributeRationalType
  //

  technicalAttributeRationalType::
  technicalAttributeRationalType (const ::xml_schema::long_& _xsd_long__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (_xsd_long__base),
    factorNumerator_ (factorNumerator_default_value (), ::xml_schema::flags (), this),
    factorDenominator_ (factorDenominator_default_value (), ::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  technicalAttributeRationalType::
  technicalAttributeRationalType (const technicalAttributeRationalType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c),
    factorNumerator_ (x.factorNumerator_, f, this),
    factorDenominator_ (x.factorDenominator_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  technicalAttributeRationalType::
  technicalAttributeRationalType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    factorNumerator_ (f, this),
    factorDenominator_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void technicalAttributeRationalType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "factorNumerator" && n.namespace_ ().empty ())
      {
        this->factorNumerator_.set (factorNumerator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "factorDenominator" && n.namespace_ ().empty ())
      {
        this->factorDenominator_.set (factorDenominator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }

    if (!factorNumerator_.present ())
    {
      this->factorNumerator_.set (factorNumerator_default_value ());
    }

    if (!factorDenominator_.present ())
    {
      this->factorDenominator_.set (factorDenominator_default_value ());
    }
  }

  technicalAttributeRationalType* technicalAttributeRationalType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class technicalAttributeRationalType (*this, f, c);
  }

  technicalAttributeRationalType::
  ~technicalAttributeRationalType ()
  {
  }

  // technicalAttributeUriType
  //

  technicalAttributeUriType::
  technicalAttributeUriType (const ::xml_schema::uri& _xsd_uri_base)
  : ::xml_schema::uri (_xsd_uri_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  technicalAttributeUriType::
  technicalAttributeUriType (const technicalAttributeUriType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::uri (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  technicalAttributeUriType::
  technicalAttributeUriType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::uri (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void technicalAttributeUriType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  technicalAttributeUriType* technicalAttributeUriType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class technicalAttributeUriType (*this, f, c);
  }

  technicalAttributeUriType::
  ~technicalAttributeUriType ()
  {
  }

  // hasTrackPart
  //

  hasTrackPart::
  hasTrackPart (const trackPartTitle_type& trackPartTitle)
  : ::ebuCore_2011::relationType (),
    trackPartTitle_ (trackPartTitle, ::xml_schema::flags (), this),
    destinationStart_ (::xml_schema::flags (), this),
    destinationEnd_ (::xml_schema::flags (), this),
    sourceStart_ (::xml_schema::flags (), this),
    sourceEnd_ (::xml_schema::flags (), this)
  {
  }

  hasTrackPart::
  hasTrackPart (::std::auto_ptr< trackPartTitle_type >& trackPartTitle)
  : ::ebuCore_2011::relationType (),
    trackPartTitle_ (trackPartTitle, ::xml_schema::flags (), this),
    destinationStart_ (::xml_schema::flags (), this),
    destinationEnd_ (::xml_schema::flags (), this),
    sourceStart_ (::xml_schema::flags (), this),
    sourceEnd_ (::xml_schema::flags (), this)
  {
  }

  hasTrackPart::
  hasTrackPart (const hasTrackPart& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::ebuCore_2011::relationType (x, f, c),
    trackPartTitle_ (x.trackPartTitle_, f, this),
    destinationStart_ (x.destinationStart_, f, this),
    destinationEnd_ (x.destinationEnd_, f, this),
    sourceStart_ (x.sourceStart_, f, this),
    sourceEnd_ (x.sourceEnd_, f, this)
  {
  }

  hasTrackPart::
  hasTrackPart (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::ebuCore_2011::relationType (e, f | ::xml_schema::flags::base, c),
    trackPartTitle_ (f, this),
    destinationStart_ (f, this),
    destinationEnd_ (f, this),
    sourceStart_ (f, this),
    sourceEnd_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void hasTrackPart::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::ebuCore_2011::relationType::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // trackPartTitle
      //
      if (n.name () == "trackPartTitle" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< trackPartTitle_type > r (
          trackPartTitle_traits::create (i, f, this));

        if (!trackPartTitle_.present ())
        {
          this->trackPartTitle_.set (r);
          continue;
        }
      }

      // destinationStart
      //
      if (n.name () == "destinationStart" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< destinationStart_type > r (
          destinationStart_traits::create (i, f, this));

        if (!this->destinationStart_)
        {
          this->destinationStart_.set (r);
          continue;
        }
      }

      // destinationEnd
      //
      if (n.name () == "destinationEnd" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< destinationEnd_type > r (
          destinationEnd_traits::create (i, f, this));

        if (!this->destinationEnd_)
        {
          this->destinationEnd_.set (r);
          continue;
        }
      }

      // sourceStart
      //
      if (n.name () == "sourceStart" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< sourceStart_type > r (
          sourceStart_traits::create (i, f, this));

        if (!this->sourceStart_)
        {
          this->sourceStart_.set (r);
          continue;
        }
      }

      // sourceEnd
      //
      if (n.name () == "sourceEnd" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< sourceEnd_type > r (
          sourceEnd_traits::create (i, f, this));

        if (!this->sourceEnd_)
        {
          this->sourceEnd_.set (r);
          continue;
        }
      }

      break;
    }

    if (!trackPartTitle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "trackPartTitle",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }
  }

  hasTrackPart* hasTrackPart::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hasTrackPart (*this, f, c);
  }

  hasTrackPart::
  ~hasTrackPart ()
  {
  }

  // part
  //

  part::
  part ()
  : ::ebuCore_2011::coreMetadataType (),
    partId_ (::xml_schema::flags (), this),
    partName_ (::xml_schema::flags (), this)
  {
  }

  part::
  part (const part& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::ebuCore_2011::coreMetadataType (x, f, c),
    partId_ (x.partId_, f, this),
    partName_ (x.partName_, f, this)
  {
  }

  part::
  part (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::ebuCore_2011::coreMetadataType (e, f | ::xml_schema::flags::base, c),
    partId_ (f, this),
    partName_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void part::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::ebuCore_2011::coreMetadataType::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "partId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< partId_type > r (
          partId_traits::create (i, f, this));

        this->partId_.set (r);
        continue;
      }

      if (n.name () == "partName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< partName_type > r (
          partName_traits::create (i, f, this));

        this->partName_.set (r);
        continue;
      }
    }
  }

  part* part::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part (*this, f, c);
  }

  part::
  ~part ()
  {
  }

  // genre
  //

  genre::
  genre ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  genre::
  genre (const genre& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  genre::
  genre (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void genre::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  genre* genre::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class genre (*this, f, c);
  }

  genre::
  ~genre ()
  {
  }

  // objectType
  //

  objectType::
  objectType ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  objectType::
  objectType (const objectType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  objectType::
  objectType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void objectType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  objectType* objectType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class objectType (*this, f, c);
  }

  objectType::
  ~objectType ()
  {
  }

  // targetAudience
  //

  targetAudience::
  targetAudience ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  targetAudience::
  targetAudience (const targetAudience& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  targetAudience::
  targetAudience (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void targetAudience::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  targetAudience* targetAudience::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class targetAudience (*this, f, c);
  }

  targetAudience::
  ~targetAudience ()
  {
  }

  // temporal
  //

  temporal::
  temporal ()
  : ::xml_schema::type (),
    PeriodOfTime_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this),
    periodId_ (::xml_schema::flags (), this)
  {
  }

  temporal::
  temporal (const temporal& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    PeriodOfTime_ (x.PeriodOfTime_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    note_ (x.note_, f, this),
    periodId_ (x.periodId_, f, this)
  {
  }

  temporal::
  temporal (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    PeriodOfTime_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    note_ (f, this),
    periodId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void temporal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PeriodOfTime
      //
      if (n.name () == "PeriodOfTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< PeriodOfTime_type > r (
          PeriodOfTime_traits::create (i, f, this));

        if (!this->PeriodOfTime_)
        {
          this->PeriodOfTime_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }

      if (n.name () == "periodId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< periodId_type > r (
          periodId_traits::create (i, f, this));

        this->periodId_.set (r);
        continue;
      }
    }
  }

  temporal* temporal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class temporal (*this, f, c);
  }

  temporal::
  ~temporal ()
  {
  }

  // spatial
  //

  spatial::
  spatial ()
  : ::xml_schema::type (),
    location_ (::xml_schema::flags (), this)
  {
  }

  spatial::
  spatial (const spatial& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    location_ (x.location_, f, this)
  {
  }

  spatial::
  spatial (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    location_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void spatial::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // location
      //
      if (n.name () == "location" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< location_type > r (
          location_traits::create (i, f, this));

        this->location_.push_back (r);
        continue;
      }

      break;
    }
  }

  spatial* spatial::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class spatial (*this, f, c);
  }

  spatial::
  ~spatial ()
  {
  }

  // medium
  //

  medium::
  medium ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  medium::
  medium (const medium& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  medium::
  medium (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void medium::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  medium* medium::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class medium (*this, f, c);
  }

  medium::
  ~medium ()
  {
  }

  // mimeType
  //

  mimeType::
  mimeType ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  mimeType::
  mimeType (const mimeType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  mimeType::
  mimeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void mimeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  mimeType* mimeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mimeType (*this, f, c);
  }

  mimeType::
  ~mimeType ()
  {
  }

  // containerFormat
  //

  containerFormat::
  containerFormat ()
  : ::xml_schema::type (),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  containerFormat::
  containerFormat (const containerFormat& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this)
  {
  }

  containerFormat::
  containerFormat (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void containerFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }
    }
  }

  containerFormat* containerFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class containerFormat (*this, f, c);
  }

  containerFormat::
  ~containerFormat ()
  {
  }

  // signingFormat
  //

  signingFormat::
  signingFormat ()
  : ::xml_schema::type (),
    trackId_ (::xml_schema::flags (), this),
    trackName_ (::xml_schema::flags (), this),
    language_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    signingSourceUri_ (::xml_schema::flags (), this),
    signingFormatId_ (::xml_schema::flags (), this),
    signingFormatName_ (::xml_schema::flags (), this),
    signingFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  signingFormat::
  signingFormat (const signingFormat& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    trackId_ (x.trackId_, f, this),
    trackName_ (x.trackName_, f, this),
    language_ (x.language_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    signingSourceUri_ (x.signingSourceUri_, f, this),
    signingFormatId_ (x.signingFormatId_, f, this),
    signingFormatName_ (x.signingFormatName_, f, this),
    signingFormatDefinition_ (x.signingFormatDefinition_, f, this)
  {
  }

  signingFormat::
  signingFormat (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    trackId_ (f, this),
    trackName_ (f, this),
    language_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    signingSourceUri_ (f, this),
    signingFormatId_ (f, this),
    signingFormatName_ (f, this),
    signingFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void signingFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "trackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackId_type > r (
          trackId_traits::create (i, f, this));

        this->trackId_.set (r);
        continue;
      }

      if (n.name () == "trackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackName_type > r (
          trackName_traits::create (i, f, this));

        this->trackName_.set (r);
        continue;
      }

      if (n.name () == "language" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< language_type > r (
          language_traits::create (i, f, this));

        this->language_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "signingSourceUri" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signingSourceUri_type > r (
          signingSourceUri_traits::create (i, f, this));

        this->signingSourceUri_.set (r);
        continue;
      }

      if (n.name () == "signingFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signingFormatId_type > r (
          signingFormatId_traits::create (i, f, this));

        this->signingFormatId_.set (r);
        continue;
      }

      if (n.name () == "signingFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signingFormatName_type > r (
          signingFormatName_traits::create (i, f, this));

        this->signingFormatName_.set (r);
        continue;
      }

      if (n.name () == "signingFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signingFormatDefinition_type > r (
          signingFormatDefinition_traits::create (i, f, this));

        this->signingFormatDefinition_.set (r);
        continue;
      }
    }
  }

  signingFormat* signingFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class signingFormat (*this, f, c);
  }

  signingFormat::
  ~signingFormat ()
  {
  }

  // locator
  //

  locator::
  locator ()
  : ::xml_schema::string (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  locator::
  locator (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  locator::
  locator (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  locator::
  locator (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  locator::
  locator (const locator& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  locator::
  locator (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void locator::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  locator* locator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class locator (*this, f, c);
  }

  locator::
  ~locator ()
  {
  }

  // dateCreated
  //

  dateCreated::
  dateCreated ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this)
  {
  }

  dateCreated::
  dateCreated (const dateCreated& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    period_ (x.period_, f, this)
  {
  }

  dateCreated::
  dateCreated (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    period_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void dateCreated::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.set (r);
        continue;
      }
    }
  }

  dateCreated* dateCreated::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dateCreated (*this, f, c);
  }

  dateCreated::
  ~dateCreated ()
  {
  }

  // dateModified
  //

  dateModified::
  dateModified ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this)
  {
  }

  dateModified::
  dateModified (const dateModified& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    period_ (x.period_, f, this)
  {
  }

  dateModified::
  dateModified (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    period_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void dateModified::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.set (r);
        continue;
      }
    }
  }

  dateModified* dateModified::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dateModified (*this, f, c);
  }

  dateModified::
  ~dateModified ()
  {
  }

  // created
  //

  created::
  created ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this)
  {
  }

  created::
  created (const created& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    period_ (x.period_, f, this)
  {
  }

  created::
  created (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    period_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void created::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.set (r);
        continue;
      }
    }
  }

  created* created::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class created (*this, f, c);
  }

  created::
  ~created ()
  {
  }

  // issued
  //

  issued::
  issued ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this)
  {
  }

  issued::
  issued (const issued& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    period_ (x.period_, f, this)
  {
  }

  issued::
  issued (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    period_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void issued::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.set (r);
        continue;
      }
    }
  }

  issued* issued::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class issued (*this, f, c);
  }

  issued::
  ~issued ()
  {
  }

  // modified
  //

  modified::
  modified ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this)
  {
  }

  modified::
  modified (const modified& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    period_ (x.period_, f, this)
  {
  }

  modified::
  modified (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    period_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void modified::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.set (r);
        continue;
      }
    }
  }

  modified* modified::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class modified (*this, f, c);
  }

  modified::
  ~modified ()
  {
  }

  // digitised
  //

  digitised::
  digitised ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this)
  {
  }

  digitised::
  digitised (const digitised& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    period_ (x.period_, f, this)
  {
  }

  digitised::
  digitised (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    period_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void digitised::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.set (r);
        continue;
      }
    }
  }

  digitised* digitised::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class digitised (*this, f, c);
  }

  digitised::
  ~digitised ()
  {
  }

  // alternative
  //

  alternative::
  alternative ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  alternative::
  alternative (const alternative& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    period_ (x.period_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  alternative::
  alternative (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    period_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void alternative::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  alternative* alternative::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class alternative (*this, f, c);
  }

  alternative::
  ~alternative ()
  {
  }

  // firstPublicationChannel
  //

  firstPublicationChannel::
  firstPublicationChannel ()
  : ::xml_schema::string (),
    formatIdRef_ (::xml_schema::flags (), this)
  {
  }

  firstPublicationChannel::
  firstPublicationChannel (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatIdRef_ (::xml_schema::flags (), this)
  {
  }

  firstPublicationChannel::
  firstPublicationChannel (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatIdRef_ (::xml_schema::flags (), this)
  {
  }

  firstPublicationChannel::
  firstPublicationChannel (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatIdRef_ (::xml_schema::flags (), this)
  {
  }

  firstPublicationChannel::
  firstPublicationChannel (const firstPublicationChannel& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    formatIdRef_ (x.formatIdRef_, f, this)
  {
  }

  firstPublicationChannel::
  firstPublicationChannel (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    formatIdRef_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void firstPublicationChannel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatIdRef" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatIdRef_type > r (
          formatIdRef_traits::create (i, f, this));

        this->formatIdRef_.set (r);
        continue;
      }
    }
  }

  firstPublicationChannel* firstPublicationChannel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class firstPublicationChannel (*this, f, c);
  }

  firstPublicationChannel::
  ~firstPublicationChannel ()
  {
  }

  // repeatChannel
  //

  repeatChannel::
  repeatChannel ()
  : ::xml_schema::string (),
    formatIdRef_ (::xml_schema::flags (), this)
  {
  }

  repeatChannel::
  repeatChannel (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatIdRef_ (::xml_schema::flags (), this)
  {
  }

  repeatChannel::
  repeatChannel (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatIdRef_ (::xml_schema::flags (), this)
  {
  }

  repeatChannel::
  repeatChannel (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatIdRef_ (::xml_schema::flags (), this)
  {
  }

  repeatChannel::
  repeatChannel (const repeatChannel& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    formatIdRef_ (x.formatIdRef_, f, this)
  {
  }

  repeatChannel::
  repeatChannel (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    formatIdRef_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void repeatChannel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatIdRef" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatIdRef_type > r (
          formatIdRef_traits::create (i, f, this));

        this->formatIdRef_.set (r);
        continue;
      }
    }
  }

  repeatChannel* repeatChannel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class repeatChannel (*this, f, c);
  }

  repeatChannel::
  ~repeatChannel ()
  {
  }

  // role
  //

  role::
  role ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  role::
  role (const role& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  role::
  role (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void role::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  role* role::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class role (*this, f, c);
  }

  role::
  ~role ()
  {
  }

  // organisationDepartment
  //

  organisationDepartment::
  organisationDepartment ()
  : ::dc::elementType (),
    departmentId_ (::xml_schema::flags (), this)
  {
  }

  organisationDepartment::
  organisationDepartment (const char* _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    departmentId_ (::xml_schema::flags (), this)
  {
  }

  organisationDepartment::
  organisationDepartment (const ::std::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    departmentId_ (::xml_schema::flags (), this)
  {
  }

  organisationDepartment::
  organisationDepartment (const ::xml_schema::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    departmentId_ (::xml_schema::flags (), this)
  {
  }

  organisationDepartment::
  organisationDepartment (const organisationDepartment& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::dc::elementType (x, f, c),
    departmentId_ (x.departmentId_, f, this)
  {
  }

  organisationDepartment::
  organisationDepartment (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::dc::elementType (e, f | ::xml_schema::flags::base, c),
    departmentId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void organisationDepartment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dc::elementType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "departmentId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< departmentId_type > r (
          departmentId_traits::create (i, f, this));

        this->departmentId_.set (r);
        continue;
      }
    }
  }

  organisationDepartment* organisationDepartment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class organisationDepartment (*this, f, c);
  }

  organisationDepartment::
  ~organisationDepartment ()
  {
  }

  // country
  //

  country::
  country ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  country::
  country (const country& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  country::
  country (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void country::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  country* country::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class country (*this, f, c);
  }

  country::
  ~country ()
  {
  }

  // orientation
  //

  orientation::
  orientation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_orientation_convert ();
  }

  orientation::
  orientation (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_orientation_convert ();
  }

  orientation::
  orientation (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_orientation_convert ();
  }

  orientation* orientation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class orientation (*this, f, c);
  }

  orientation::value orientation::
  _xsd_orientation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_orientation_literals_);
    const value* i (::std::lower_bound (
                      _xsd_orientation_indexes_,
                      _xsd_orientation_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_orientation_indexes_ + 2 || _xsd_orientation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const orientation::
  _xsd_orientation_literals_[2] =
  {
    "landscape",
    "portrait"
  };

  const orientation::value orientation::
  _xsd_orientation_indexes_[2] =
  {
    ::ebuCore_2011::orientation::landscape,
    ::ebuCore_2011::orientation::portrait
  };

  // imageEncoding
  //

  imageEncoding::
  imageEncoding ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  imageEncoding::
  imageEncoding (const imageEncoding& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  imageEncoding::
  imageEncoding (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void imageEncoding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  imageEncoding* imageEncoding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class imageEncoding (*this, f, c);
  }

  imageEncoding::
  ~imageEncoding ()
  {
  }

  // aspectRatio
  //

  aspectRatio::
  aspectRatio ()
  : ::xml_schema::string (),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  aspectRatio::
  aspectRatio (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  aspectRatio::
  aspectRatio (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  aspectRatio::
  aspectRatio (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  aspectRatio::
  aspectRatio (const aspectRatio& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    note_ (x.note_, f, this)
  {
  }

  aspectRatio::
  aspectRatio (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void aspectRatio::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  aspectRatio* aspectRatio::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class aspectRatio (*this, f, c);
  }

  aspectRatio::
  ~aspectRatio ()
  {
  }

  // videoEncoding
  //

  videoEncoding::
  videoEncoding ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  videoEncoding::
  videoEncoding (const videoEncoding& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  videoEncoding::
  videoEncoding (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void videoEncoding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  videoEncoding* videoEncoding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class videoEncoding (*this, f, c);
  }

  videoEncoding::
  ~videoEncoding ()
  {
  }

  // videoTrack
  //

  videoTrack::
  videoTrack ()
  : ::xml_schema::type (),
    trackId_ (::xml_schema::flags (), this),
    trackName_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  videoTrack::
  videoTrack (const videoTrack& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    trackId_ (x.trackId_, f, this),
    trackName_ (x.trackName_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  videoTrack::
  videoTrack (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    trackId_ (f, this),
    trackName_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void videoTrack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "trackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackId_type > r (
          trackId_traits::create (i, f, this));

        this->trackId_.set (r);
        continue;
      }

      if (n.name () == "trackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackName_type > r (
          trackName_traits::create (i, f, this));

        this->trackName_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  videoTrack* videoTrack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class videoTrack (*this, f, c);
  }

  videoTrack::
  ~videoTrack ()
  {
  }

  // audioEncoding
  //

  audioEncoding::
  audioEncoding ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  audioEncoding::
  audioEncoding (const audioEncoding& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  audioEncoding::
  audioEncoding (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void audioEncoding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  audioEncoding* audioEncoding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class audioEncoding (*this, f, c);
  }

  audioEncoding::
  ~audioEncoding ()
  {
  }

  // audioTrackConfiguration
  //

  audioTrackConfiguration::
  audioTrackConfiguration ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  audioTrackConfiguration::
  audioTrackConfiguration (const audioTrackConfiguration& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  audioTrackConfiguration::
  audioTrackConfiguration (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void audioTrackConfiguration::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  audioTrackConfiguration* audioTrackConfiguration::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class audioTrackConfiguration (*this, f, c);
  }

  audioTrackConfiguration::
  ~audioTrackConfiguration ()
  {
  }

  // audioTrack
  //

  audioTrack::
  audioTrack ()
  : ::xml_schema::type (),
    trackLanguage_ (::xml_schema::flags (), this),
    trackId_ (::xml_schema::flags (), this),
    trackName_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this)
  {
  }

  audioTrack::
  audioTrack (const audioTrack& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    trackLanguage_ (x.trackLanguage_, f, this),
    trackId_ (x.trackId_, f, this),
    trackName_ (x.trackName_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this)
  {
  }

  audioTrack::
  audioTrack (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    trackLanguage_ (f, this),
    trackId_ (f, this),
    trackName_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void audioTrack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "trackLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackLanguage_type > r (
          trackLanguage_traits::create (i, f, this));

        this->trackLanguage_.set (r);
        continue;
      }

      if (n.name () == "trackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackId_type > r (
          trackId_traits::create (i, f, this));

        this->trackId_.set (r);
        continue;
      }

      if (n.name () == "trackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackName_type > r (
          trackName_traits::create (i, f, this));

        this->trackName_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }
    }
  }

  audioTrack* audioTrack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class audioTrack (*this, f, c);
  }

  audioTrack::
  ~audioTrack ()
  {
  }

  // captioningFormat
  //

  captioningFormat::
  captioningFormat ()
  : ::xml_schema::type (),
    trackId_ (::xml_schema::flags (), this),
    trackName_ (::xml_schema::flags (), this),
    language_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    captioningSourceUri_ (::xml_schema::flags (), this),
    captioningFormatId_ (::xml_schema::flags (), this),
    captioningFormatName_ (::xml_schema::flags (), this)
  {
  }

  captioningFormat::
  captioningFormat (const captioningFormat& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    trackId_ (x.trackId_, f, this),
    trackName_ (x.trackName_, f, this),
    language_ (x.language_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    captioningSourceUri_ (x.captioningSourceUri_, f, this),
    captioningFormatId_ (x.captioningFormatId_, f, this),
    captioningFormatName_ (x.captioningFormatName_, f, this)
  {
  }

  captioningFormat::
  captioningFormat (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    trackId_ (f, this),
    trackName_ (f, this),
    language_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    captioningSourceUri_ (f, this),
    captioningFormatId_ (f, this),
    captioningFormatName_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void captioningFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "trackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackId_type > r (
          trackId_traits::create (i, f, this));

        this->trackId_.set (r);
        continue;
      }

      if (n.name () == "trackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackName_type > r (
          trackName_traits::create (i, f, this));

        this->trackName_.set (r);
        continue;
      }

      if (n.name () == "language" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< language_type > r (
          language_traits::create (i, f, this));

        this->language_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "captioningSourceUri" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< captioningSourceUri_type > r (
          captioningSourceUri_traits::create (i, f, this));

        this->captioningSourceUri_.set (r);
        continue;
      }

      if (n.name () == "captioningFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< captioningFormatId_type > r (
          captioningFormatId_traits::create (i, f, this));

        this->captioningFormatId_.set (r);
        continue;
      }

      if (n.name () == "captioningFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< captioningFormatName_type > r (
          captioningFormatName_traits::create (i, f, this));

        this->captioningFormatName_.set (r);
        continue;
      }
    }
  }

  captioningFormat* captioningFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class captioningFormat (*this, f, c);
  }

  captioningFormat::
  ~captioningFormat ()
  {
  }

  // ancillaryDataFormat
  //

  ancillaryDataFormat::
  ancillaryDataFormat ()
  : ::xml_schema::type (),
    DID_ (::xml_schema::flags (), this),
    SDID_ (::xml_schema::flags (), this),
    lineNumber_ (::xml_schema::flags (), this),
    wrappingType_ (::xml_schema::flags (), this),
    ancillaryDataFormatId_ (::xml_schema::flags (), this),
    ancillaryDataFormatName_ (::xml_schema::flags (), this)
  {
  }

  ancillaryDataFormat::
  ancillaryDataFormat (const ancillaryDataFormat& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DID_ (x.DID_, f, this),
    SDID_ (x.SDID_, f, this),
    lineNumber_ (x.lineNumber_, f, this),
    wrappingType_ (x.wrappingType_, f, this),
    ancillaryDataFormatId_ (x.ancillaryDataFormatId_, f, this),
    ancillaryDataFormatName_ (x.ancillaryDataFormatName_, f, this)
  {
  }

  ancillaryDataFormat::
  ancillaryDataFormat (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DID_ (f, this),
    SDID_ (f, this),
    lineNumber_ (f, this),
    wrappingType_ (f, this),
    ancillaryDataFormatId_ (f, this),
    ancillaryDataFormatName_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ancillaryDataFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DID
      //
      if (n.name () == "DID" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->DID_)
        {
          this->DID_.set (DID_traits::create (i, f, this));
          continue;
        }
      }

      // SDID
      //
      if (n.name () == "SDID" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->SDID_)
        {
          this->SDID_.set (SDID_traits::create (i, f, this));
          continue;
        }
      }

      // lineNumber
      //
      if (n.name () == "lineNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        this->lineNumber_.push_back (lineNumber_traits::create (i, f, this));
        continue;
      }

      // wrappingType
      //
      if (n.name () == "wrappingType" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!this->wrappingType_)
        {
          this->wrappingType_.set (wrappingType_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ancillaryDataFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ancillaryDataFormatId_type > r (
          ancillaryDataFormatId_traits::create (i, f, this));

        this->ancillaryDataFormatId_.set (r);
        continue;
      }

      if (n.name () == "ancillaryDataFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ancillaryDataFormatName_type > r (
          ancillaryDataFormatName_traits::create (i, f, this));

        this->ancillaryDataFormatName_.set (r);
        continue;
      }
    }
  }

  ancillaryDataFormat* ancillaryDataFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ancillaryDataFormat (*this, f, c);
  }

  ancillaryDataFormat::
  ~ancillaryDataFormat ()
  {
  }

  // timecode
  //

  timecode::
  timecode ()
  : ::xml_schema::string ()
  {
  }

  timecode::
  timecode (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode::
  timecode (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode::
  timecode (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode::
  timecode (const timecode& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  timecode::
  timecode (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  timecode::
  timecode (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  timecode::
  timecode (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  timecode* timecode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class timecode (*this, f, c);
  }

  timecode::
  ~timecode ()
  {
  }

  // time
  //

  time::
  time ()
  : ::xml_schema::string (),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  time::
  time (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  time::
  time (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  time::
  time (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  time::
  time (const time& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this)
  {
  }

  time::
  time (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void time::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }
    }
  }

  time* time::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class time (*this, f, c);
  }

  time::
  ~time ()
  {
  }

  // timecode1
  //

  timecode1::
  timecode1 ()
  : ::xml_schema::string ()
  {
  }

  timecode1::
  timecode1 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode1::
  timecode1 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode1::
  timecode1 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode1::
  timecode1 (const timecode1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  timecode1::
  timecode1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  timecode1::
  timecode1 (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  timecode1::
  timecode1 (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  timecode1* timecode1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class timecode1 (*this, f, c);
  }

  timecode1::
  ~timecode1 ()
  {
  }

  // time1
  //

  time1::
  time1 ()
  : ::xml_schema::string (),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  time1::
  time1 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  time1::
  time1 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  time1::
  time1 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  time1::
  time1 (const time1& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this)
  {
  }

  time1::
  time1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void time1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }
    }
  }

  time1* time1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class time1 (*this, f, c);
  }

  time1::
  ~time1 ()
  {
  }

  // PeriodOfTime
  //

  PeriodOfTime::
  PeriodOfTime ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    period_ (::xml_schema::flags (), this)
  {
  }

  PeriodOfTime::
  PeriodOfTime (const PeriodOfTime& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    period_ (x.period_, f, this)
  {
  }

  PeriodOfTime::
  PeriodOfTime (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    period_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void PeriodOfTime::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< period_type > r (
          period_traits::create (i, f, this));

        this->period_.set (r);
        continue;
      }
    }
  }

  PeriodOfTime* PeriodOfTime::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PeriodOfTime (*this, f, c);
  }

  PeriodOfTime::
  ~PeriodOfTime ()
  {
  }

  // location
  //

  location::
  location ()
  : ::xml_schema::type (),
    name_ (::xml_schema::flags (), this),
    coordinates_ (::xml_schema::flags (), this),
    code_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this),
    locationId_ (::xml_schema::flags (), this)
  {
  }

  location::
  location (const location& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    coordinates_ (x.coordinates_, f, this),
    code_ (x.code_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    note_ (x.note_, f, this),
    locationId_ (x.locationId_, f, this)
  {
  }

  location::
  location (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    coordinates_ (f, this),
    code_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    note_ (f, this),
    locationId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void location::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (r);
          continue;
        }
      }

      // coordinates
      //
      if (n.name () == "coordinates" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< coordinates_type > r (
          coordinates_traits::create (i, f, this));

        if (!this->coordinates_)
        {
          this->coordinates_.set (r);
          continue;
        }
      }

      // code
      //
      if (n.name () == "code" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        ::std::auto_ptr< code_type > r (
          code_traits::create (i, f, this));

        if (!this->code_)
        {
          this->code_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }

      if (n.name () == "locationId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< locationId_type > r (
          locationId_traits::create (i, f, this));

        this->locationId_.set (r);
        continue;
      }
    }
  }

  location* location::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class location (*this, f, c);
  }

  location::
  ~location ()
  {
  }

  // coordinates
  //

  coordinates::
  coordinates (const posy_type& posy,
               const posx_type& posx)
  : ::xml_schema::type (),
    posy_ (posy, ::xml_schema::flags (), this),
    posx_ (posx, ::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this)
  {
  }

  coordinates::
  coordinates (const coordinates& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    posy_ (x.posy_, f, this),
    posx_ (x.posx_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this)
  {
  }

  coordinates::
  coordinates (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    posy_ (f, this),
    posx_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void coordinates::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // posy
      //
      if (n.name () == "posy" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!posy_.present ())
        {
          this->posy_.set (posy_traits::create (i, f, this));
          continue;
        }
      }

      // posx
      //
      if (n.name () == "posx" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
      {
        if (!posx_.present ())
        {
          this->posx_.set (posx_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!posy_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "posy",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }

    if (!posx_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "posx",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }
    }
  }

  coordinates* coordinates::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class coordinates (*this, f, c);
  }

  coordinates::
  ~coordinates ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ebuCore_2011
{
  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType > r (
      ::ebuCore_2011::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType > r (
      ::ebuCore_2011::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType > r (
      ::ebuCore_2011::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ebuCore_2011::ebuCoreMain (isrc, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ebuCore_2011::ebuCoreMain (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ebuCore_2011::ebuCoreMain (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ebuCore_2011::ebuCoreMain (isrc, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ebuCore_2011::ebuCoreMain (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ebuCore_2011::ebuCoreMain (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType > r (
      ::ebuCore_2011::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType > r (
      ::ebuCore_2011::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType > r (
      ::ebuCore_2011::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType > r (
        ::ebuCore_2011::ebuCoreMain (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ebuCoreMain" &&
        n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
    {
      ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType > r (
        ::xsd::cxx::tree::traits< ::ebuCore_2011::ebuCoreMainType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ebuCoreMain",
      "urn:ebu:metadata-schema:ebuCore_2011");
  }

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ebuCoreMain" &&
        n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
    {
      ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType > r (
        ::xsd::cxx::tree::traits< ::ebuCore_2011::ebuCoreMainType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ebuCoreMain",
      "urn:ebu:metadata-schema:ebuCore_2011");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace ebuCore_2011
{
  void
  ebuCoreMain (::std::ostream& o,
               const ::ebuCore_2011::ebuCoreMainType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2011::ebuCoreMain (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ebuCoreMain (::std::ostream& o,
               const ::ebuCore_2011::ebuCoreMainType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2011::ebuCoreMain (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ebuCoreMain (::std::ostream& o,
               const ::ebuCore_2011::ebuCoreMainType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2011::ebuCoreMain (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& t,
               const ::ebuCore_2011::ebuCoreMainType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2011::ebuCoreMain (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& t,
               const ::ebuCore_2011::ebuCoreMainType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2011::ebuCoreMain (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& t,
               const ::ebuCore_2011::ebuCoreMainType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2011::ebuCoreMain (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ebuCoreMain (::xercesc::DOMDocument& d,
               const ::ebuCore_2011::ebuCoreMainType& s,
               ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ebuCoreMain" &&
        n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2011")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ebuCoreMain",
        "urn:ebu:metadata-schema:ebuCore_2011");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  ebuCoreMain (const ::ebuCore_2011::ebuCoreMainType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "ebuCoreMain",
        "urn:ebu:metadata-schema:ebuCore_2011",
        m, f));

    ::ebuCore_2011::ebuCoreMain (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const ebuCoreMainType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // coreMetadata
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coreMetadata",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << i.coreMetadata ();
    }

    // metadataProvider
    //
    if (i.metadataProvider ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "metadataProvider",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.metadataProvider ();
    }

    // schema
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "schema",
          e));

      a << i.schema ();
    }

    // version
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << i.version ();
    }

    // dateLastModified
    //
    if (i.dateLastModified ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dateLastModified",
          e));

      a << *i.dateLastModified ();
    }

    // documentId
    //
    if (i.documentId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentId",
          e));

      a << *i.documentId ();
    }

    // lang
    //
    if (i.lang ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "lang",
          "http://www.w3.org/XML/1998/namespace",
          e));

      a << *i.lang ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const coreMetadataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // title
    //
    for (coreMetadataType::title_const_iterator
         b (i.title ().begin ()), n (i.title ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "title",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // alternativeTitle
    //
    for (coreMetadataType::alternativeTitle_const_iterator
         b (i.alternativeTitle ().begin ()), n (i.alternativeTitle ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alternativeTitle",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // creator
    //
    for (coreMetadataType::creator_const_iterator
         b (i.creator ().begin ()), n (i.creator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "creator",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // subject
    //
    for (coreMetadataType::subject_const_iterator
         b (i.subject ().begin ()), n (i.subject ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subject",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // description
    //
    for (coreMetadataType::description_const_iterator
         b (i.description ().begin ()), n (i.description ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // publisher
    //
    for (coreMetadataType::publisher_const_iterator
         b (i.publisher ().begin ()), n (i.publisher ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publisher",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // contributor
    //
    for (coreMetadataType::contributor_const_iterator
         b (i.contributor ().begin ()), n (i.contributor ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contributor",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // date
    //
    for (coreMetadataType::date_const_iterator
         b (i.date ().begin ()), n (i.date ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "date",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // type
    //
    for (coreMetadataType::type_const_iterator
         b (i.type ().begin ()), n (i.type ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // format
    //
    for (coreMetadataType::format_const_iterator
         b (i.format ().begin ()), n (i.format ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "format",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // identifier
    //
    for (coreMetadataType::identifier_const_iterator
         b (i.identifier ().begin ()), n (i.identifier ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "identifier",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // source
    //
    for (coreMetadataType::source_const_iterator
         b (i.source ().begin ()), n (i.source ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "source",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // language
    //
    for (coreMetadataType::language_const_iterator
         b (i.language ().begin ()), n (i.language ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "language",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // relation
    //
    for (coreMetadataType::relation_const_iterator
         b (i.relation ().begin ()), n (i.relation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relation",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // isVersionOf
    //
    for (coreMetadataType::isVersionOf_const_iterator
         b (i.isVersionOf ().begin ()), n (i.isVersionOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isVersionOf",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // hasVersion
    //
    for (coreMetadataType::hasVersion_const_iterator
         b (i.hasVersion ().begin ()), n (i.hasVersion ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hasVersion",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // isReplacedBy
    //
    for (coreMetadataType::isReplacedBy_const_iterator
         b (i.isReplacedBy ().begin ()), n (i.isReplacedBy ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isReplacedBy",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // replaces
    //
    for (coreMetadataType::replaces_const_iterator
         b (i.replaces ().begin ()), n (i.replaces ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "replaces",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // isRequiredBy
    //
    for (coreMetadataType::isRequiredBy_const_iterator
         b (i.isRequiredBy ().begin ()), n (i.isRequiredBy ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isRequiredBy",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // requires
    //
    for (coreMetadataType::requires_const_iterator
         b (i.requires ().begin ()), n (i.requires ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "requires",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // isPartOf
    //
    for (coreMetadataType::isPartOf_const_iterator
         b (i.isPartOf ().begin ()), n (i.isPartOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isPartOf",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // hasPart
    //
    for (coreMetadataType::hasPart_const_iterator
         b (i.hasPart ().begin ()), n (i.hasPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hasPart",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // hasTrackPart
    //
    for (coreMetadataType::hasTrackPart_const_iterator
         b (i.hasTrackPart ().begin ()), n (i.hasTrackPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hasTrackPart",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // isReferencedBy
    //
    for (coreMetadataType::isReferencedBy_const_iterator
         b (i.isReferencedBy ().begin ()), n (i.isReferencedBy ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isReferencedBy",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // references
    //
    for (coreMetadataType::references_const_iterator
         b (i.references ().begin ()), n (i.references ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "references",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // isFormatOf
    //
    for (coreMetadataType::isFormatOf_const_iterator
         b (i.isFormatOf ().begin ()), n (i.isFormatOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isFormatOf",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // hasFormat
    //
    for (coreMetadataType::hasFormat_const_iterator
         b (i.hasFormat ().begin ()), n (i.hasFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hasFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // isEpisodeOf
    //
    for (coreMetadataType::isEpisodeOf_const_iterator
         b (i.isEpisodeOf ().begin ()), n (i.isEpisodeOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isEpisodeOf",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // isMemberOf
    //
    for (coreMetadataType::isMemberOf_const_iterator
         b (i.isMemberOf ().begin ()), n (i.isMemberOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isMemberOf",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // coverage
    //
    for (coreMetadataType::coverage_const_iterator
         b (i.coverage ().begin ()), n (i.coverage ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coverage",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // rights
    //
    for (coreMetadataType::rights_const_iterator
         b (i.rights ().begin ()), n (i.rights ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rights",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // version
    //
    if (i.version ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "version",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.version ();
    }

    // publicationHistory
    //
    if (i.publicationHistory ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationHistory",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.publicationHistory ();
    }

    // rating
    //
    for (coreMetadataType::rating_const_iterator
         b (i.rating ().begin ()), n (i.rating ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rating",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // part
    //
    for (coreMetadataType::part_const_iterator
         b (i.part ().begin ()), n (i.part ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "part",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const titleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // title
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "title",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << i.title ();
    }

    // attributiondate
    //
    if (i.attributiondate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "attributiondate",
          e));

      a << *i.attributiondate ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const alternativeTitleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // title
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "title",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << i.title ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // statusLabel
    //
    if (i.statusLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "statusLabel",
          e));

      a << *i.statusLabel ();
    }

    // statusDefinition
    //
    if (i.statusDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "statusDefinition",
          e));

      a << *i.statusDefinition ();
    }

    // statusLink
    //
    if (i.statusLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "statusLink",
          e));

      a << *i.statusLink ();
    }

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // period
    //
    if (i.period ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << *i.period ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const identifierType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // identifier
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "identifier",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << i.identifier ();
    }

    // attributor
    //
    if (i.attributor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "attributor",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.attributor ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const subjectType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // subject
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subject",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << i.subject ();
    }

    // subjectCode
    //
    if (i.subjectCode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subjectCode",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.subjectCode ();
    }

    // subjectDefinition
    //
    if (i.subjectDefinition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subjectDefinition",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.subjectDefinition ();
    }

    // attributor
    //
    if (i.attributor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "attributor",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.attributor ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const typeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    for (typeType::type_const_iterator
         b (i.type ().begin ()), n (i.type ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // genre
    //
    for (typeType::genre_const_iterator
         b (i.genre ().begin ()), n (i.genre ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "genre",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // objectType
    //
    for (typeType::objectType_const_iterator
         b (i.objectType ().begin ()), n (i.objectType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "objectType",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // targetAudience
    //
    for (typeType::targetAudience_const_iterator
         b (i.targetAudience ().begin ()), n (i.targetAudience ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "targetAudience",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const descriptionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // description
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << i.description ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const coverageType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // coverage
    //
    if (i.coverage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coverage",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *i.coverage ();
    }

    // temporal
    //
    if (i.temporal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "temporal",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.temporal ();
    }

    // spatial
    //
    if (i.spatial ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spatial",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.spatial ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const rightsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // rights
    //
    if (i.rights ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rights",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *i.rights ();
    }

    // rightsLink
    //
    if (i.rightsLink ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightsLink",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.rightsLink ();
    }

    // rightsHolder
    //
    if (i.rightsHolder ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightsHolder",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.rightsHolder ();
    }

    // exploitationIssues
    //
    if (i.exploitationIssues ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "exploitationIssues",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.exploitationIssues ();
    }

    // coverage
    //
    if (i.coverage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coverage",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.coverage ();
    }

    // rightsClearanceFlag
    //
    if (i.rightsClearanceFlag ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightsClearanceFlag",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.rightsClearanceFlag ();
    }

    // disclaimer
    //
    for (rightsType::disclaimer_const_iterator
         b (i.disclaimer ().begin ()), n (i.disclaimer ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "disclaimer",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // rightsId
    //
    for (rightsType::rightsId_const_iterator
         b (i.rightsId ().begin ()), n (i.rightsId ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightsId",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // contactDetails
    //
    for (rightsType::contactDetails_const_iterator
         b (i.contactDetails ().begin ()), n (i.contactDetails ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contactDetails",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }

    // formatIDRefs
    //
    if (i.formatIDRefs ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatIDRefs",
          e));

      a << *i.formatIDRefs ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const formatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // format
    //
    if (i.format ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "format",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *i.format ();
    }

    // regionDelimX
    //
    if (i.regionDelimX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimX",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.regionDelimX ();
    }

    // regionDelimY
    //
    if (i.regionDelimY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimY",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.regionDelimY ();
    }

    // width
    //
    if (i.width ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.width ();
    }

    // height
    //
    if (i.height ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "height",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.height ();
    }

    // medium
    //
    for (formatType::medium_const_iterator
         b (i.medium ().begin ()), n (i.medium ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "medium",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // mimeType
    //
    for (formatType::mimeType_const_iterator
         b (i.mimeType ().begin ()), n (i.mimeType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mimeType",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // imageFormat
    //
    for (formatType::imageFormat_const_iterator
         b (i.imageFormat ().begin ()), n (i.imageFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "imageFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // videoFormat
    //
    for (formatType::videoFormat_const_iterator
         b (i.videoFormat ().begin ()), n (i.videoFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "videoFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // audioFormat
    //
    for (formatType::audioFormat_const_iterator
         b (i.audioFormat ().begin ()), n (i.audioFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "audioFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // containerFormat
    //
    for (formatType::containerFormat_const_iterator
         b (i.containerFormat ().begin ()), n (i.containerFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "containerFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // dataFormat
    //
    for (formatType::dataFormat_const_iterator
         b (i.dataFormat ().begin ()), n (i.dataFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // signingFormat
    //
    for (formatType::signingFormat_const_iterator
         b (i.signingFormat ().begin ()), n (i.signingFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "signingFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // start
    //
    if (i.start ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "start",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.start ();
    }

    // end
    //
    if (i.end ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "end",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.end ();
    }

    // duration
    //
    if (i.duration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "duration",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.duration ();
    }

    // fileSize
    //
    if (i.fileSize ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fileSize",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.fileSize ();
    }

    // filename
    //
    if (i.filename ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "filename",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.filename ();
    }

    // locator
    //
    if (i.locator ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "locator",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.locator ();
    }

    // documentFormat
    //
    if (i.documentFormat ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "documentFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.documentFormat ();
    }

    // technicalAttributeString
    //
    for (formatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (formatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (formatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (formatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (formatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (formatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (formatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (formatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (formatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (formatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (formatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (formatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (formatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // dateCreated
    //
    if (i.dateCreated ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dateCreated",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.dateCreated ();
    }

    // dateModified
    //
    if (i.dateModified ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dateModified",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.dateModified ();
    }

    // formatId
    //
    if (i.formatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatId",
          e));

      a << *i.formatId ();
    }

    // formatName
    //
    if (i.formatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatName",
          e));

      a << *i.formatName ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const relationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // relation
    //
    if (i.relation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relation",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *i.relation ();
    }

    // relationIdentifier
    //
    if (i.relationIdentifier ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relationIdentifier",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.relationIdentifier ();
    }

    // relationLink
    //
    if (i.relationLink ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relationLink",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.relationLink ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // runningOrderNumber
    //
    if (i.runningOrderNumber ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "runningOrderNumber",
          e));

      a << *i.runningOrderNumber ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const languageType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // language
    //
    if (i.language ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "language",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *i.language ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dateType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // date
    //
    for (dateType::date_const_iterator
         b (i.date ().begin ()), n (i.date ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "date",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // created
    //
    if (i.created ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "created",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.created ();
    }

    // issued
    //
    if (i.issued ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "issued",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.issued ();
    }

    // modified
    //
    if (i.modified ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "modified",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.modified ();
    }

    // digitised
    //
    if (i.digitised ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "digitised",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.digitised ();
    }

    // alternative
    //
    for (dateType::alternative_const_iterator
         b (i.alternative ().begin ()), n (i.alternative ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alternative",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const publicationHistoryType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // firstPublicationDate
    //
    if (i.firstPublicationDate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "firstPublicationDate",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.firstPublicationDate ();
    }

    // firstPublicationTime
    //
    if (i.firstPublicationTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "firstPublicationTime",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.firstPublicationTime ();
    }

    // firstPublicationChannel
    //
    if (i.firstPublicationChannel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "firstPublicationChannel",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.firstPublicationChannel ();
    }

    // repeatDate
    //
    for (publicationHistoryType::repeatDate_const_iterator
         b (i.repeatDate ().begin ()), n (i.repeatDate ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "repeatDate",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // repeatTime
    //
    for (publicationHistoryType::repeatTime_const_iterator
         b (i.repeatTime ().begin ()), n (i.repeatTime ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "repeatTime",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // repeatChannel
    //
    for (publicationHistoryType::repeatChannel_const_iterator
         b (i.repeatChannel ().begin ()), n (i.repeatChannel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "repeatChannel",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const entityType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // contactDetails
    //
    for (entityType::contactDetails_const_iterator
         b (i.contactDetails ().begin ()), n (i.contactDetails ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contactDetails",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // organisationDetails
    //
    if (i.organisationDetails ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "organisationDetails",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.organisationDetails ();
    }

    // role
    //
    for (entityType::role_const_iterator
         b (i.role ().begin ()), n (i.role ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "role",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // entityId
    //
    if (i.entityId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "entityId",
          e));

      a << *i.entityId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const contactDetailsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.name ();
    }

    // givenName
    //
    if (i.givenName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "givenName",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.givenName ();
    }

    // familyName
    //
    if (i.familyName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "familyName",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.familyName ();
    }

    // username
    //
    if (i.username ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "username",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.username ();
    }

    // occupation
    //
    if (i.occupation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "occupation",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.occupation ();
    }

    // details
    //
    for (contactDetailsType::details_const_iterator
         b (i.details ().begin ()), n (i.details ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "details",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // stageName
    //
    for (contactDetailsType::stageName_const_iterator
         b (i.stageName ().begin ()), n (i.stageName ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stageName",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // relatedContacts
    //
    for (contactDetailsType::relatedContacts_const_iterator
         b (i.relatedContacts ().begin ()), n (i.relatedContacts ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relatedContacts",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // contactId
    //
    if (i.contactId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "contactId",
          e));

      a << *i.contactId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const organisationDetailsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // organisationName
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "organisationName",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << i.organisationName ();
    }

    // organisationDepartment
    //
    if (i.organisationDepartment ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "organisationDepartment",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.organisationDepartment ();
    }

    // details
    //
    for (organisationDetailsType::details_const_iterator
         b (i.details ().begin ()), n (i.details ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "details",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // contacts
    //
    for (organisationDetailsType::contacts_const_iterator
         b (i.contacts ().begin ()), n (i.contacts ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contacts",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // organisationId
    //
    if (i.organisationId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "organisationId",
          e));

      a << *i.organisationId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const detailsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // emailAddress
    //
    if (i.emailAddress ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "emailAddress",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.emailAddress ();
    }

    // webAddress
    //
    if (i.webAddress ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "webAddress",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.webAddress ();
    }

    // address
    //
    if (i.address ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "address",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.address ();
    }

    // telephoneNumber
    //
    if (i.telephoneNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "telephoneNumber",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.telephoneNumber ();
    }

    // mobileTelephoneNumber
    //
    if (i.mobileTelephoneNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mobileTelephoneNumber",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.mobileTelephoneNumber ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const addressType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // addressLine
    //
    for (addressType::addressLine_const_iterator
         b (i.addressLine ().begin ()), n (i.addressLine ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "addressLine",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // addressTownCity
    //
    if (i.addressTownCity ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "addressTownCity",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.addressTownCity ();
    }

    // addressCountyState
    //
    if (i.addressCountyState ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "addressCountyState",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.addressCountyState ();
    }

    // addressDeliveryCode
    //
    if (i.addressDeliveryCode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "addressDeliveryCode",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.addressDeliveryCode ();
    }

    // country
    //
    if (i.country ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "country",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.country ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const editUnitNumberType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >& > (i);

    // editRate
    //
    if (i.editRate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "editRate",
          e));

      a << *i.editRate ();
    }

    // factorNumerator
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factorNumerator",
          e));

      a << i.factorNumerator ();
    }

    // factorDenominator
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factorDenominator",
          e));

      a << i.factorDenominator ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ratingType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ratingValue
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingValue",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << i.ratingValue ();
    }

    // ratingScaleMaxValue
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingScaleMaxValue",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << i.ratingScaleMaxValue ();
    }

    // ratingScaleMinValue
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingScaleMinValue",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << i.ratingScaleMinValue ();
    }

    // ratingProvider
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingProvider",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << i.ratingProvider ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const lengthType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);

    // unit
    //
    if (i.unit ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << *i.unit ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const imageFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // regionDelimX
    //
    if (i.regionDelimX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimX",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.regionDelimX ();
    }

    // regionDelimY
    //
    if (i.regionDelimY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimY",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.regionDelimY ();
    }

    // width
    //
    if (i.width ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.width ();
    }

    // height
    //
    if (i.height ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "height",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.height ();
    }

    // orientation
    //
    if (i.orientation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "orientation",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.orientation ();
    }

    // imageEncoding
    //
    for (imageFormatType::imageEncoding_const_iterator
         b (i.imageEncoding ().begin ()), n (i.imageEncoding ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "imageEncoding",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeString
    //
    for (imageFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (imageFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (imageFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (imageFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (imageFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (imageFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (imageFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (imageFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (imageFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (imageFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (imageFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (imageFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (imageFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // imageFormatId
    //
    if (i.imageFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "imageFormatId",
          e));

      a << *i.imageFormatId ();
    }

    // imageFormatName
    //
    if (i.imageFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "imageFormatName",
          e));

      a << *i.imageFormatName ();
    }

    // imageFormatDefinition
    //
    if (i.imageFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "imageFormatDefinition",
          e));

      a << *i.imageFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const videoFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // regionDelimX
    //
    if (i.regionDelimX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimX",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.regionDelimX ();
    }

    // regionDelimY
    //
    if (i.regionDelimY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimY",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.regionDelimY ();
    }

    // width
    //
    if (i.width ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.width ();
    }

    // height
    //
    if (i.height ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "height",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.height ();
    }

    // aspectRatio
    //
    if (i.aspectRatio ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aspectRatio",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.aspectRatio ();
    }

    // videoEncoding
    //
    for (videoFormatType::videoEncoding_const_iterator
         b (i.videoEncoding ().begin ()), n (i.videoEncoding ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "videoEncoding",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // videoTrack
    //
    for (videoFormatType::videoTrack_const_iterator
         b (i.videoTrack ().begin ()), n (i.videoTrack ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "videoTrack",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeString
    //
    for (videoFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (videoFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (videoFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (videoFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (videoFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (videoFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (videoFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (videoFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (videoFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (videoFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (videoFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (videoFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (videoFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // videoFormatId
    //
    if (i.videoFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "videoFormatId",
          e));

      a << *i.videoFormatId ();
    }

    // videoFormatName
    //
    if (i.videoFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "videoFormatName",
          e));

      a << *i.videoFormatName ();
    }

    // videoFormatDefinition
    //
    if (i.videoFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "videoFormatDefinition",
          e));

      a << *i.videoFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const audioFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // audioEncoding
    //
    for (audioFormatType::audioEncoding_const_iterator
         b (i.audioEncoding ().begin ()), n (i.audioEncoding ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "audioEncoding",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // audioTrackConfiguration
    //
    if (i.audioTrackConfiguration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "audioTrackConfiguration",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.audioTrackConfiguration ();
    }

    // audioTrack
    //
    for (audioFormatType::audioTrack_const_iterator
         b (i.audioTrack ().begin ()), n (i.audioTrack ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "audioTrack",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeString
    //
    for (audioFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (audioFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (audioFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (audioFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (audioFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (audioFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (audioFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (audioFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (audioFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (audioFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (audioFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (audioFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (audioFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // audioFormatId
    //
    if (i.audioFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "audioFormatId",
          e));

      a << *i.audioFormatId ();
    }

    // audioFormatName
    //
    if (i.audioFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "audioFormatName",
          e));

      a << *i.audioFormatName ();
    }

    // audioFormatDefinition
    //
    if (i.audioFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "audioFormatDefinition",
          e));

      a << *i.audioFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dataFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // captioningFormat
    //
    for (dataFormatType::captioningFormat_const_iterator
         b (i.captioningFormat ().begin ()), n (i.captioningFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "captioningFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // ancillaryDataFormat
    //
    for (dataFormatType::ancillaryDataFormat_const_iterator
         b (i.ancillaryDataFormat ().begin ()), n (i.ancillaryDataFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ancillaryDataFormat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeString
    //
    for (dataFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (dataFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (dataFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (dataFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (dataFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (dataFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (dataFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (dataFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (dataFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (dataFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (dataFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (dataFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (dataFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // dataFormatId
    //
    if (i.dataFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataFormatId",
          e));

      a << *i.dataFormatId ();
    }

    // dataFormatName
    //
    if (i.dataFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataFormatName",
          e));

      a << *i.dataFormatName ();
    }

    // dataFormatDefinition
    //
    if (i.dataFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataFormatDefinition",
          e));

      a << *i.dataFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const documentFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // wordCount
    //
    if (i.wordCount ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "wordCount",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.wordCount ();
    }

    // regionDelimX
    //
    if (i.regionDelimX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimX",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.regionDelimX ();
    }

    // regionDelimY
    //
    if (i.regionDelimY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimY",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.regionDelimY ();
    }

    // width
    //
    if (i.width ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.width ();
    }

    // height
    //
    if (i.height ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "height",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.height ();
    }

    // technicalAttributeString
    //
    for (documentFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (documentFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (documentFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (documentFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (documentFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (documentFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (documentFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (documentFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (documentFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (documentFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (documentFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (documentFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (documentFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // documentFormatId
    //
    if (i.documentFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentFormatId",
          e));

      a << *i.documentFormatId ();
    }

    // documentFormatName
    //
    if (i.documentFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentFormatName",
          e));

      a << *i.documentFormatName ();
    }

    // documentFormatDefinition
    //
    if (i.documentFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentFormatDefinition",
          e));

      a << *i.documentFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const timeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // timecode
    //
    if (i.timecode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timecode",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.timecode ();
    }

    // normalPlayTime
    //
    if (i.normalPlayTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "normalPlayTime",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.normalPlayTime ();
    }

    // editUnitNumber
    //
    if (i.editUnitNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "editUnitNumber",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.editUnitNumber ();
    }

    // time
    //
    if (i.time ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "time",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.time ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const durationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // timecode
    //
    if (i.timecode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timecode",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.timecode ();
    }

    // normalPlayTime
    //
    if (i.normalPlayTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "normalPlayTime",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.normalPlayTime ();
    }

    // editUnitNumber
    //
    if (i.editUnitNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "editUnitNumber",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.editUnitNumber ();
    }

    // time
    //
    if (i.time ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "time",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.time ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const String& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Boolean& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Float& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Int8& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Int16& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Int32& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Int64& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UInt8& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UInt16& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UInt32& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UInt64& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const technicalAttributeRationalType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >& > (i);

    // factorNumerator
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factorNumerator",
          e));

      a << i.factorNumerator ();
    }

    // factorDenominator
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factorDenominator",
          e));

      a << i.factorDenominator ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const technicalAttributeUriType& i)
  {
    e << static_cast< const ::xml_schema::uri& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const hasTrackPart& i)
  {
    e << static_cast< const ::ebuCore_2011::relationType& > (i);

    // trackPartTitle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trackPartTitle",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << i.trackPartTitle ();
    }

    // destinationStart
    //
    if (i.destinationStart ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "destinationStart",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.destinationStart ();
    }

    // destinationEnd
    //
    if (i.destinationEnd ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "destinationEnd",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.destinationEnd ();
    }

    // sourceStart
    //
    if (i.sourceStart ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sourceStart",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.sourceStart ();
    }

    // sourceEnd
    //
    if (i.sourceEnd ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sourceEnd",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.sourceEnd ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const part& i)
  {
    e << static_cast< const ::ebuCore_2011::coreMetadataType& > (i);

    // partId
    //
    if (i.partId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "partId",
          e));

      a << *i.partId ();
    }

    // partName
    //
    if (i.partName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "partName",
          e));

      a << *i.partName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const genre& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const objectType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const targetAudience& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const temporal& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // PeriodOfTime
    //
    if (i.PeriodOfTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PeriodOfTime",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.PeriodOfTime ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }

    // periodId
    //
    if (i.periodId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "periodId",
          e));

      a << *i.periodId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const spatial& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // location
    //
    for (spatial::location_const_iterator
         b (i.location ().begin ()), n (i.location ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "location",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const medium& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mimeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const containerFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const signingFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // trackId
    //
    if (i.trackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackId",
          e));

      a << *i.trackId ();
    }

    // trackName
    //
    if (i.trackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackName",
          e));

      a << *i.trackName ();
    }

    // language
    //
    if (i.language ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "language",
          e));

      a << *i.language ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // signingSourceUri
    //
    if (i.signingSourceUri ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "signingSourceUri",
          e));

      a << *i.signingSourceUri ();
    }

    // signingFormatId
    //
    if (i.signingFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "signingFormatId",
          e));

      a << *i.signingFormatId ();
    }

    // signingFormatName
    //
    if (i.signingFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "signingFormatName",
          e));

      a << *i.signingFormatName ();
    }

    // signingFormatDefinition
    //
    if (i.signingFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "signingFormatDefinition",
          e));

      a << *i.signingFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const locator& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dateCreated& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // period
    //
    if (i.period ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << *i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dateModified& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // period
    //
    if (i.period ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << *i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const created& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // period
    //
    if (i.period ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << *i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const issued& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // period
    //
    if (i.period ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << *i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const modified& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // period
    //
    if (i.period ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << *i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const digitised& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // period
    //
    if (i.period ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << *i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const alternative& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // period
    //
    if (i.period ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << *i.period ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const firstPublicationChannel& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // formatIdRef
    //
    if (i.formatIdRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatIdRef",
          e));

      a << *i.formatIdRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const repeatChannel& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // formatIdRef
    //
    if (i.formatIdRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatIdRef",
          e));

      a << *i.formatIdRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const role& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const organisationDepartment& i)
  {
    e << static_cast< const ::dc::elementType& > (i);

    // departmentId
    //
    if (i.departmentId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "departmentId",
          e));

      a << *i.departmentId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const country& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const orientation& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const orientation& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const orientation& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const imageEncoding& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const aspectRatio& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const videoEncoding& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const videoTrack& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // trackId
    //
    if (i.trackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackId",
          e));

      a << *i.trackId ();
    }

    // trackName
    //
    if (i.trackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackName",
          e));

      a << *i.trackName ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const audioEncoding& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const audioTrackConfiguration& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const audioTrack& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // trackLanguage
    //
    if (i.trackLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackLanguage",
          e));

      a << *i.trackLanguage ();
    }

    // trackId
    //
    if (i.trackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackId",
          e));

      a << *i.trackId ();
    }

    // trackName
    //
    if (i.trackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackName",
          e));

      a << *i.trackName ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const captioningFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // trackId
    //
    if (i.trackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackId",
          e));

      a << *i.trackId ();
    }

    // trackName
    //
    if (i.trackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackName",
          e));

      a << *i.trackName ();
    }

    // language
    //
    if (i.language ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "language",
          e));

      a << *i.language ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // captioningSourceUri
    //
    if (i.captioningSourceUri ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "captioningSourceUri",
          e));

      a << *i.captioningSourceUri ();
    }

    // captioningFormatId
    //
    if (i.captioningFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "captioningFormatId",
          e));

      a << *i.captioningFormatId ();
    }

    // captioningFormatName
    //
    if (i.captioningFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "captioningFormatName",
          e));

      a << *i.captioningFormatName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ancillaryDataFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // DID
    //
    if (i.DID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DID",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.DID ();
    }

    // SDID
    //
    if (i.SDID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SDID",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.SDID ();
    }

    // lineNumber
    //
    for (ancillaryDataFormat::lineNumber_const_iterator
         b (i.lineNumber ().begin ()), n (i.lineNumber ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lineNumber",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *b;
    }

    // wrappingType
    //
    if (i.wrappingType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "wrappingType",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.wrappingType ();
    }

    // ancillaryDataFormatId
    //
    if (i.ancillaryDataFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ancillaryDataFormatId",
          e));

      a << *i.ancillaryDataFormatId ();
    }

    // ancillaryDataFormatName
    //
    if (i.ancillaryDataFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ancillaryDataFormatName",
          e));

      a << *i.ancillaryDataFormatName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const timecode& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const timecode& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const timecode& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const time& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const timecode1& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const timecode1& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const timecode1& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const time1& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodOfTime& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // period
    //
    if (i.period ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << *i.period ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const location& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.name ();
    }

    // coordinates
    //
    if (i.coordinates ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coordinates",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.coordinates ();
    }

    // code
    //
    if (i.code ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "code",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << *i.code ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }

    // locationId
    //
    if (i.locationId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "locationId",
          e));

      a << *i.locationId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const coordinates& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // posy
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "posy",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << i.posy ();
    }

    // posx
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "posx",
          "urn:ebu:metadata-schema:ebuCore_2011",
          e));

      s << i.posx ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

