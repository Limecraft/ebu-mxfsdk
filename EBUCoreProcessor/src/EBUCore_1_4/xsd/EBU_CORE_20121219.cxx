// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "EBUCore_1_4/xsd/EBU_CORE_20121219.hxx"

namespace ebuCore_2012
{
  // ebuCoreMainType
  // 

  const ebuCoreMainType::coreMetadata_type& ebuCoreMainType::
  coreMetadata () const
  {
    return this->coreMetadata_.get ();
  }

  ebuCoreMainType::coreMetadata_type& ebuCoreMainType::
  coreMetadata ()
  {
    return this->coreMetadata_.get ();
  }

  void ebuCoreMainType::
  coreMetadata (const coreMetadata_type& x)
  {
    this->coreMetadata_.set (x);
  }

  void ebuCoreMainType::
  coreMetadata (::std::auto_ptr< coreMetadata_type > x)
  {
    this->coreMetadata_.set (x);
  }

  const ebuCoreMainType::metadataProvider_optional& ebuCoreMainType::
  metadataProvider () const
  {
    return this->metadataProvider_;
  }

  ebuCoreMainType::metadataProvider_optional& ebuCoreMainType::
  metadataProvider ()
  {
    return this->metadataProvider_;
  }

  void ebuCoreMainType::
  metadataProvider (const metadataProvider_type& x)
  {
    this->metadataProvider_.set (x);
  }

  void ebuCoreMainType::
  metadataProvider (const metadataProvider_optional& x)
  {
    this->metadataProvider_ = x;
  }

  void ebuCoreMainType::
  metadataProvider (::std::auto_ptr< metadataProvider_type > x)
  {
    this->metadataProvider_.set (x);
  }

  const ebuCoreMainType::schema_optional& ebuCoreMainType::
  schema () const
  {
    return this->schema_;
  }

  ebuCoreMainType::schema_optional& ebuCoreMainType::
  schema ()
  {
    return this->schema_;
  }

  void ebuCoreMainType::
  schema (const schema_type& x)
  {
    this->schema_.set (x);
  }

  void ebuCoreMainType::
  schema (const schema_optional& x)
  {
    this->schema_ = x;
  }

  void ebuCoreMainType::
  schema (::std::auto_ptr< schema_type > x)
  {
    this->schema_.set (x);
  }

  const ebuCoreMainType::version_type& ebuCoreMainType::
  version () const
  {
    return this->version_.get ();
  }

  ebuCoreMainType::version_type& ebuCoreMainType::
  version ()
  {
    return this->version_.get ();
  }

  void ebuCoreMainType::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void ebuCoreMainType::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const ebuCoreMainType::version_type& ebuCoreMainType::
  version_default_value ()
  {
    return version_default_value_;
  }

  const ebuCoreMainType::dateLastModified_optional& ebuCoreMainType::
  dateLastModified () const
  {
    return this->dateLastModified_;
  }

  ebuCoreMainType::dateLastModified_optional& ebuCoreMainType::
  dateLastModified ()
  {
    return this->dateLastModified_;
  }

  void ebuCoreMainType::
  dateLastModified (const dateLastModified_type& x)
  {
    this->dateLastModified_.set (x);
  }

  void ebuCoreMainType::
  dateLastModified (const dateLastModified_optional& x)
  {
    this->dateLastModified_ = x;
  }

  void ebuCoreMainType::
  dateLastModified (::std::auto_ptr< dateLastModified_type > x)
  {
    this->dateLastModified_.set (x);
  }

  const ebuCoreMainType::documentId_optional& ebuCoreMainType::
  documentId () const
  {
    return this->documentId_;
  }

  ebuCoreMainType::documentId_optional& ebuCoreMainType::
  documentId ()
  {
    return this->documentId_;
  }

  void ebuCoreMainType::
  documentId (const documentId_type& x)
  {
    this->documentId_.set (x);
  }

  void ebuCoreMainType::
  documentId (const documentId_optional& x)
  {
    this->documentId_ = x;
  }

  void ebuCoreMainType::
  documentId (::std::auto_ptr< documentId_type > x)
  {
    this->documentId_.set (x);
  }

  const ebuCoreMainType::documentLocation_optional& ebuCoreMainType::
  documentLocation () const
  {
    return this->documentLocation_;
  }

  ebuCoreMainType::documentLocation_optional& ebuCoreMainType::
  documentLocation ()
  {
    return this->documentLocation_;
  }

  void ebuCoreMainType::
  documentLocation (const documentLocation_type& x)
  {
    this->documentLocation_.set (x);
  }

  void ebuCoreMainType::
  documentLocation (const documentLocation_optional& x)
  {
    this->documentLocation_ = x;
  }

  void ebuCoreMainType::
  documentLocation (::std::auto_ptr< documentLocation_type > x)
  {
    this->documentLocation_.set (x);
  }

  const ebuCoreMainType::lang_optional& ebuCoreMainType::
  lang () const
  {
    return this->lang_;
  }

  ebuCoreMainType::lang_optional& ebuCoreMainType::
  lang ()
  {
    return this->lang_;
  }

  void ebuCoreMainType::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void ebuCoreMainType::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void ebuCoreMainType::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // coreMetadataType
  // 

  const coreMetadataType::title_sequence& coreMetadataType::
  title () const
  {
    return this->title_;
  }

  coreMetadataType::title_sequence& coreMetadataType::
  title ()
  {
    return this->title_;
  }

  void coreMetadataType::
  title (const title_sequence& s)
  {
    this->title_ = s;
  }

  const coreMetadataType::alternativeTitle_sequence& coreMetadataType::
  alternativeTitle () const
  {
    return this->alternativeTitle_;
  }

  coreMetadataType::alternativeTitle_sequence& coreMetadataType::
  alternativeTitle ()
  {
    return this->alternativeTitle_;
  }

  void coreMetadataType::
  alternativeTitle (const alternativeTitle_sequence& s)
  {
    this->alternativeTitle_ = s;
  }

  const coreMetadataType::creator_sequence& coreMetadataType::
  creator () const
  {
    return this->creator_;
  }

  coreMetadataType::creator_sequence& coreMetadataType::
  creator ()
  {
    return this->creator_;
  }

  void coreMetadataType::
  creator (const creator_sequence& s)
  {
    this->creator_ = s;
  }

  const coreMetadataType::subject_sequence& coreMetadataType::
  subject () const
  {
    return this->subject_;
  }

  coreMetadataType::subject_sequence& coreMetadataType::
  subject ()
  {
    return this->subject_;
  }

  void coreMetadataType::
  subject (const subject_sequence& s)
  {
    this->subject_ = s;
  }

  const coreMetadataType::description_sequence& coreMetadataType::
  description () const
  {
    return this->description_;
  }

  coreMetadataType::description_sequence& coreMetadataType::
  description ()
  {
    return this->description_;
  }

  void coreMetadataType::
  description (const description_sequence& s)
  {
    this->description_ = s;
  }

  const coreMetadataType::publisher_sequence& coreMetadataType::
  publisher () const
  {
    return this->publisher_;
  }

  coreMetadataType::publisher_sequence& coreMetadataType::
  publisher ()
  {
    return this->publisher_;
  }

  void coreMetadataType::
  publisher (const publisher_sequence& s)
  {
    this->publisher_ = s;
  }

  const coreMetadataType::contributor_sequence& coreMetadataType::
  contributor () const
  {
    return this->contributor_;
  }

  coreMetadataType::contributor_sequence& coreMetadataType::
  contributor ()
  {
    return this->contributor_;
  }

  void coreMetadataType::
  contributor (const contributor_sequence& s)
  {
    this->contributor_ = s;
  }

  const coreMetadataType::date_sequence& coreMetadataType::
  date () const
  {
    return this->date_;
  }

  coreMetadataType::date_sequence& coreMetadataType::
  date ()
  {
    return this->date_;
  }

  void coreMetadataType::
  date (const date_sequence& s)
  {
    this->date_ = s;
  }

  const coreMetadataType::type_sequence& coreMetadataType::
  type () const
  {
    return this->type_;
  }

  coreMetadataType::type_sequence& coreMetadataType::
  type ()
  {
    return this->type_;
  }

  void coreMetadataType::
  type (const type_sequence& s)
  {
    this->type_ = s;
  }

  const coreMetadataType::format_sequence& coreMetadataType::
  format () const
  {
    return this->format_;
  }

  coreMetadataType::format_sequence& coreMetadataType::
  format ()
  {
    return this->format_;
  }

  void coreMetadataType::
  format (const format_sequence& s)
  {
    this->format_ = s;
  }

  const coreMetadataType::identifier_sequence& coreMetadataType::
  identifier () const
  {
    return this->identifier_;
  }

  coreMetadataType::identifier_sequence& coreMetadataType::
  identifier ()
  {
    return this->identifier_;
  }

  void coreMetadataType::
  identifier (const identifier_sequence& s)
  {
    this->identifier_ = s;
  }

  const coreMetadataType::source_sequence& coreMetadataType::
  source () const
  {
    return this->source_;
  }

  coreMetadataType::source_sequence& coreMetadataType::
  source ()
  {
    return this->source_;
  }

  void coreMetadataType::
  source (const source_sequence& s)
  {
    this->source_ = s;
  }

  const coreMetadataType::language_sequence& coreMetadataType::
  language () const
  {
    return this->language_;
  }

  coreMetadataType::language_sequence& coreMetadataType::
  language ()
  {
    return this->language_;
  }

  void coreMetadataType::
  language (const language_sequence& s)
  {
    this->language_ = s;
  }

  const coreMetadataType::relation_sequence& coreMetadataType::
  relation () const
  {
    return this->relation_;
  }

  coreMetadataType::relation_sequence& coreMetadataType::
  relation ()
  {
    return this->relation_;
  }

  void coreMetadataType::
  relation (const relation_sequence& s)
  {
    this->relation_ = s;
  }

  const coreMetadataType::isVersionOf_sequence& coreMetadataType::
  isVersionOf () const
  {
    return this->isVersionOf_;
  }

  coreMetadataType::isVersionOf_sequence& coreMetadataType::
  isVersionOf ()
  {
    return this->isVersionOf_;
  }

  void coreMetadataType::
  isVersionOf (const isVersionOf_sequence& s)
  {
    this->isVersionOf_ = s;
  }

  const coreMetadataType::hasVersion_sequence& coreMetadataType::
  hasVersion () const
  {
    return this->hasVersion_;
  }

  coreMetadataType::hasVersion_sequence& coreMetadataType::
  hasVersion ()
  {
    return this->hasVersion_;
  }

  void coreMetadataType::
  hasVersion (const hasVersion_sequence& s)
  {
    this->hasVersion_ = s;
  }

  const coreMetadataType::isReplacedBy_sequence& coreMetadataType::
  isReplacedBy () const
  {
    return this->isReplacedBy_;
  }

  coreMetadataType::isReplacedBy_sequence& coreMetadataType::
  isReplacedBy ()
  {
    return this->isReplacedBy_;
  }

  void coreMetadataType::
  isReplacedBy (const isReplacedBy_sequence& s)
  {
    this->isReplacedBy_ = s;
  }

  const coreMetadataType::replaces_sequence& coreMetadataType::
  replaces () const
  {
    return this->replaces_;
  }

  coreMetadataType::replaces_sequence& coreMetadataType::
  replaces ()
  {
    return this->replaces_;
  }

  void coreMetadataType::
  replaces (const replaces_sequence& s)
  {
    this->replaces_ = s;
  }

  const coreMetadataType::isRequiredBy_sequence& coreMetadataType::
  isRequiredBy () const
  {
    return this->isRequiredBy_;
  }

  coreMetadataType::isRequiredBy_sequence& coreMetadataType::
  isRequiredBy ()
  {
    return this->isRequiredBy_;
  }

  void coreMetadataType::
  isRequiredBy (const isRequiredBy_sequence& s)
  {
    this->isRequiredBy_ = s;
  }

  const coreMetadataType::requires_sequence& coreMetadataType::
  requires () const
  {
    return this->requires_;
  }

  coreMetadataType::requires_sequence& coreMetadataType::
  requires ()
  {
    return this->requires_;
  }

  void coreMetadataType::
  requires (const requires_sequence& s)
  {
    this->requires_ = s;
  }

  const coreMetadataType::isPartOf_sequence& coreMetadataType::
  isPartOf () const
  {
    return this->isPartOf_;
  }

  coreMetadataType::isPartOf_sequence& coreMetadataType::
  isPartOf ()
  {
    return this->isPartOf_;
  }

  void coreMetadataType::
  isPartOf (const isPartOf_sequence& s)
  {
    this->isPartOf_ = s;
  }

  const coreMetadataType::hasPart_sequence& coreMetadataType::
  hasPart () const
  {
    return this->hasPart_;
  }

  coreMetadataType::hasPart_sequence& coreMetadataType::
  hasPart ()
  {
    return this->hasPart_;
  }

  void coreMetadataType::
  hasPart (const hasPart_sequence& s)
  {
    this->hasPart_ = s;
  }

  const coreMetadataType::hasTrackPart_sequence& coreMetadataType::
  hasTrackPart () const
  {
    return this->hasTrackPart_;
  }

  coreMetadataType::hasTrackPart_sequence& coreMetadataType::
  hasTrackPart ()
  {
    return this->hasTrackPart_;
  }

  void coreMetadataType::
  hasTrackPart (const hasTrackPart_sequence& s)
  {
    this->hasTrackPart_ = s;
  }

  const coreMetadataType::isReferencedBy_sequence& coreMetadataType::
  isReferencedBy () const
  {
    return this->isReferencedBy_;
  }

  coreMetadataType::isReferencedBy_sequence& coreMetadataType::
  isReferencedBy ()
  {
    return this->isReferencedBy_;
  }

  void coreMetadataType::
  isReferencedBy (const isReferencedBy_sequence& s)
  {
    this->isReferencedBy_ = s;
  }

  const coreMetadataType::references_sequence& coreMetadataType::
  references () const
  {
    return this->references_;
  }

  coreMetadataType::references_sequence& coreMetadataType::
  references ()
  {
    return this->references_;
  }

  void coreMetadataType::
  references (const references_sequence& s)
  {
    this->references_ = s;
  }

  const coreMetadataType::isFormatOf_sequence& coreMetadataType::
  isFormatOf () const
  {
    return this->isFormatOf_;
  }

  coreMetadataType::isFormatOf_sequence& coreMetadataType::
  isFormatOf ()
  {
    return this->isFormatOf_;
  }

  void coreMetadataType::
  isFormatOf (const isFormatOf_sequence& s)
  {
    this->isFormatOf_ = s;
  }

  const coreMetadataType::hasFormat_sequence& coreMetadataType::
  hasFormat () const
  {
    return this->hasFormat_;
  }

  coreMetadataType::hasFormat_sequence& coreMetadataType::
  hasFormat ()
  {
    return this->hasFormat_;
  }

  void coreMetadataType::
  hasFormat (const hasFormat_sequence& s)
  {
    this->hasFormat_ = s;
  }

  const coreMetadataType::isEpisodeOf_sequence& coreMetadataType::
  isEpisodeOf () const
  {
    return this->isEpisodeOf_;
  }

  coreMetadataType::isEpisodeOf_sequence& coreMetadataType::
  isEpisodeOf ()
  {
    return this->isEpisodeOf_;
  }

  void coreMetadataType::
  isEpisodeOf (const isEpisodeOf_sequence& s)
  {
    this->isEpisodeOf_ = s;
  }

  const coreMetadataType::isMemberOf_sequence& coreMetadataType::
  isMemberOf () const
  {
    return this->isMemberOf_;
  }

  coreMetadataType::isMemberOf_sequence& coreMetadataType::
  isMemberOf ()
  {
    return this->isMemberOf_;
  }

  void coreMetadataType::
  isMemberOf (const isMemberOf_sequence& s)
  {
    this->isMemberOf_ = s;
  }

  const coreMetadataType::hasMember_sequence& coreMetadataType::
  hasMember () const
  {
    return this->hasMember_;
  }

  coreMetadataType::hasMember_sequence& coreMetadataType::
  hasMember ()
  {
    return this->hasMember_;
  }

  void coreMetadataType::
  hasMember (const hasMember_sequence& s)
  {
    this->hasMember_ = s;
  }

  const coreMetadataType::coverage_sequence& coreMetadataType::
  coverage () const
  {
    return this->coverage_;
  }

  coreMetadataType::coverage_sequence& coreMetadataType::
  coverage ()
  {
    return this->coverage_;
  }

  void coreMetadataType::
  coverage (const coverage_sequence& s)
  {
    this->coverage_ = s;
  }

  const coreMetadataType::rights_sequence& coreMetadataType::
  rights () const
  {
    return this->rights_;
  }

  coreMetadataType::rights_sequence& coreMetadataType::
  rights ()
  {
    return this->rights_;
  }

  void coreMetadataType::
  rights (const rights_sequence& s)
  {
    this->rights_ = s;
  }

  const coreMetadataType::version_sequence& coreMetadataType::
  version () const
  {
    return this->version_;
  }

  coreMetadataType::version_sequence& coreMetadataType::
  version ()
  {
    return this->version_;
  }

  void coreMetadataType::
  version (const version_sequence& s)
  {
    this->version_ = s;
  }

  const coreMetadataType::publicationHistory_optional& coreMetadataType::
  publicationHistory () const
  {
    return this->publicationHistory_;
  }

  coreMetadataType::publicationHistory_optional& coreMetadataType::
  publicationHistory ()
  {
    return this->publicationHistory_;
  }

  void coreMetadataType::
  publicationHistory (const publicationHistory_type& x)
  {
    this->publicationHistory_.set (x);
  }

  void coreMetadataType::
  publicationHistory (const publicationHistory_optional& x)
  {
    this->publicationHistory_ = x;
  }

  void coreMetadataType::
  publicationHistory (::std::auto_ptr< publicationHistory_type > x)
  {
    this->publicationHistory_.set (x);
  }

  const coreMetadataType::rating_sequence& coreMetadataType::
  rating () const
  {
    return this->rating_;
  }

  coreMetadataType::rating_sequence& coreMetadataType::
  rating ()
  {
    return this->rating_;
  }

  void coreMetadataType::
  rating (const rating_sequence& s)
  {
    this->rating_ = s;
  }

  const coreMetadataType::part_sequence& coreMetadataType::
  part () const
  {
    return this->part_;
  }

  coreMetadataType::part_sequence& coreMetadataType::
  part ()
  {
    return this->part_;
  }

  void coreMetadataType::
  part (const part_sequence& s)
  {
    this->part_ = s;
  }


  // partType
  // 

  const partType::partStartTime_optional& partType::
  partStartTime () const
  {
    return this->partStartTime_;
  }

  partType::partStartTime_optional& partType::
  partStartTime ()
  {
    return this->partStartTime_;
  }

  void partType::
  partStartTime (const partStartTime_type& x)
  {
    this->partStartTime_.set (x);
  }

  void partType::
  partStartTime (const partStartTime_optional& x)
  {
    this->partStartTime_ = x;
  }

  void partType::
  partStartTime (::std::auto_ptr< partStartTime_type > x)
  {
    this->partStartTime_.set (x);
  }

  const partType::partDuration_optional& partType::
  partDuration () const
  {
    return this->partDuration_;
  }

  partType::partDuration_optional& partType::
  partDuration ()
  {
    return this->partDuration_;
  }

  void partType::
  partDuration (const partDuration_type& x)
  {
    this->partDuration_.set (x);
  }

  void partType::
  partDuration (const partDuration_optional& x)
  {
    this->partDuration_ = x;
  }

  void partType::
  partDuration (::std::auto_ptr< partDuration_type > x)
  {
    this->partDuration_.set (x);
  }

  const partType::partId_optional& partType::
  partId () const
  {
    return this->partId_;
  }

  partType::partId_optional& partType::
  partId ()
  {
    return this->partId_;
  }

  void partType::
  partId (const partId_type& x)
  {
    this->partId_.set (x);
  }

  void partType::
  partId (const partId_optional& x)
  {
    this->partId_ = x;
  }

  void partType::
  partId (::std::auto_ptr< partId_type > x)
  {
    this->partId_.set (x);
  }

  const partType::partName_optional& partType::
  partName () const
  {
    return this->partName_;
  }

  partType::partName_optional& partType::
  partName ()
  {
    return this->partName_;
  }

  void partType::
  partName (const partName_type& x)
  {
    this->partName_.set (x);
  }

  void partType::
  partName (const partName_optional& x)
  {
    this->partName_ = x;
  }

  void partType::
  partName (::std::auto_ptr< partName_type > x)
  {
    this->partName_.set (x);
  }

  const partType::partDefinition_optional& partType::
  partDefinition () const
  {
    return this->partDefinition_;
  }

  partType::partDefinition_optional& partType::
  partDefinition ()
  {
    return this->partDefinition_;
  }

  void partType::
  partDefinition (const partDefinition_type& x)
  {
    this->partDefinition_.set (x);
  }

  void partType::
  partDefinition (const partDefinition_optional& x)
  {
    this->partDefinition_ = x;
  }

  void partType::
  partDefinition (::std::auto_ptr< partDefinition_type > x)
  {
    this->partDefinition_.set (x);
  }

  const partType::partNumber_optional& partType::
  partNumber () const
  {
    return this->partNumber_;
  }

  partType::partNumber_optional& partType::
  partNumber ()
  {
    return this->partNumber_;
  }

  void partType::
  partNumber (const partNumber_type& x)
  {
    this->partNumber_.set (x);
  }

  void partType::
  partNumber (const partNumber_optional& x)
  {
    this->partNumber_ = x;
  }

  const partType::partTotalNumber_optional& partType::
  partTotalNumber () const
  {
    return this->partTotalNumber_;
  }

  partType::partTotalNumber_optional& partType::
  partTotalNumber ()
  {
    return this->partTotalNumber_;
  }

  void partType::
  partTotalNumber (const partTotalNumber_type& x)
  {
    this->partTotalNumber_.set (x);
  }

  void partType::
  partTotalNumber (const partTotalNumber_optional& x)
  {
    this->partTotalNumber_ = x;
  }

  const partType::typeLabel_optional& partType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  partType::typeLabel_optional& partType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void partType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void partType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void partType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const partType::typeDefinition_optional& partType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  partType::typeDefinition_optional& partType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void partType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void partType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void partType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const partType::typeLink_optional& partType::
  typeLink () const
  {
    return this->typeLink_;
  }

  partType::typeLink_optional& partType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void partType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void partType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void partType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const partType::typeLanguage_optional& partType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  partType::typeLanguage_optional& partType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void partType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void partType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void partType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // titleType
  // 

  const titleType::title_sequence& titleType::
  title () const
  {
    return this->title_;
  }

  titleType::title_sequence& titleType::
  title ()
  {
    return this->title_;
  }

  void titleType::
  title (const title_sequence& s)
  {
    this->title_ = s;
  }

  const titleType::attributiondate_optional& titleType::
  attributiondate () const
  {
    return this->attributiondate_;
  }

  titleType::attributiondate_optional& titleType::
  attributiondate ()
  {
    return this->attributiondate_;
  }

  void titleType::
  attributiondate (const attributiondate_type& x)
  {
    this->attributiondate_.set (x);
  }

  void titleType::
  attributiondate (const attributiondate_optional& x)
  {
    this->attributiondate_ = x;
  }

  void titleType::
  attributiondate (::std::auto_ptr< attributiondate_type > x)
  {
    this->attributiondate_.set (x);
  }

  const titleType::note_optional& titleType::
  note () const
  {
    return this->note_;
  }

  titleType::note_optional& titleType::
  note ()
  {
    return this->note_;
  }

  void titleType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void titleType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void titleType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // alternativeTitleType
  // 

  const alternativeTitleType::title_sequence& alternativeTitleType::
  title () const
  {
    return this->title_;
  }

  alternativeTitleType::title_sequence& alternativeTitleType::
  title ()
  {
    return this->title_;
  }

  void alternativeTitleType::
  title (const title_sequence& s)
  {
    this->title_ = s;
  }

  const alternativeTitleType::typeLabel_optional& alternativeTitleType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  alternativeTitleType::typeLabel_optional& alternativeTitleType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void alternativeTitleType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void alternativeTitleType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void alternativeTitleType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const alternativeTitleType::typeDefinition_optional& alternativeTitleType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  alternativeTitleType::typeDefinition_optional& alternativeTitleType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void alternativeTitleType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void alternativeTitleType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void alternativeTitleType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const alternativeTitleType::typeLink_optional& alternativeTitleType::
  typeLink () const
  {
    return this->typeLink_;
  }

  alternativeTitleType::typeLink_optional& alternativeTitleType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void alternativeTitleType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void alternativeTitleType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void alternativeTitleType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const alternativeTitleType::typeLanguage_optional& alternativeTitleType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  alternativeTitleType::typeLanguage_optional& alternativeTitleType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void alternativeTitleType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void alternativeTitleType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void alternativeTitleType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const alternativeTitleType::statusLabel_optional& alternativeTitleType::
  statusLabel () const
  {
    return this->statusLabel_;
  }

  alternativeTitleType::statusLabel_optional& alternativeTitleType::
  statusLabel ()
  {
    return this->statusLabel_;
  }

  void alternativeTitleType::
  statusLabel (const statusLabel_type& x)
  {
    this->statusLabel_.set (x);
  }

  void alternativeTitleType::
  statusLabel (const statusLabel_optional& x)
  {
    this->statusLabel_ = x;
  }

  void alternativeTitleType::
  statusLabel (::std::auto_ptr< statusLabel_type > x)
  {
    this->statusLabel_.set (x);
  }

  const alternativeTitleType::statusDefinition_optional& alternativeTitleType::
  statusDefinition () const
  {
    return this->statusDefinition_;
  }

  alternativeTitleType::statusDefinition_optional& alternativeTitleType::
  statusDefinition ()
  {
    return this->statusDefinition_;
  }

  void alternativeTitleType::
  statusDefinition (const statusDefinition_type& x)
  {
    this->statusDefinition_.set (x);
  }

  void alternativeTitleType::
  statusDefinition (const statusDefinition_optional& x)
  {
    this->statusDefinition_ = x;
  }

  void alternativeTitleType::
  statusDefinition (::std::auto_ptr< statusDefinition_type > x)
  {
    this->statusDefinition_.set (x);
  }

  const alternativeTitleType::statusLink_optional& alternativeTitleType::
  statusLink () const
  {
    return this->statusLink_;
  }

  alternativeTitleType::statusLink_optional& alternativeTitleType::
  statusLink ()
  {
    return this->statusLink_;
  }

  void alternativeTitleType::
  statusLink (const statusLink_type& x)
  {
    this->statusLink_.set (x);
  }

  void alternativeTitleType::
  statusLink (const statusLink_optional& x)
  {
    this->statusLink_ = x;
  }

  void alternativeTitleType::
  statusLink (::std::auto_ptr< statusLink_type > x)
  {
    this->statusLink_.set (x);
  }

  const alternativeTitleType::statusLanguage_optional& alternativeTitleType::
  statusLanguage () const
  {
    return this->statusLanguage_;
  }

  alternativeTitleType::statusLanguage_optional& alternativeTitleType::
  statusLanguage ()
  {
    return this->statusLanguage_;
  }

  void alternativeTitleType::
  statusLanguage (const statusLanguage_type& x)
  {
    this->statusLanguage_.set (x);
  }

  void alternativeTitleType::
  statusLanguage (const statusLanguage_optional& x)
  {
    this->statusLanguage_ = x;
  }

  void alternativeTitleType::
  statusLanguage (::std::auto_ptr< statusLanguage_type > x)
  {
    this->statusLanguage_.set (x);
  }

  const alternativeTitleType::startYear_optional& alternativeTitleType::
  startYear () const
  {
    return this->startYear_;
  }

  alternativeTitleType::startYear_optional& alternativeTitleType::
  startYear ()
  {
    return this->startYear_;
  }

  void alternativeTitleType::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void alternativeTitleType::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void alternativeTitleType::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const alternativeTitleType::startDate_optional& alternativeTitleType::
  startDate () const
  {
    return this->startDate_;
  }

  alternativeTitleType::startDate_optional& alternativeTitleType::
  startDate ()
  {
    return this->startDate_;
  }

  void alternativeTitleType::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void alternativeTitleType::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void alternativeTitleType::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const alternativeTitleType::startTime_optional& alternativeTitleType::
  startTime () const
  {
    return this->startTime_;
  }

  alternativeTitleType::startTime_optional& alternativeTitleType::
  startTime ()
  {
    return this->startTime_;
  }

  void alternativeTitleType::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void alternativeTitleType::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void alternativeTitleType::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const alternativeTitleType::endYear_optional& alternativeTitleType::
  endYear () const
  {
    return this->endYear_;
  }

  alternativeTitleType::endYear_optional& alternativeTitleType::
  endYear ()
  {
    return this->endYear_;
  }

  void alternativeTitleType::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void alternativeTitleType::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void alternativeTitleType::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const alternativeTitleType::endDate_optional& alternativeTitleType::
  endDate () const
  {
    return this->endDate_;
  }

  alternativeTitleType::endDate_optional& alternativeTitleType::
  endDate ()
  {
    return this->endDate_;
  }

  void alternativeTitleType::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void alternativeTitleType::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void alternativeTitleType::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const alternativeTitleType::endTime_optional& alternativeTitleType::
  endTime () const
  {
    return this->endTime_;
  }

  alternativeTitleType::endTime_optional& alternativeTitleType::
  endTime ()
  {
    return this->endTime_;
  }

  void alternativeTitleType::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void alternativeTitleType::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void alternativeTitleType::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const alternativeTitleType::note_optional& alternativeTitleType::
  note () const
  {
    return this->note_;
  }

  alternativeTitleType::note_optional& alternativeTitleType::
  note ()
  {
    return this->note_;
  }

  void alternativeTitleType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void alternativeTitleType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void alternativeTitleType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // identifierType
  // 

  const identifierType::identifier_type& identifierType::
  identifier () const
  {
    return this->identifier_.get ();
  }

  identifierType::identifier_type& identifierType::
  identifier ()
  {
    return this->identifier_.get ();
  }

  void identifierType::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void identifierType::
  identifier (::std::auto_ptr< identifier_type > x)
  {
    this->identifier_.set (x);
  }

  const identifierType::attributor_optional& identifierType::
  attributor () const
  {
    return this->attributor_;
  }

  identifierType::attributor_optional& identifierType::
  attributor ()
  {
    return this->attributor_;
  }

  void identifierType::
  attributor (const attributor_type& x)
  {
    this->attributor_.set (x);
  }

  void identifierType::
  attributor (const attributor_optional& x)
  {
    this->attributor_ = x;
  }

  void identifierType::
  attributor (::std::auto_ptr< attributor_type > x)
  {
    this->attributor_.set (x);
  }

  const identifierType::typeLabel_optional& identifierType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  identifierType::typeLabel_optional& identifierType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void identifierType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void identifierType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void identifierType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const identifierType::typeDefinition_optional& identifierType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  identifierType::typeDefinition_optional& identifierType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void identifierType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void identifierType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void identifierType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const identifierType::typeLink_optional& identifierType::
  typeLink () const
  {
    return this->typeLink_;
  }

  identifierType::typeLink_optional& identifierType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void identifierType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void identifierType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void identifierType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const identifierType::typeLanguage_optional& identifierType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  identifierType::typeLanguage_optional& identifierType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void identifierType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void identifierType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void identifierType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const identifierType::formatLabel_optional& identifierType::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  identifierType::formatLabel_optional& identifierType::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void identifierType::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void identifierType::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void identifierType::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const identifierType::formatDefinition_optional& identifierType::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  identifierType::formatDefinition_optional& identifierType::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void identifierType::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void identifierType::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void identifierType::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const identifierType::formatLink_optional& identifierType::
  formatLink () const
  {
    return this->formatLink_;
  }

  identifierType::formatLink_optional& identifierType::
  formatLink ()
  {
    return this->formatLink_;
  }

  void identifierType::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void identifierType::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void identifierType::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const identifierType::formatLanguage_optional& identifierType::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  identifierType::formatLanguage_optional& identifierType::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void identifierType::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void identifierType::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void identifierType::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }

  const identifierType::note_optional& identifierType::
  note () const
  {
    return this->note_;
  }

  identifierType::note_optional& identifierType::
  note ()
  {
    return this->note_;
  }

  void identifierType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void identifierType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void identifierType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // subjectType
  // 

  const subjectType::subject_sequence& subjectType::
  subject () const
  {
    return this->subject_;
  }

  subjectType::subject_sequence& subjectType::
  subject ()
  {
    return this->subject_;
  }

  void subjectType::
  subject (const subject_sequence& s)
  {
    this->subject_ = s;
  }

  const subjectType::subjectCode_optional& subjectType::
  subjectCode () const
  {
    return this->subjectCode_;
  }

  subjectType::subjectCode_optional& subjectType::
  subjectCode ()
  {
    return this->subjectCode_;
  }

  void subjectType::
  subjectCode (const subjectCode_type& x)
  {
    this->subjectCode_.set (x);
  }

  void subjectType::
  subjectCode (const subjectCode_optional& x)
  {
    this->subjectCode_ = x;
  }

  void subjectType::
  subjectCode (::std::auto_ptr< subjectCode_type > x)
  {
    this->subjectCode_.set (x);
  }

  const subjectType::subjectDefinition_sequence& subjectType::
  subjectDefinition () const
  {
    return this->subjectDefinition_;
  }

  subjectType::subjectDefinition_sequence& subjectType::
  subjectDefinition ()
  {
    return this->subjectDefinition_;
  }

  void subjectType::
  subjectDefinition (const subjectDefinition_sequence& s)
  {
    this->subjectDefinition_ = s;
  }

  const subjectType::attributor_optional& subjectType::
  attributor () const
  {
    return this->attributor_;
  }

  subjectType::attributor_optional& subjectType::
  attributor ()
  {
    return this->attributor_;
  }

  void subjectType::
  attributor (const attributor_type& x)
  {
    this->attributor_.set (x);
  }

  void subjectType::
  attributor (const attributor_optional& x)
  {
    this->attributor_ = x;
  }

  void subjectType::
  attributor (::std::auto_ptr< attributor_type > x)
  {
    this->attributor_.set (x);
  }

  const subjectType::typeLabel_optional& subjectType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  subjectType::typeLabel_optional& subjectType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void subjectType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void subjectType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void subjectType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const subjectType::typeDefinition_optional& subjectType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  subjectType::typeDefinition_optional& subjectType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void subjectType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void subjectType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void subjectType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const subjectType::typeLink_optional& subjectType::
  typeLink () const
  {
    return this->typeLink_;
  }

  subjectType::typeLink_optional& subjectType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void subjectType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void subjectType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void subjectType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const subjectType::typeLanguage_optional& subjectType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  subjectType::typeLanguage_optional& subjectType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void subjectType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void subjectType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void subjectType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const subjectType::note_optional& subjectType::
  note () const
  {
    return this->note_;
  }

  subjectType::note_optional& subjectType::
  note ()
  {
    return this->note_;
  }

  void subjectType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void subjectType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void subjectType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // typeType
  // 

  const typeType::type_sequence& typeType::
  type () const
  {
    return this->type_;
  }

  typeType::type_sequence& typeType::
  type ()
  {
    return this->type_;
  }

  void typeType::
  type (const type_sequence& s)
  {
    this->type_ = s;
  }

  const typeType::genre_sequence& typeType::
  genre () const
  {
    return this->genre_;
  }

  typeType::genre_sequence& typeType::
  genre ()
  {
    return this->genre_;
  }

  void typeType::
  genre (const genre_sequence& s)
  {
    this->genre_ = s;
  }

  const typeType::objectType_sequence& typeType::
  objectType () const
  {
    return this->objectType_;
  }

  typeType::objectType_sequence& typeType::
  objectType ()
  {
    return this->objectType_;
  }

  void typeType::
  objectType (const objectType_sequence& s)
  {
    this->objectType_ = s;
  }

  const typeType::targetAudience_sequence& typeType::
  targetAudience () const
  {
    return this->targetAudience_;
  }

  typeType::targetAudience_sequence& typeType::
  targetAudience ()
  {
    return this->targetAudience_;
  }

  void typeType::
  targetAudience (const targetAudience_sequence& s)
  {
    this->targetAudience_ = s;
  }

  const typeType::note_optional& typeType::
  note () const
  {
    return this->note_;
  }

  typeType::note_optional& typeType::
  note ()
  {
    return this->note_;
  }

  void typeType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void typeType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void typeType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // descriptionType
  // 

  const descriptionType::description_sequence& descriptionType::
  description () const
  {
    return this->description_;
  }

  descriptionType::description_sequence& descriptionType::
  description ()
  {
    return this->description_;
  }

  void descriptionType::
  description (const description_sequence& s)
  {
    this->description_ = s;
  }

  const descriptionType::typeLabel_optional& descriptionType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  descriptionType::typeLabel_optional& descriptionType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void descriptionType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void descriptionType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void descriptionType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const descriptionType::typeDefinition_optional& descriptionType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  descriptionType::typeDefinition_optional& descriptionType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void descriptionType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void descriptionType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void descriptionType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const descriptionType::typeLink_optional& descriptionType::
  typeLink () const
  {
    return this->typeLink_;
  }

  descriptionType::typeLink_optional& descriptionType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void descriptionType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void descriptionType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void descriptionType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const descriptionType::typeLanguage_optional& descriptionType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  descriptionType::typeLanguage_optional& descriptionType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void descriptionType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void descriptionType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void descriptionType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const descriptionType::note_optional& descriptionType::
  note () const
  {
    return this->note_;
  }

  descriptionType::note_optional& descriptionType::
  note ()
  {
    return this->note_;
  }

  void descriptionType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void descriptionType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void descriptionType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // coverageType
  // 

  const coverageType::coverage_optional& coverageType::
  coverage () const
  {
    return this->coverage_;
  }

  coverageType::coverage_optional& coverageType::
  coverage ()
  {
    return this->coverage_;
  }

  void coverageType::
  coverage (const coverage_type& x)
  {
    this->coverage_.set (x);
  }

  void coverageType::
  coverage (const coverage_optional& x)
  {
    this->coverage_ = x;
  }

  void coverageType::
  coverage (::std::auto_ptr< coverage_type > x)
  {
    this->coverage_.set (x);
  }

  const coverageType::temporal_optional& coverageType::
  temporal () const
  {
    return this->temporal_;
  }

  coverageType::temporal_optional& coverageType::
  temporal ()
  {
    return this->temporal_;
  }

  void coverageType::
  temporal (const temporal_type& x)
  {
    this->temporal_.set (x);
  }

  void coverageType::
  temporal (const temporal_optional& x)
  {
    this->temporal_ = x;
  }

  void coverageType::
  temporal (::std::auto_ptr< temporal_type > x)
  {
    this->temporal_.set (x);
  }

  const coverageType::spatial_optional& coverageType::
  spatial () const
  {
    return this->spatial_;
  }

  coverageType::spatial_optional& coverageType::
  spatial ()
  {
    return this->spatial_;
  }

  void coverageType::
  spatial (const spatial_type& x)
  {
    this->spatial_.set (x);
  }

  void coverageType::
  spatial (const spatial_optional& x)
  {
    this->spatial_ = x;
  }

  void coverageType::
  spatial (::std::auto_ptr< spatial_type > x)
  {
    this->spatial_.set (x);
  }


  // locationType
  // 

  const locationType::name_optional& locationType::
  name () const
  {
    return this->name_;
  }

  locationType::name_optional& locationType::
  name ()
  {
    return this->name_;
  }

  void locationType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void locationType::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void locationType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const locationType::coordinates_optional& locationType::
  coordinates () const
  {
    return this->coordinates_;
  }

  locationType::coordinates_optional& locationType::
  coordinates ()
  {
    return this->coordinates_;
  }

  void locationType::
  coordinates (const coordinates_type& x)
  {
    this->coordinates_.set (x);
  }

  void locationType::
  coordinates (const coordinates_optional& x)
  {
    this->coordinates_ = x;
  }

  void locationType::
  coordinates (::std::auto_ptr< coordinates_type > x)
  {
    this->coordinates_.set (x);
  }

  const locationType::code_optional& locationType::
  code () const
  {
    return this->code_;
  }

  locationType::code_optional& locationType::
  code ()
  {
    return this->code_;
  }

  void locationType::
  code (const code_type& x)
  {
    this->code_.set (x);
  }

  void locationType::
  code (const code_optional& x)
  {
    this->code_ = x;
  }

  void locationType::
  code (::std::auto_ptr< code_type > x)
  {
    this->code_.set (x);
  }

  const locationType::region_optional& locationType::
  region () const
  {
    return this->region_;
  }

  locationType::region_optional& locationType::
  region ()
  {
    return this->region_;
  }

  void locationType::
  region (const region_type& x)
  {
    this->region_.set (x);
  }

  void locationType::
  region (const region_optional& x)
  {
    this->region_ = x;
  }

  void locationType::
  region (::std::auto_ptr< region_type > x)
  {
    this->region_.set (x);
  }

  const locationType::typeLabel_optional& locationType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  locationType::typeLabel_optional& locationType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void locationType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void locationType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void locationType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const locationType::typeDefinition_optional& locationType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  locationType::typeDefinition_optional& locationType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void locationType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void locationType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void locationType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const locationType::typeLink_optional& locationType::
  typeLink () const
  {
    return this->typeLink_;
  }

  locationType::typeLink_optional& locationType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void locationType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void locationType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void locationType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const locationType::typeLanguage_optional& locationType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  locationType::typeLanguage_optional& locationType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void locationType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void locationType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void locationType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const locationType::note_optional& locationType::
  note () const
  {
    return this->note_;
  }

  locationType::note_optional& locationType::
  note ()
  {
    return this->note_;
  }

  void locationType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void locationType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void locationType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }

  const locationType::locationId_optional& locationType::
  locationId () const
  {
    return this->locationId_;
  }

  locationType::locationId_optional& locationType::
  locationId ()
  {
    return this->locationId_;
  }

  void locationType::
  locationId (const locationId_type& x)
  {
    this->locationId_.set (x);
  }

  void locationType::
  locationId (const locationId_optional& x)
  {
    this->locationId_ = x;
  }

  void locationType::
  locationId (::std::auto_ptr< locationId_type > x)
  {
    this->locationId_.set (x);
  }


  // periodOfTimeType
  // 

  const periodOfTimeType::periodName_optional& periodOfTimeType::
  periodName () const
  {
    return this->periodName_;
  }

  periodOfTimeType::periodName_optional& periodOfTimeType::
  periodName ()
  {
    return this->periodName_;
  }

  void periodOfTimeType::
  periodName (const periodName_type& x)
  {
    this->periodName_.set (x);
  }

  void periodOfTimeType::
  periodName (const periodName_optional& x)
  {
    this->periodName_ = x;
  }

  void periodOfTimeType::
  periodName (::std::auto_ptr< periodName_type > x)
  {
    this->periodName_.set (x);
  }

  const periodOfTimeType::startYear_optional& periodOfTimeType::
  startYear () const
  {
    return this->startYear_;
  }

  periodOfTimeType::startYear_optional& periodOfTimeType::
  startYear ()
  {
    return this->startYear_;
  }

  void periodOfTimeType::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void periodOfTimeType::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void periodOfTimeType::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const periodOfTimeType::startDate_optional& periodOfTimeType::
  startDate () const
  {
    return this->startDate_;
  }

  periodOfTimeType::startDate_optional& periodOfTimeType::
  startDate ()
  {
    return this->startDate_;
  }

  void periodOfTimeType::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void periodOfTimeType::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void periodOfTimeType::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const periodOfTimeType::startTime_optional& periodOfTimeType::
  startTime () const
  {
    return this->startTime_;
  }

  periodOfTimeType::startTime_optional& periodOfTimeType::
  startTime ()
  {
    return this->startTime_;
  }

  void periodOfTimeType::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void periodOfTimeType::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void periodOfTimeType::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const periodOfTimeType::endYear_optional& periodOfTimeType::
  endYear () const
  {
    return this->endYear_;
  }

  periodOfTimeType::endYear_optional& periodOfTimeType::
  endYear ()
  {
    return this->endYear_;
  }

  void periodOfTimeType::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void periodOfTimeType::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void periodOfTimeType::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const periodOfTimeType::endDate_optional& periodOfTimeType::
  endDate () const
  {
    return this->endDate_;
  }

  periodOfTimeType::endDate_optional& periodOfTimeType::
  endDate ()
  {
    return this->endDate_;
  }

  void periodOfTimeType::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void periodOfTimeType::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void periodOfTimeType::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const periodOfTimeType::endTime_optional& periodOfTimeType::
  endTime () const
  {
    return this->endTime_;
  }

  periodOfTimeType::endTime_optional& periodOfTimeType::
  endTime ()
  {
    return this->endTime_;
  }

  void periodOfTimeType::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void periodOfTimeType::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void periodOfTimeType::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }


  // rightsType
  // 

  const rightsType::rights_sequence& rightsType::
  rights () const
  {
    return this->rights_;
  }

  rightsType::rights_sequence& rightsType::
  rights ()
  {
    return this->rights_;
  }

  void rightsType::
  rights (const rights_sequence& s)
  {
    this->rights_ = s;
  }

  const rightsType::rightsLink_optional& rightsType::
  rightsLink () const
  {
    return this->rightsLink_;
  }

  rightsType::rightsLink_optional& rightsType::
  rightsLink ()
  {
    return this->rightsLink_;
  }

  void rightsType::
  rightsLink (const rightsLink_type& x)
  {
    this->rightsLink_.set (x);
  }

  void rightsType::
  rightsLink (const rightsLink_optional& x)
  {
    this->rightsLink_ = x;
  }

  void rightsType::
  rightsLink (::std::auto_ptr< rightsLink_type > x)
  {
    this->rightsLink_.set (x);
  }

  const rightsType::rightsHolder_sequence& rightsType::
  rightsHolder () const
  {
    return this->rightsHolder_;
  }

  rightsType::rightsHolder_sequence& rightsType::
  rightsHolder ()
  {
    return this->rightsHolder_;
  }

  void rightsType::
  rightsHolder (const rightsHolder_sequence& s)
  {
    this->rightsHolder_ = s;
  }

  const rightsType::exploitationIssues_sequence& rightsType::
  exploitationIssues () const
  {
    return this->exploitationIssues_;
  }

  rightsType::exploitationIssues_sequence& rightsType::
  exploitationIssues ()
  {
    return this->exploitationIssues_;
  }

  void rightsType::
  exploitationIssues (const exploitationIssues_sequence& s)
  {
    this->exploitationIssues_ = s;
  }

  const rightsType::copyrightStatement_sequence& rightsType::
  copyrightStatement () const
  {
    return this->copyrightStatement_;
  }

  rightsType::copyrightStatement_sequence& rightsType::
  copyrightStatement ()
  {
    return this->copyrightStatement_;
  }

  void rightsType::
  copyrightStatement (const copyrightStatement_sequence& s)
  {
    this->copyrightStatement_ = s;
  }

  const rightsType::coverage_optional& rightsType::
  coverage () const
  {
    return this->coverage_;
  }

  rightsType::coverage_optional& rightsType::
  coverage ()
  {
    return this->coverage_;
  }

  void rightsType::
  coverage (const coverage_type& x)
  {
    this->coverage_.set (x);
  }

  void rightsType::
  coverage (const coverage_optional& x)
  {
    this->coverage_ = x;
  }

  void rightsType::
  coverage (::std::auto_ptr< coverage_type > x)
  {
    this->coverage_.set (x);
  }

  const rightsType::rightsClearanceFlag_optional& rightsType::
  rightsClearanceFlag () const
  {
    return this->rightsClearanceFlag_;
  }

  rightsType::rightsClearanceFlag_optional& rightsType::
  rightsClearanceFlag ()
  {
    return this->rightsClearanceFlag_;
  }

  void rightsType::
  rightsClearanceFlag (const rightsClearanceFlag_type& x)
  {
    this->rightsClearanceFlag_.set (x);
  }

  void rightsType::
  rightsClearanceFlag (const rightsClearanceFlag_optional& x)
  {
    this->rightsClearanceFlag_ = x;
  }

  const rightsType::disclaimer_sequence& rightsType::
  disclaimer () const
  {
    return this->disclaimer_;
  }

  rightsType::disclaimer_sequence& rightsType::
  disclaimer ()
  {
    return this->disclaimer_;
  }

  void rightsType::
  disclaimer (const disclaimer_sequence& s)
  {
    this->disclaimer_ = s;
  }

  const rightsType::rightsAttributedId_sequence& rightsType::
  rightsAttributedId () const
  {
    return this->rightsAttributedId_;
  }

  rightsType::rightsAttributedId_sequence& rightsType::
  rightsAttributedId ()
  {
    return this->rightsAttributedId_;
  }

  void rightsType::
  rightsAttributedId (const rightsAttributedId_sequence& s)
  {
    this->rightsAttributedId_ = s;
  }

  const rightsType::contactDetails_sequence& rightsType::
  contactDetails () const
  {
    return this->contactDetails_;
  }

  rightsType::contactDetails_sequence& rightsType::
  contactDetails ()
  {
    return this->contactDetails_;
  }

  void rightsType::
  contactDetails (const contactDetails_sequence& s)
  {
    this->contactDetails_ = s;
  }

  const rightsType::typeLabel_optional& rightsType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  rightsType::typeLabel_optional& rightsType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void rightsType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void rightsType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void rightsType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const rightsType::typeDefinition_optional& rightsType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  rightsType::typeDefinition_optional& rightsType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void rightsType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void rightsType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void rightsType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const rightsType::typeLink_optional& rightsType::
  typeLink () const
  {
    return this->typeLink_;
  }

  rightsType::typeLink_optional& rightsType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void rightsType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void rightsType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void rightsType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const rightsType::typeLanguage_optional& rightsType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  rightsType::typeLanguage_optional& rightsType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void rightsType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void rightsType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void rightsType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const rightsType::note_optional& rightsType::
  note () const
  {
    return this->note_;
  }

  rightsType::note_optional& rightsType::
  note ()
  {
    return this->note_;
  }

  void rightsType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void rightsType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void rightsType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }

  const rightsType::formatIDRefs_optional& rightsType::
  formatIDRefs () const
  {
    return this->formatIDRefs_;
  }

  rightsType::formatIDRefs_optional& rightsType::
  formatIDRefs ()
  {
    return this->formatIDRefs_;
  }

  void rightsType::
  formatIDRefs (const formatIDRefs_type& x)
  {
    this->formatIDRefs_.set (x);
  }

  void rightsType::
  formatIDRefs (const formatIDRefs_optional& x)
  {
    this->formatIDRefs_ = x;
  }

  void rightsType::
  formatIDRefs (::std::auto_ptr< formatIDRefs_type > x)
  {
    this->formatIDRefs_.set (x);
  }

  const rightsType::rightsID_optional& rightsType::
  rightsID () const
  {
    return this->rightsID_;
  }

  rightsType::rightsID_optional& rightsType::
  rightsID ()
  {
    return this->rightsID_;
  }

  void rightsType::
  rightsID (const rightsID_type& x)
  {
    this->rightsID_.set (x);
  }

  void rightsType::
  rightsID (const rightsID_optional& x)
  {
    this->rightsID_ = x;
  }

  void rightsType::
  rightsID (::std::auto_ptr< rightsID_type > x)
  {
    this->rightsID_.set (x);
  }


  // relationType
  // 

  const relationType::relation_optional& relationType::
  relation () const
  {
    return this->relation_;
  }

  relationType::relation_optional& relationType::
  relation ()
  {
    return this->relation_;
  }

  void relationType::
  relation (const relation_type& x)
  {
    this->relation_.set (x);
  }

  void relationType::
  relation (const relation_optional& x)
  {
    this->relation_ = x;
  }

  void relationType::
  relation (::std::auto_ptr< relation_type > x)
  {
    this->relation_.set (x);
  }

  const relationType::relationIdentifier_optional& relationType::
  relationIdentifier () const
  {
    return this->relationIdentifier_;
  }

  relationType::relationIdentifier_optional& relationType::
  relationIdentifier ()
  {
    return this->relationIdentifier_;
  }

  void relationType::
  relationIdentifier (const relationIdentifier_type& x)
  {
    this->relationIdentifier_.set (x);
  }

  void relationType::
  relationIdentifier (const relationIdentifier_optional& x)
  {
    this->relationIdentifier_ = x;
  }

  void relationType::
  relationIdentifier (::std::auto_ptr< relationIdentifier_type > x)
  {
    this->relationIdentifier_.set (x);
  }

  const relationType::relationLink_optional& relationType::
  relationLink () const
  {
    return this->relationLink_;
  }

  relationType::relationLink_optional& relationType::
  relationLink ()
  {
    return this->relationLink_;
  }

  void relationType::
  relationLink (const relationLink_type& x)
  {
    this->relationLink_.set (x);
  }

  void relationType::
  relationLink (const relationLink_optional& x)
  {
    this->relationLink_ = x;
  }

  void relationType::
  relationLink (::std::auto_ptr< relationLink_type > x)
  {
    this->relationLink_.set (x);
  }

  const relationType::typeLabel_optional& relationType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  relationType::typeLabel_optional& relationType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void relationType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void relationType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void relationType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const relationType::typeDefinition_optional& relationType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  relationType::typeDefinition_optional& relationType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void relationType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void relationType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void relationType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const relationType::typeLink_optional& relationType::
  typeLink () const
  {
    return this->typeLink_;
  }

  relationType::typeLink_optional& relationType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void relationType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void relationType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void relationType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const relationType::typeLanguage_optional& relationType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  relationType::typeLanguage_optional& relationType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void relationType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void relationType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void relationType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const relationType::runningOrderNumber_optional& relationType::
  runningOrderNumber () const
  {
    return this->runningOrderNumber_;
  }

  relationType::runningOrderNumber_optional& relationType::
  runningOrderNumber ()
  {
    return this->runningOrderNumber_;
  }

  void relationType::
  runningOrderNumber (const runningOrderNumber_type& x)
  {
    this->runningOrderNumber_.set (x);
  }

  void relationType::
  runningOrderNumber (const runningOrderNumber_optional& x)
  {
    this->runningOrderNumber_ = x;
  }

  const relationType::totalNumberOfGroupMembers_optional& relationType::
  totalNumberOfGroupMembers () const
  {
    return this->totalNumberOfGroupMembers_;
  }

  relationType::totalNumberOfGroupMembers_optional& relationType::
  totalNumberOfGroupMembers ()
  {
    return this->totalNumberOfGroupMembers_;
  }

  void relationType::
  totalNumberOfGroupMembers (const totalNumberOfGroupMembers_type& x)
  {
    this->totalNumberOfGroupMembers_.set (x);
  }

  void relationType::
  totalNumberOfGroupMembers (const totalNumberOfGroupMembers_optional& x)
  {
    this->totalNumberOfGroupMembers_ = x;
  }

  const relationType::orderedGroupFlag_optional& relationType::
  orderedGroupFlag () const
  {
    return this->orderedGroupFlag_;
  }

  relationType::orderedGroupFlag_optional& relationType::
  orderedGroupFlag ()
  {
    return this->orderedGroupFlag_;
  }

  void relationType::
  orderedGroupFlag (const orderedGroupFlag_type& x)
  {
    this->orderedGroupFlag_.set (x);
  }

  void relationType::
  orderedGroupFlag (const orderedGroupFlag_optional& x)
  {
    this->orderedGroupFlag_ = x;
  }

  const relationType::note_optional& relationType::
  note () const
  {
    return this->note_;
  }

  relationType::note_optional& relationType::
  note ()
  {
    return this->note_;
  }

  void relationType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void relationType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void relationType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // languageType
  // 

  const languageType::language_optional& languageType::
  language () const
  {
    return this->language_;
  }

  languageType::language_optional& languageType::
  language ()
  {
    return this->language_;
  }

  void languageType::
  language (const language_type& x)
  {
    this->language_.set (x);
  }

  void languageType::
  language (const language_optional& x)
  {
    this->language_ = x;
  }

  void languageType::
  language (::std::auto_ptr< language_type > x)
  {
    this->language_.set (x);
  }

  const languageType::typeLabel_optional& languageType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  languageType::typeLabel_optional& languageType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void languageType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void languageType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void languageType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const languageType::typeDefinition_optional& languageType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  languageType::typeDefinition_optional& languageType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void languageType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void languageType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void languageType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const languageType::typeLink_optional& languageType::
  typeLink () const
  {
    return this->typeLink_;
  }

  languageType::typeLink_optional& languageType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void languageType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void languageType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void languageType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const languageType::typeLanguage_optional& languageType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  languageType::typeLanguage_optional& languageType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void languageType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void languageType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void languageType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const languageType::note_optional& languageType::
  note () const
  {
    return this->note_;
  }

  languageType::note_optional& languageType::
  note ()
  {
    return this->note_;
  }

  void languageType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void languageType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void languageType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }


  // dateType
  // 

  const dateType::date_sequence& dateType::
  date () const
  {
    return this->date_;
  }

  dateType::date_sequence& dateType::
  date ()
  {
    return this->date_;
  }

  void dateType::
  date (const date_sequence& s)
  {
    this->date_ = s;
  }

  const dateType::created_optional& dateType::
  created () const
  {
    return this->created_;
  }

  dateType::created_optional& dateType::
  created ()
  {
    return this->created_;
  }

  void dateType::
  created (const created_type& x)
  {
    this->created_.set (x);
  }

  void dateType::
  created (const created_optional& x)
  {
    this->created_ = x;
  }

  void dateType::
  created (::std::auto_ptr< created_type > x)
  {
    this->created_.set (x);
  }

  const dateType::issued_optional& dateType::
  issued () const
  {
    return this->issued_;
  }

  dateType::issued_optional& dateType::
  issued ()
  {
    return this->issued_;
  }

  void dateType::
  issued (const issued_type& x)
  {
    this->issued_.set (x);
  }

  void dateType::
  issued (const issued_optional& x)
  {
    this->issued_ = x;
  }

  void dateType::
  issued (::std::auto_ptr< issued_type > x)
  {
    this->issued_.set (x);
  }

  const dateType::modified_optional& dateType::
  modified () const
  {
    return this->modified_;
  }

  dateType::modified_optional& dateType::
  modified ()
  {
    return this->modified_;
  }

  void dateType::
  modified (const modified_type& x)
  {
    this->modified_.set (x);
  }

  void dateType::
  modified (const modified_optional& x)
  {
    this->modified_ = x;
  }

  void dateType::
  modified (::std::auto_ptr< modified_type > x)
  {
    this->modified_.set (x);
  }

  const dateType::digitised_optional& dateType::
  digitised () const
  {
    return this->digitised_;
  }

  dateType::digitised_optional& dateType::
  digitised ()
  {
    return this->digitised_;
  }

  void dateType::
  digitised (const digitised_type& x)
  {
    this->digitised_.set (x);
  }

  void dateType::
  digitised (const digitised_optional& x)
  {
    this->digitised_ = x;
  }

  void dateType::
  digitised (::std::auto_ptr< digitised_type > x)
  {
    this->digitised_.set (x);
  }

  const dateType::released_optional& dateType::
  released () const
  {
    return this->released_;
  }

  dateType::released_optional& dateType::
  released ()
  {
    return this->released_;
  }

  void dateType::
  released (const released_type& x)
  {
    this->released_.set (x);
  }

  void dateType::
  released (const released_optional& x)
  {
    this->released_ = x;
  }

  void dateType::
  released (::std::auto_ptr< released_type > x)
  {
    this->released_.set (x);
  }

  const dateType::copyrighted_optional& dateType::
  copyrighted () const
  {
    return this->copyrighted_;
  }

  dateType::copyrighted_optional& dateType::
  copyrighted ()
  {
    return this->copyrighted_;
  }

  void dateType::
  copyrighted (const copyrighted_type& x)
  {
    this->copyrighted_.set (x);
  }

  void dateType::
  copyrighted (const copyrighted_optional& x)
  {
    this->copyrighted_ = x;
  }

  void dateType::
  copyrighted (::std::auto_ptr< copyrighted_type > x)
  {
    this->copyrighted_.set (x);
  }

  const dateType::alternative_sequence& dateType::
  alternative () const
  {
    return this->alternative_;
  }

  dateType::alternative_sequence& dateType::
  alternative ()
  {
    return this->alternative_;
  }

  void dateType::
  alternative (const alternative_sequence& s)
  {
    this->alternative_ = s;
  }


  // publicationHistoryType
  // 

  const publicationHistoryType::publicationEvent_sequence& publicationHistoryType::
  publicationEvent () const
  {
    return this->publicationEvent_;
  }

  publicationHistoryType::publicationEvent_sequence& publicationHistoryType::
  publicationEvent ()
  {
    return this->publicationEvent_;
  }

  void publicationHistoryType::
  publicationEvent (const publicationEvent_sequence& s)
  {
    this->publicationEvent_ = s;
  }


  // publicationEventType
  // 

  const publicationEventType::publicationDate_optional& publicationEventType::
  publicationDate () const
  {
    return this->publicationDate_;
  }

  publicationEventType::publicationDate_optional& publicationEventType::
  publicationDate ()
  {
    return this->publicationDate_;
  }

  void publicationEventType::
  publicationDate (const publicationDate_type& x)
  {
    this->publicationDate_.set (x);
  }

  void publicationEventType::
  publicationDate (const publicationDate_optional& x)
  {
    this->publicationDate_ = x;
  }

  void publicationEventType::
  publicationDate (::std::auto_ptr< publicationDate_type > x)
  {
    this->publicationDate_.set (x);
  }

  const publicationEventType::publicationTime_optional& publicationEventType::
  publicationTime () const
  {
    return this->publicationTime_;
  }

  publicationEventType::publicationTime_optional& publicationEventType::
  publicationTime ()
  {
    return this->publicationTime_;
  }

  void publicationEventType::
  publicationTime (const publicationTime_type& x)
  {
    this->publicationTime_.set (x);
  }

  void publicationEventType::
  publicationTime (const publicationTime_optional& x)
  {
    this->publicationTime_ = x;
  }

  void publicationEventType::
  publicationTime (::std::auto_ptr< publicationTime_type > x)
  {
    this->publicationTime_.set (x);
  }

  const publicationEventType::publicationService_optional& publicationEventType::
  publicationService () const
  {
    return this->publicationService_;
  }

  publicationEventType::publicationService_optional& publicationEventType::
  publicationService ()
  {
    return this->publicationService_;
  }

  void publicationEventType::
  publicationService (const publicationService_type& x)
  {
    this->publicationService_.set (x);
  }

  void publicationEventType::
  publicationService (const publicationService_optional& x)
  {
    this->publicationService_ = x;
  }

  void publicationEventType::
  publicationService (::std::auto_ptr< publicationService_type > x)
  {
    this->publicationService_.set (x);
  }

  const publicationEventType::publicationMedium_optional& publicationEventType::
  publicationMedium () const
  {
    return this->publicationMedium_;
  }

  publicationEventType::publicationMedium_optional& publicationEventType::
  publicationMedium ()
  {
    return this->publicationMedium_;
  }

  void publicationEventType::
  publicationMedium (const publicationMedium_type& x)
  {
    this->publicationMedium_.set (x);
  }

  void publicationEventType::
  publicationMedium (const publicationMedium_optional& x)
  {
    this->publicationMedium_ = x;
  }

  void publicationEventType::
  publicationMedium (::std::auto_ptr< publicationMedium_type > x)
  {
    this->publicationMedium_.set (x);
  }

  const publicationEventType::publicationChannel_optional& publicationEventType::
  publicationChannel () const
  {
    return this->publicationChannel_;
  }

  publicationEventType::publicationChannel_optional& publicationEventType::
  publicationChannel ()
  {
    return this->publicationChannel_;
  }

  void publicationEventType::
  publicationChannel (const publicationChannel_type& x)
  {
    this->publicationChannel_.set (x);
  }

  void publicationEventType::
  publicationChannel (const publicationChannel_optional& x)
  {
    this->publicationChannel_ = x;
  }

  void publicationEventType::
  publicationChannel (::std::auto_ptr< publicationChannel_type > x)
  {
    this->publicationChannel_.set (x);
  }

  const publicationEventType::publicationRegion_sequence& publicationEventType::
  publicationRegion () const
  {
    return this->publicationRegion_;
  }

  publicationEventType::publicationRegion_sequence& publicationEventType::
  publicationRegion ()
  {
    return this->publicationRegion_;
  }

  void publicationEventType::
  publicationRegion (const publicationRegion_sequence& s)
  {
    this->publicationRegion_ = s;
  }

  const publicationEventType::firstShowing_optional& publicationEventType::
  firstShowing () const
  {
    return this->firstShowing_;
  }

  publicationEventType::firstShowing_optional& publicationEventType::
  firstShowing ()
  {
    return this->firstShowing_;
  }

  void publicationEventType::
  firstShowing (const firstShowing_type& x)
  {
    this->firstShowing_.set (x);
  }

  void publicationEventType::
  firstShowing (const firstShowing_optional& x)
  {
    this->firstShowing_ = x;
  }

  const publicationEventType::live_optional& publicationEventType::
  live () const
  {
    return this->live_;
  }

  publicationEventType::live_optional& publicationEventType::
  live ()
  {
    return this->live_;
  }

  void publicationEventType::
  live (const live_type& x)
  {
    this->live_.set (x);
  }

  void publicationEventType::
  live (const live_optional& x)
  {
    this->live_ = x;
  }

  const publicationEventType::free_optional& publicationEventType::
  free () const
  {
    return this->free_;
  }

  publicationEventType::free_optional& publicationEventType::
  free ()
  {
    return this->free_;
  }

  void publicationEventType::
  free (const free_type& x)
  {
    this->free_.set (x);
  }

  void publicationEventType::
  free (const free_optional& x)
  {
    this->free_ = x;
  }

  const publicationEventType::note_optional& publicationEventType::
  note () const
  {
    return this->note_;
  }

  publicationEventType::note_optional& publicationEventType::
  note ()
  {
    return this->note_;
  }

  void publicationEventType::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void publicationEventType::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void publicationEventType::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }

  const publicationEventType::formatIdRef_optional& publicationEventType::
  formatIdRef () const
  {
    return this->formatIdRef_;
  }

  publicationEventType::formatIdRef_optional& publicationEventType::
  formatIdRef ()
  {
    return this->formatIdRef_;
  }

  void publicationEventType::
  formatIdRef (const formatIdRef_type& x)
  {
    this->formatIdRef_.set (x);
  }

  void publicationEventType::
  formatIdRef (const formatIdRef_optional& x)
  {
    this->formatIdRef_ = x;
  }

  void publicationEventType::
  formatIdRef (::std::auto_ptr< formatIdRef_type > x)
  {
    this->formatIdRef_.set (x);
  }

  const publicationEventType::rightsIDRefs_optional& publicationEventType::
  rightsIDRefs () const
  {
    return this->rightsIDRefs_;
  }

  publicationEventType::rightsIDRefs_optional& publicationEventType::
  rightsIDRefs ()
  {
    return this->rightsIDRefs_;
  }

  void publicationEventType::
  rightsIDRefs (const rightsIDRefs_type& x)
  {
    this->rightsIDRefs_.set (x);
  }

  void publicationEventType::
  rightsIDRefs (const rightsIDRefs_optional& x)
  {
    this->rightsIDRefs_ = x;
  }

  void publicationEventType::
  rightsIDRefs (::std::auto_ptr< rightsIDRefs_type > x)
  {
    this->rightsIDRefs_.set (x);
  }


  // publicationServiceType
  // 

  const publicationServiceType::publicationServiceName_optional& publicationServiceType::
  publicationServiceName () const
  {
    return this->publicationServiceName_;
  }

  publicationServiceType::publicationServiceName_optional& publicationServiceType::
  publicationServiceName ()
  {
    return this->publicationServiceName_;
  }

  void publicationServiceType::
  publicationServiceName (const publicationServiceName_type& x)
  {
    this->publicationServiceName_.set (x);
  }

  void publicationServiceType::
  publicationServiceName (const publicationServiceName_optional& x)
  {
    this->publicationServiceName_ = x;
  }

  void publicationServiceType::
  publicationServiceName (::std::auto_ptr< publicationServiceName_type > x)
  {
    this->publicationServiceName_.set (x);
  }

  const publicationServiceType::publicationSource_optional& publicationServiceType::
  publicationSource () const
  {
    return this->publicationSource_;
  }

  publicationServiceType::publicationSource_optional& publicationServiceType::
  publicationSource ()
  {
    return this->publicationSource_;
  }

  void publicationServiceType::
  publicationSource (const publicationSource_type& x)
  {
    this->publicationSource_.set (x);
  }

  void publicationServiceType::
  publicationSource (const publicationSource_optional& x)
  {
    this->publicationSource_ = x;
  }

  void publicationServiceType::
  publicationSource (::std::auto_ptr< publicationSource_type > x)
  {
    this->publicationSource_.set (x);
  }


  // publicationMediumType
  // 

  const publicationMediumType::typeLabel_optional& publicationMediumType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  publicationMediumType::typeLabel_optional& publicationMediumType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void publicationMediumType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void publicationMediumType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void publicationMediumType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const publicationMediumType::typeDefinition_optional& publicationMediumType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  publicationMediumType::typeDefinition_optional& publicationMediumType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void publicationMediumType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void publicationMediumType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void publicationMediumType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const publicationMediumType::typeLink_optional& publicationMediumType::
  typeLink () const
  {
    return this->typeLink_;
  }

  publicationMediumType::typeLink_optional& publicationMediumType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void publicationMediumType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void publicationMediumType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void publicationMediumType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const publicationMediumType::typeLanguage_optional& publicationMediumType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  publicationMediumType::typeLanguage_optional& publicationMediumType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void publicationMediumType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void publicationMediumType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void publicationMediumType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // publicationChannelType
  // 

  const publicationChannelType::typeLabel_optional& publicationChannelType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  publicationChannelType::typeLabel_optional& publicationChannelType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void publicationChannelType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void publicationChannelType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void publicationChannelType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const publicationChannelType::typeDefinition_optional& publicationChannelType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  publicationChannelType::typeDefinition_optional& publicationChannelType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void publicationChannelType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void publicationChannelType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void publicationChannelType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const publicationChannelType::typeLink_optional& publicationChannelType::
  typeLink () const
  {
    return this->typeLink_;
  }

  publicationChannelType::typeLink_optional& publicationChannelType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void publicationChannelType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void publicationChannelType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void publicationChannelType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const publicationChannelType::typeLanguage_optional& publicationChannelType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  publicationChannelType::typeLanguage_optional& publicationChannelType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void publicationChannelType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void publicationChannelType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void publicationChannelType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // formatType
  // 

  const formatType::format_optional& formatType::
  format () const
  {
    return this->format_;
  }

  formatType::format_optional& formatType::
  format ()
  {
    return this->format_;
  }

  void formatType::
  format (const format_type& x)
  {
    this->format_.set (x);
  }

  void formatType::
  format (const format_optional& x)
  {
    this->format_ = x;
  }

  void formatType::
  format (::std::auto_ptr< format_type > x)
  {
    this->format_.set (x);
  }

  const formatType::medium_sequence& formatType::
  medium () const
  {
    return this->medium_;
  }

  formatType::medium_sequence& formatType::
  medium ()
  {
    return this->medium_;
  }

  void formatType::
  medium (const medium_sequence& s)
  {
    this->medium_ = s;
  }

  const formatType::imageFormat_sequence& formatType::
  imageFormat () const
  {
    return this->imageFormat_;
  }

  formatType::imageFormat_sequence& formatType::
  imageFormat ()
  {
    return this->imageFormat_;
  }

  void formatType::
  imageFormat (const imageFormat_sequence& s)
  {
    this->imageFormat_ = s;
  }

  const formatType::videoFormat_sequence& formatType::
  videoFormat () const
  {
    return this->videoFormat_;
  }

  formatType::videoFormat_sequence& formatType::
  videoFormat ()
  {
    return this->videoFormat_;
  }

  void formatType::
  videoFormat (const videoFormat_sequence& s)
  {
    this->videoFormat_ = s;
  }

  const formatType::audioFormat_sequence& formatType::
  audioFormat () const
  {
    return this->audioFormat_;
  }

  formatType::audioFormat_sequence& formatType::
  audioFormat ()
  {
    return this->audioFormat_;
  }

  void formatType::
  audioFormat (const audioFormat_sequence& s)
  {
    this->audioFormat_ = s;
  }

  const formatType::containerFormat_sequence& formatType::
  containerFormat () const
  {
    return this->containerFormat_;
  }

  formatType::containerFormat_sequence& formatType::
  containerFormat ()
  {
    return this->containerFormat_;
  }

  void formatType::
  containerFormat (const containerFormat_sequence& s)
  {
    this->containerFormat_ = s;
  }

  const formatType::dataFormat_sequence& formatType::
  dataFormat () const
  {
    return this->dataFormat_;
  }

  formatType::dataFormat_sequence& formatType::
  dataFormat ()
  {
    return this->dataFormat_;
  }

  void formatType::
  dataFormat (const dataFormat_sequence& s)
  {
    this->dataFormat_ = s;
  }

  const formatType::signingFormat_sequence& formatType::
  signingFormat () const
  {
    return this->signingFormat_;
  }

  formatType::signingFormat_sequence& formatType::
  signingFormat ()
  {
    return this->signingFormat_;
  }

  void formatType::
  signingFormat (const signingFormat_sequence& s)
  {
    this->signingFormat_ = s;
  }

  const formatType::start_optional& formatType::
  start () const
  {
    return this->start_;
  }

  formatType::start_optional& formatType::
  start ()
  {
    return this->start_;
  }

  void formatType::
  start (const start_type& x)
  {
    this->start_.set (x);
  }

  void formatType::
  start (const start_optional& x)
  {
    this->start_ = x;
  }

  void formatType::
  start (::std::auto_ptr< start_type > x)
  {
    this->start_.set (x);
  }

  const formatType::end_optional& formatType::
  end () const
  {
    return this->end_;
  }

  formatType::end_optional& formatType::
  end ()
  {
    return this->end_;
  }

  void formatType::
  end (const end_type& x)
  {
    this->end_.set (x);
  }

  void formatType::
  end (const end_optional& x)
  {
    this->end_ = x;
  }

  void formatType::
  end (::std::auto_ptr< end_type > x)
  {
    this->end_.set (x);
  }

  const formatType::duration_optional& formatType::
  duration () const
  {
    return this->duration_;
  }

  formatType::duration_optional& formatType::
  duration ()
  {
    return this->duration_;
  }

  void formatType::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void formatType::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void formatType::
  duration (::std::auto_ptr< duration_type > x)
  {
    this->duration_.set (x);
  }

  const formatType::fileSize_optional& formatType::
  fileSize () const
  {
    return this->fileSize_;
  }

  formatType::fileSize_optional& formatType::
  fileSize ()
  {
    return this->fileSize_;
  }

  void formatType::
  fileSize (const fileSize_type& x)
  {
    this->fileSize_.set (x);
  }

  void formatType::
  fileSize (const fileSize_optional& x)
  {
    this->fileSize_ = x;
  }

  const formatType::fileName_optional& formatType::
  fileName () const
  {
    return this->fileName_;
  }

  formatType::fileName_optional& formatType::
  fileName ()
  {
    return this->fileName_;
  }

  void formatType::
  fileName (const fileName_type& x)
  {
    this->fileName_.set (x);
  }

  void formatType::
  fileName (const fileName_optional& x)
  {
    this->fileName_ = x;
  }

  void formatType::
  fileName (::std::auto_ptr< fileName_type > x)
  {
    this->fileName_.set (x);
  }

  const formatType::mimeType_sequence& formatType::
  mimeType () const
  {
    return this->mimeType_;
  }

  formatType::mimeType_sequence& formatType::
  mimeType ()
  {
    return this->mimeType_;
  }

  void formatType::
  mimeType (const mimeType_sequence& s)
  {
    this->mimeType_ = s;
  }

  const formatType::locator_sequence& formatType::
  locator () const
  {
    return this->locator_;
  }

  formatType::locator_sequence& formatType::
  locator ()
  {
    return this->locator_;
  }

  void formatType::
  locator (const locator_sequence& s)
  {
    this->locator_ = s;
  }

  const formatType::hash_optional& formatType::
  hash () const
  {
    return this->hash_;
  }

  formatType::hash_optional& formatType::
  hash ()
  {
    return this->hash_;
  }

  void formatType::
  hash (const hash_type& x)
  {
    this->hash_.set (x);
  }

  void formatType::
  hash (const hash_optional& x)
  {
    this->hash_ = x;
  }

  void formatType::
  hash (::std::auto_ptr< hash_type > x)
  {
    this->hash_.set (x);
  }

  const formatType::documentFormat_optional& formatType::
  documentFormat () const
  {
    return this->documentFormat_;
  }

  formatType::documentFormat_optional& formatType::
  documentFormat ()
  {
    return this->documentFormat_;
  }

  void formatType::
  documentFormat (const documentFormat_type& x)
  {
    this->documentFormat_.set (x);
  }

  void formatType::
  documentFormat (const documentFormat_optional& x)
  {
    this->documentFormat_ = x;
  }

  void formatType::
  documentFormat (::std::auto_ptr< documentFormat_type > x)
  {
    this->documentFormat_.set (x);
  }

  const formatType::technicalAttributeString_sequence& formatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  formatType::technicalAttributeString_sequence& formatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void formatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const formatType::technicalAttributeByte_sequence& formatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  formatType::technicalAttributeByte_sequence& formatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void formatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const formatType::technicalAttributeShort_sequence& formatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  formatType::technicalAttributeShort_sequence& formatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void formatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const formatType::technicalAttributeInteger_sequence& formatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  formatType::technicalAttributeInteger_sequence& formatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void formatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const formatType::technicalAttributeLong_sequence& formatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  formatType::technicalAttributeLong_sequence& formatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void formatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const formatType::technicalAttributeUnsignedByte_sequence& formatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  formatType::technicalAttributeUnsignedByte_sequence& formatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void formatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const formatType::technicalAttributeUnsignedShort_sequence& formatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  formatType::technicalAttributeUnsignedShort_sequence& formatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void formatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const formatType::technicalAttributeUnsignedInteger_sequence& formatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  formatType::technicalAttributeUnsignedInteger_sequence& formatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void formatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const formatType::technicalAttributeUnsignedLong_sequence& formatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  formatType::technicalAttributeUnsignedLong_sequence& formatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void formatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const formatType::technicalAttributeBoolean_sequence& formatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  formatType::technicalAttributeBoolean_sequence& formatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void formatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const formatType::technicalAttributeFloat_sequence& formatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  formatType::technicalAttributeFloat_sequence& formatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void formatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const formatType::technicalAttributeRational_sequence& formatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  formatType::technicalAttributeRational_sequence& formatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void formatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const formatType::technicalAttributeUri_sequence& formatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  formatType::technicalAttributeUri_sequence& formatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void formatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const formatType::dateCreated_optional& formatType::
  dateCreated () const
  {
    return this->dateCreated_;
  }

  formatType::dateCreated_optional& formatType::
  dateCreated ()
  {
    return this->dateCreated_;
  }

  void formatType::
  dateCreated (const dateCreated_type& x)
  {
    this->dateCreated_.set (x);
  }

  void formatType::
  dateCreated (const dateCreated_optional& x)
  {
    this->dateCreated_ = x;
  }

  void formatType::
  dateCreated (::std::auto_ptr< dateCreated_type > x)
  {
    this->dateCreated_.set (x);
  }

  const formatType::dateModified_optional& formatType::
  dateModified () const
  {
    return this->dateModified_;
  }

  formatType::dateModified_optional& formatType::
  dateModified ()
  {
    return this->dateModified_;
  }

  void formatType::
  dateModified (const dateModified_type& x)
  {
    this->dateModified_.set (x);
  }

  void formatType::
  dateModified (const dateModified_optional& x)
  {
    this->dateModified_ = x;
  }

  void formatType::
  dateModified (::std::auto_ptr< dateModified_type > x)
  {
    this->dateModified_.set (x);
  }

  const formatType::formatId_optional& formatType::
  formatId () const
  {
    return this->formatId_;
  }

  formatType::formatId_optional& formatType::
  formatId ()
  {
    return this->formatId_;
  }

  void formatType::
  formatId (const formatId_type& x)
  {
    this->formatId_.set (x);
  }

  void formatType::
  formatId (const formatId_optional& x)
  {
    this->formatId_ = x;
  }

  void formatType::
  formatId (::std::auto_ptr< formatId_type > x)
  {
    this->formatId_.set (x);
  }

  const formatType::formatVersionId_optional& formatType::
  formatVersionId () const
  {
    return this->formatVersionId_;
  }

  formatType::formatVersionId_optional& formatType::
  formatVersionId ()
  {
    return this->formatVersionId_;
  }

  void formatType::
  formatVersionId (const formatVersionId_type& x)
  {
    this->formatVersionId_.set (x);
  }

  void formatType::
  formatVersionId (const formatVersionId_optional& x)
  {
    this->formatVersionId_ = x;
  }

  void formatType::
  formatVersionId (::std::auto_ptr< formatVersionId_type > x)
  {
    this->formatVersionId_.set (x);
  }

  const formatType::formatName_optional& formatType::
  formatName () const
  {
    return this->formatName_;
  }

  formatType::formatName_optional& formatType::
  formatName ()
  {
    return this->formatName_;
  }

  void formatType::
  formatName (const formatName_type& x)
  {
    this->formatName_.set (x);
  }

  void formatType::
  formatName (const formatName_optional& x)
  {
    this->formatName_ = x;
  }

  void formatType::
  formatName (::std::auto_ptr< formatName_type > x)
  {
    this->formatName_.set (x);
  }

  const formatType::formatDefinition_optional& formatType::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  formatType::formatDefinition_optional& formatType::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void formatType::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void formatType::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void formatType::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }


  // entityType
  // 

  const entityType::contactDetails_sequence& entityType::
  contactDetails () const
  {
    return this->contactDetails_;
  }

  entityType::contactDetails_sequence& entityType::
  contactDetails ()
  {
    return this->contactDetails_;
  }

  void entityType::
  contactDetails (const contactDetails_sequence& s)
  {
    this->contactDetails_ = s;
  }

  const entityType::organisationDetails_sequence& entityType::
  organisationDetails () const
  {
    return this->organisationDetails_;
  }

  entityType::organisationDetails_sequence& entityType::
  organisationDetails ()
  {
    return this->organisationDetails_;
  }

  void entityType::
  organisationDetails (const organisationDetails_sequence& s)
  {
    this->organisationDetails_ = s;
  }

  const entityType::role_sequence& entityType::
  role () const
  {
    return this->role_;
  }

  entityType::role_sequence& entityType::
  role ()
  {
    return this->role_;
  }

  void entityType::
  role (const role_sequence& s)
  {
    this->role_ = s;
  }

  const entityType::entityId_optional& entityType::
  entityId () const
  {
    return this->entityId_;
  }

  entityType::entityId_optional& entityType::
  entityId ()
  {
    return this->entityId_;
  }

  void entityType::
  entityId (const entityId_type& x)
  {
    this->entityId_.set (x);
  }

  void entityType::
  entityId (const entityId_optional& x)
  {
    this->entityId_ = x;
  }

  void entityType::
  entityId (::std::auto_ptr< entityId_type > x)
  {
    this->entityId_.set (x);
  }


  // contactDetailsType
  // 

  const contactDetailsType::name_sequence& contactDetailsType::
  name () const
  {
    return this->name_;
  }

  contactDetailsType::name_sequence& contactDetailsType::
  name ()
  {
    return this->name_;
  }

  void contactDetailsType::
  name (const name_sequence& s)
  {
    this->name_ = s;
  }

  const contactDetailsType::givenName_optional& contactDetailsType::
  givenName () const
  {
    return this->givenName_;
  }

  contactDetailsType::givenName_optional& contactDetailsType::
  givenName ()
  {
    return this->givenName_;
  }

  void contactDetailsType::
  givenName (const givenName_type& x)
  {
    this->givenName_.set (x);
  }

  void contactDetailsType::
  givenName (const givenName_optional& x)
  {
    this->givenName_ = x;
  }

  void contactDetailsType::
  givenName (::std::auto_ptr< givenName_type > x)
  {
    this->givenName_.set (x);
  }

  const contactDetailsType::familyName_optional& contactDetailsType::
  familyName () const
  {
    return this->familyName_;
  }

  contactDetailsType::familyName_optional& contactDetailsType::
  familyName ()
  {
    return this->familyName_;
  }

  void contactDetailsType::
  familyName (const familyName_type& x)
  {
    this->familyName_.set (x);
  }

  void contactDetailsType::
  familyName (const familyName_optional& x)
  {
    this->familyName_ = x;
  }

  void contactDetailsType::
  familyName (::std::auto_ptr< familyName_type > x)
  {
    this->familyName_.set (x);
  }

  const contactDetailsType::otherGivenName_sequence& contactDetailsType::
  otherGivenName () const
  {
    return this->otherGivenName_;
  }

  contactDetailsType::otherGivenName_sequence& contactDetailsType::
  otherGivenName ()
  {
    return this->otherGivenName_;
  }

  void contactDetailsType::
  otherGivenName (const otherGivenName_sequence& s)
  {
    this->otherGivenName_ = s;
  }

  const contactDetailsType::suffix_optional& contactDetailsType::
  suffix () const
  {
    return this->suffix_;
  }

  contactDetailsType::suffix_optional& contactDetailsType::
  suffix ()
  {
    return this->suffix_;
  }

  void contactDetailsType::
  suffix (const suffix_type& x)
  {
    this->suffix_.set (x);
  }

  void contactDetailsType::
  suffix (const suffix_optional& x)
  {
    this->suffix_ = x;
  }

  void contactDetailsType::
  suffix (::std::auto_ptr< suffix_type > x)
  {
    this->suffix_.set (x);
  }

  const contactDetailsType::salutation_optional& contactDetailsType::
  salutation () const
  {
    return this->salutation_;
  }

  contactDetailsType::salutation_optional& contactDetailsType::
  salutation ()
  {
    return this->salutation_;
  }

  void contactDetailsType::
  salutation (const salutation_type& x)
  {
    this->salutation_.set (x);
  }

  void contactDetailsType::
  salutation (const salutation_optional& x)
  {
    this->salutation_ = x;
  }

  void contactDetailsType::
  salutation (::std::auto_ptr< salutation_type > x)
  {
    this->salutation_.set (x);
  }

  const contactDetailsType::username_sequence& contactDetailsType::
  username () const
  {
    return this->username_;
  }

  contactDetailsType::username_sequence& contactDetailsType::
  username ()
  {
    return this->username_;
  }

  void contactDetailsType::
  username (const username_sequence& s)
  {
    this->username_ = s;
  }

  const contactDetailsType::occupation_optional& contactDetailsType::
  occupation () const
  {
    return this->occupation_;
  }

  contactDetailsType::occupation_optional& contactDetailsType::
  occupation ()
  {
    return this->occupation_;
  }

  void contactDetailsType::
  occupation (const occupation_type& x)
  {
    this->occupation_.set (x);
  }

  void contactDetailsType::
  occupation (const occupation_optional& x)
  {
    this->occupation_ = x;
  }

  void contactDetailsType::
  occupation (::std::auto_ptr< occupation_type > x)
  {
    this->occupation_.set (x);
  }

  const contactDetailsType::details_sequence& contactDetailsType::
  details () const
  {
    return this->details_;
  }

  contactDetailsType::details_sequence& contactDetailsType::
  details ()
  {
    return this->details_;
  }

  void contactDetailsType::
  details (const details_sequence& s)
  {
    this->details_ = s;
  }

  const contactDetailsType::stageName_sequence& contactDetailsType::
  stageName () const
  {
    return this->stageName_;
  }

  contactDetailsType::stageName_sequence& contactDetailsType::
  stageName ()
  {
    return this->stageName_;
  }

  void contactDetailsType::
  stageName (const stageName_sequence& s)
  {
    this->stageName_ = s;
  }

  const contactDetailsType::guest_optional& contactDetailsType::
  guest () const
  {
    return this->guest_;
  }

  contactDetailsType::guest_optional& contactDetailsType::
  guest ()
  {
    return this->guest_;
  }

  void contactDetailsType::
  guest (const guest_type& x)
  {
    this->guest_.set (x);
  }

  void contactDetailsType::
  guest (const guest_optional& x)
  {
    this->guest_ = x;
  }

  const contactDetailsType::gender_optional& contactDetailsType::
  gender () const
  {
    return this->gender_;
  }

  contactDetailsType::gender_optional& contactDetailsType::
  gender ()
  {
    return this->gender_;
  }

  void contactDetailsType::
  gender (const gender_type& x)
  {
    this->gender_.set (x);
  }

  void contactDetailsType::
  gender (const gender_optional& x)
  {
    this->gender_ = x;
  }

  void contactDetailsType::
  gender (::std::auto_ptr< gender_type > x)
  {
    this->gender_.set (x);
  }

  const contactDetailsType::relatedInformationLink_sequence& contactDetailsType::
  relatedInformationLink () const
  {
    return this->relatedInformationLink_;
  }

  contactDetailsType::relatedInformationLink_sequence& contactDetailsType::
  relatedInformationLink ()
  {
    return this->relatedInformationLink_;
  }

  void contactDetailsType::
  relatedInformationLink (const relatedInformationLink_sequence& s)
  {
    this->relatedInformationLink_ = s;
  }

  const contactDetailsType::relatedContacts_sequence& contactDetailsType::
  relatedContacts () const
  {
    return this->relatedContacts_;
  }

  contactDetailsType::relatedContacts_sequence& contactDetailsType::
  relatedContacts ()
  {
    return this->relatedContacts_;
  }

  void contactDetailsType::
  relatedContacts (const relatedContacts_sequence& s)
  {
    this->relatedContacts_ = s;
  }

  const contactDetailsType::contactId_optional& contactDetailsType::
  contactId () const
  {
    return this->contactId_;
  }

  contactDetailsType::contactId_optional& contactDetailsType::
  contactId ()
  {
    return this->contactId_;
  }

  void contactDetailsType::
  contactId (const contactId_type& x)
  {
    this->contactId_.set (x);
  }

  void contactDetailsType::
  contactId (const contactId_optional& x)
  {
    this->contactId_ = x;
  }

  void contactDetailsType::
  contactId (::std::auto_ptr< contactId_type > x)
  {
    this->contactId_.set (x);
  }

  const contactDetailsType::typeLabel_optional& contactDetailsType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  contactDetailsType::typeLabel_optional& contactDetailsType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void contactDetailsType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void contactDetailsType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void contactDetailsType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const contactDetailsType::typeDefinition_optional& contactDetailsType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  contactDetailsType::typeDefinition_optional& contactDetailsType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void contactDetailsType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void contactDetailsType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void contactDetailsType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const contactDetailsType::typeLink_optional& contactDetailsType::
  typeLink () const
  {
    return this->typeLink_;
  }

  contactDetailsType::typeLink_optional& contactDetailsType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void contactDetailsType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void contactDetailsType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void contactDetailsType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const contactDetailsType::typeLanguage_optional& contactDetailsType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  contactDetailsType::typeLanguage_optional& contactDetailsType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void contactDetailsType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void contactDetailsType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void contactDetailsType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // organisationDetailsType
  // 

  const organisationDetailsType::organisationName_sequence& organisationDetailsType::
  organisationName () const
  {
    return this->organisationName_;
  }

  organisationDetailsType::organisationName_sequence& organisationDetailsType::
  organisationName ()
  {
    return this->organisationName_;
  }

  void organisationDetailsType::
  organisationName (const organisationName_sequence& s)
  {
    this->organisationName_ = s;
  }

  const organisationDetailsType::organisationCode_sequence& organisationDetailsType::
  organisationCode () const
  {
    return this->organisationCode_;
  }

  organisationDetailsType::organisationCode_sequence& organisationDetailsType::
  organisationCode ()
  {
    return this->organisationCode_;
  }

  void organisationDetailsType::
  organisationCode (const organisationCode_sequence& s)
  {
    this->organisationCode_ = s;
  }

  const organisationDetailsType::organisationDepartment_optional& organisationDetailsType::
  organisationDepartment () const
  {
    return this->organisationDepartment_;
  }

  organisationDetailsType::organisationDepartment_optional& organisationDetailsType::
  organisationDepartment ()
  {
    return this->organisationDepartment_;
  }

  void organisationDetailsType::
  organisationDepartment (const organisationDepartment_type& x)
  {
    this->organisationDepartment_.set (x);
  }

  void organisationDetailsType::
  organisationDepartment (const organisationDepartment_optional& x)
  {
    this->organisationDepartment_ = x;
  }

  void organisationDetailsType::
  organisationDepartment (::std::auto_ptr< organisationDepartment_type > x)
  {
    this->organisationDepartment_.set (x);
  }

  const organisationDetailsType::details_sequence& organisationDetailsType::
  details () const
  {
    return this->details_;
  }

  organisationDetailsType::details_sequence& organisationDetailsType::
  details ()
  {
    return this->details_;
  }

  void organisationDetailsType::
  details (const details_sequence& s)
  {
    this->details_ = s;
  }

  const organisationDetailsType::relatedInformationLink_sequence& organisationDetailsType::
  relatedInformationLink () const
  {
    return this->relatedInformationLink_;
  }

  organisationDetailsType::relatedInformationLink_sequence& organisationDetailsType::
  relatedInformationLink ()
  {
    return this->relatedInformationLink_;
  }

  void organisationDetailsType::
  relatedInformationLink (const relatedInformationLink_sequence& s)
  {
    this->relatedInformationLink_ = s;
  }

  const organisationDetailsType::contacts_sequence& organisationDetailsType::
  contacts () const
  {
    return this->contacts_;
  }

  organisationDetailsType::contacts_sequence& organisationDetailsType::
  contacts ()
  {
    return this->contacts_;
  }

  void organisationDetailsType::
  contacts (const contacts_sequence& s)
  {
    this->contacts_ = s;
  }

  const organisationDetailsType::organisationId_optional& organisationDetailsType::
  organisationId () const
  {
    return this->organisationId_;
  }

  organisationDetailsType::organisationId_optional& organisationDetailsType::
  organisationId ()
  {
    return this->organisationId_;
  }

  void organisationDetailsType::
  organisationId (const organisationId_type& x)
  {
    this->organisationId_.set (x);
  }

  void organisationDetailsType::
  organisationId (const organisationId_optional& x)
  {
    this->organisationId_ = x;
  }

  void organisationDetailsType::
  organisationId (::std::auto_ptr< organisationId_type > x)
  {
    this->organisationId_.set (x);
  }

  const organisationDetailsType::typeLabel_optional& organisationDetailsType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  organisationDetailsType::typeLabel_optional& organisationDetailsType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void organisationDetailsType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void organisationDetailsType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void organisationDetailsType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const organisationDetailsType::typeDefinition_optional& organisationDetailsType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  organisationDetailsType::typeDefinition_optional& organisationDetailsType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void organisationDetailsType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void organisationDetailsType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void organisationDetailsType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const organisationDetailsType::typeLink_optional& organisationDetailsType::
  typeLink () const
  {
    return this->typeLink_;
  }

  organisationDetailsType::typeLink_optional& organisationDetailsType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void organisationDetailsType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void organisationDetailsType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void organisationDetailsType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const organisationDetailsType::typeLanguage_optional& organisationDetailsType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  organisationDetailsType::typeLanguage_optional& organisationDetailsType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void organisationDetailsType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void organisationDetailsType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void organisationDetailsType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // detailsType
  // 

  const detailsType::emailAddress_sequence& detailsType::
  emailAddress () const
  {
    return this->emailAddress_;
  }

  detailsType::emailAddress_sequence& detailsType::
  emailAddress ()
  {
    return this->emailAddress_;
  }

  void detailsType::
  emailAddress (const emailAddress_sequence& s)
  {
    this->emailAddress_ = s;
  }

  const detailsType::webAddress_optional& detailsType::
  webAddress () const
  {
    return this->webAddress_;
  }

  detailsType::webAddress_optional& detailsType::
  webAddress ()
  {
    return this->webAddress_;
  }

  void detailsType::
  webAddress (const webAddress_type& x)
  {
    this->webAddress_.set (x);
  }

  void detailsType::
  webAddress (const webAddress_optional& x)
  {
    this->webAddress_ = x;
  }

  void detailsType::
  webAddress (::std::auto_ptr< webAddress_type > x)
  {
    this->webAddress_.set (x);
  }

  const detailsType::address_optional& detailsType::
  address () const
  {
    return this->address_;
  }

  detailsType::address_optional& detailsType::
  address ()
  {
    return this->address_;
  }

  void detailsType::
  address (const address_type& x)
  {
    this->address_.set (x);
  }

  void detailsType::
  address (const address_optional& x)
  {
    this->address_ = x;
  }

  void detailsType::
  address (::std::auto_ptr< address_type > x)
  {
    this->address_.set (x);
  }

  const detailsType::telephoneNumber_optional& detailsType::
  telephoneNumber () const
  {
    return this->telephoneNumber_;
  }

  detailsType::telephoneNumber_optional& detailsType::
  telephoneNumber ()
  {
    return this->telephoneNumber_;
  }

  void detailsType::
  telephoneNumber (const telephoneNumber_type& x)
  {
    this->telephoneNumber_.set (x);
  }

  void detailsType::
  telephoneNumber (const telephoneNumber_optional& x)
  {
    this->telephoneNumber_ = x;
  }

  void detailsType::
  telephoneNumber (::std::auto_ptr< telephoneNumber_type > x)
  {
    this->telephoneNumber_.set (x);
  }

  const detailsType::mobileTelephoneNumber_optional& detailsType::
  mobileTelephoneNumber () const
  {
    return this->mobileTelephoneNumber_;
  }

  detailsType::mobileTelephoneNumber_optional& detailsType::
  mobileTelephoneNumber ()
  {
    return this->mobileTelephoneNumber_;
  }

  void detailsType::
  mobileTelephoneNumber (const mobileTelephoneNumber_type& x)
  {
    this->mobileTelephoneNumber_.set (x);
  }

  void detailsType::
  mobileTelephoneNumber (const mobileTelephoneNumber_optional& x)
  {
    this->mobileTelephoneNumber_ = x;
  }

  void detailsType::
  mobileTelephoneNumber (::std::auto_ptr< mobileTelephoneNumber_type > x)
  {
    this->mobileTelephoneNumber_.set (x);
  }

  const detailsType::typeLabel_optional& detailsType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  detailsType::typeLabel_optional& detailsType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void detailsType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void detailsType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void detailsType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const detailsType::typeDefinition_optional& detailsType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  detailsType::typeDefinition_optional& detailsType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void detailsType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void detailsType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void detailsType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const detailsType::typeLink_optional& detailsType::
  typeLink () const
  {
    return this->typeLink_;
  }

  detailsType::typeLink_optional& detailsType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void detailsType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void detailsType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void detailsType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const detailsType::typeLanguage_optional& detailsType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  detailsType::typeLanguage_optional& detailsType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void detailsType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void detailsType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void detailsType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // addressType
  // 

  const addressType::addressLine_sequence& addressType::
  addressLine () const
  {
    return this->addressLine_;
  }

  addressType::addressLine_sequence& addressType::
  addressLine ()
  {
    return this->addressLine_;
  }

  void addressType::
  addressLine (const addressLine_sequence& s)
  {
    this->addressLine_ = s;
  }

  const addressType::addressTownCity_optional& addressType::
  addressTownCity () const
  {
    return this->addressTownCity_;
  }

  addressType::addressTownCity_optional& addressType::
  addressTownCity ()
  {
    return this->addressTownCity_;
  }

  void addressType::
  addressTownCity (const addressTownCity_type& x)
  {
    this->addressTownCity_.set (x);
  }

  void addressType::
  addressTownCity (const addressTownCity_optional& x)
  {
    this->addressTownCity_ = x;
  }

  void addressType::
  addressTownCity (::std::auto_ptr< addressTownCity_type > x)
  {
    this->addressTownCity_.set (x);
  }

  const addressType::addressCountyState_optional& addressType::
  addressCountyState () const
  {
    return this->addressCountyState_;
  }

  addressType::addressCountyState_optional& addressType::
  addressCountyState ()
  {
    return this->addressCountyState_;
  }

  void addressType::
  addressCountyState (const addressCountyState_type& x)
  {
    this->addressCountyState_.set (x);
  }

  void addressType::
  addressCountyState (const addressCountyState_optional& x)
  {
    this->addressCountyState_ = x;
  }

  void addressType::
  addressCountyState (::std::auto_ptr< addressCountyState_type > x)
  {
    this->addressCountyState_.set (x);
  }

  const addressType::addressDeliveryCode_optional& addressType::
  addressDeliveryCode () const
  {
    return this->addressDeliveryCode_;
  }

  addressType::addressDeliveryCode_optional& addressType::
  addressDeliveryCode ()
  {
    return this->addressDeliveryCode_;
  }

  void addressType::
  addressDeliveryCode (const addressDeliveryCode_type& x)
  {
    this->addressDeliveryCode_.set (x);
  }

  void addressType::
  addressDeliveryCode (const addressDeliveryCode_optional& x)
  {
    this->addressDeliveryCode_ = x;
  }

  void addressType::
  addressDeliveryCode (::std::auto_ptr< addressDeliveryCode_type > x)
  {
    this->addressDeliveryCode_.set (x);
  }

  const addressType::country_optional& addressType::
  country () const
  {
    return this->country_;
  }

  addressType::country_optional& addressType::
  country ()
  {
    return this->country_;
  }

  void addressType::
  country (const country_type& x)
  {
    this->country_.set (x);
  }

  void addressType::
  country (const country_optional& x)
  {
    this->country_ = x;
  }

  void addressType::
  country (::std::auto_ptr< country_type > x)
  {
    this->country_.set (x);
  }


  // compoundNameType
  // 

  const compoundNameType::typeLabel_optional& compoundNameType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  compoundNameType::typeLabel_optional& compoundNameType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void compoundNameType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void compoundNameType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void compoundNameType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const compoundNameType::typeDefinition_optional& compoundNameType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  compoundNameType::typeDefinition_optional& compoundNameType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void compoundNameType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void compoundNameType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void compoundNameType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const compoundNameType::typeLink_optional& compoundNameType::
  typeLink () const
  {
    return this->typeLink_;
  }

  compoundNameType::typeLink_optional& compoundNameType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void compoundNameType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void compoundNameType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void compoundNameType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const compoundNameType::typeLanguage_optional& compoundNameType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  compoundNameType::typeLanguage_optional& compoundNameType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void compoundNameType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void compoundNameType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void compoundNameType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const compoundNameType::formatLabel_optional& compoundNameType::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  compoundNameType::formatLabel_optional& compoundNameType::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void compoundNameType::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void compoundNameType::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void compoundNameType::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const compoundNameType::formatDefinition_optional& compoundNameType::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  compoundNameType::formatDefinition_optional& compoundNameType::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void compoundNameType::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void compoundNameType::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void compoundNameType::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const compoundNameType::formatLink_optional& compoundNameType::
  formatLink () const
  {
    return this->formatLink_;
  }

  compoundNameType::formatLink_optional& compoundNameType::
  formatLink ()
  {
    return this->formatLink_;
  }

  void compoundNameType::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void compoundNameType::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void compoundNameType::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const compoundNameType::formatLanguage_optional& compoundNameType::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  compoundNameType::formatLanguage_optional& compoundNameType::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void compoundNameType::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void compoundNameType::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void compoundNameType::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }


  // regionType
  // 

  const regionType::country_optional& regionType::
  country () const
  {
    return this->country_;
  }

  regionType::country_optional& regionType::
  country ()
  {
    return this->country_;
  }

  void regionType::
  country (const country_type& x)
  {
    this->country_.set (x);
  }

  void regionType::
  country (const country_optional& x)
  {
    this->country_ = x;
  }

  void regionType::
  country (::std::auto_ptr< country_type > x)
  {
    this->country_.set (x);
  }

  const regionType::countryRegion_sequence& regionType::
  countryRegion () const
  {
    return this->countryRegion_;
  }

  regionType::countryRegion_sequence& regionType::
  countryRegion ()
  {
    return this->countryRegion_;
  }

  void regionType::
  countryRegion (const countryRegion_sequence& s)
  {
    this->countryRegion_ = s;
  }


  // editUnitNumberType
  // 

  const editUnitNumberType::editRate_optional& editUnitNumberType::
  editRate () const
  {
    return this->editRate_;
  }

  editUnitNumberType::editRate_optional& editUnitNumberType::
  editRate ()
  {
    return this->editRate_;
  }

  void editUnitNumberType::
  editRate (const editRate_type& x)
  {
    this->editRate_.set (x);
  }

  void editUnitNumberType::
  editRate (const editRate_optional& x)
  {
    this->editRate_ = x;
  }

  const editUnitNumberType::factorNumerator_type& editUnitNumberType::
  factorNumerator () const
  {
    return this->factorNumerator_.get ();
  }

  editUnitNumberType::factorNumerator_type& editUnitNumberType::
  factorNumerator ()
  {
    return this->factorNumerator_.get ();
  }

  void editUnitNumberType::
  factorNumerator (const factorNumerator_type& x)
  {
    this->factorNumerator_.set (x);
  }

  editUnitNumberType::factorNumerator_type editUnitNumberType::
  factorNumerator_default_value ()
  {
    return factorNumerator_type (1ULL);
  }

  const editUnitNumberType::factorDenominator_type& editUnitNumberType::
  factorDenominator () const
  {
    return this->factorDenominator_.get ();
  }

  editUnitNumberType::factorDenominator_type& editUnitNumberType::
  factorDenominator ()
  {
    return this->factorDenominator_.get ();
  }

  void editUnitNumberType::
  factorDenominator (const factorDenominator_type& x)
  {
    this->factorDenominator_.set (x);
  }

  editUnitNumberType::factorDenominator_type editUnitNumberType::
  factorDenominator_default_value ()
  {
    return factorDenominator_type (1ULL);
  }


  // ratingType
  // 

  const ratingType::ratingValue_sequence& ratingType::
  ratingValue () const
  {
    return this->ratingValue_;
  }

  ratingType::ratingValue_sequence& ratingType::
  ratingValue ()
  {
    return this->ratingValue_;
  }

  void ratingType::
  ratingValue (const ratingValue_sequence& s)
  {
    this->ratingValue_ = s;
  }

  const ratingType::ratingScaleMaxValue_sequence& ratingType::
  ratingScaleMaxValue () const
  {
    return this->ratingScaleMaxValue_;
  }

  ratingType::ratingScaleMaxValue_sequence& ratingType::
  ratingScaleMaxValue ()
  {
    return this->ratingScaleMaxValue_;
  }

  void ratingType::
  ratingScaleMaxValue (const ratingScaleMaxValue_sequence& s)
  {
    this->ratingScaleMaxValue_ = s;
  }

  const ratingType::ratingScaleMinValue_sequence& ratingType::
  ratingScaleMinValue () const
  {
    return this->ratingScaleMinValue_;
  }

  ratingType::ratingScaleMinValue_sequence& ratingType::
  ratingScaleMinValue ()
  {
    return this->ratingScaleMinValue_;
  }

  void ratingType::
  ratingScaleMinValue (const ratingScaleMinValue_sequence& s)
  {
    this->ratingScaleMinValue_ = s;
  }

  const ratingType::ratingProvider_optional& ratingType::
  ratingProvider () const
  {
    return this->ratingProvider_;
  }

  ratingType::ratingProvider_optional& ratingType::
  ratingProvider ()
  {
    return this->ratingProvider_;
  }

  void ratingType::
  ratingProvider (const ratingProvider_type& x)
  {
    this->ratingProvider_.set (x);
  }

  void ratingType::
  ratingProvider (const ratingProvider_optional& x)
  {
    this->ratingProvider_ = x;
  }

  void ratingType::
  ratingProvider (::std::auto_ptr< ratingProvider_type > x)
  {
    this->ratingProvider_.set (x);
  }

  const ratingType::ratingRegion_sequence& ratingType::
  ratingRegion () const
  {
    return this->ratingRegion_;
  }

  ratingType::ratingRegion_sequence& ratingType::
  ratingRegion ()
  {
    return this->ratingRegion_;
  }

  void ratingType::
  ratingRegion (const ratingRegion_sequence& s)
  {
    this->ratingRegion_ = s;
  }

  const ratingType::typeLabel_optional& ratingType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  ratingType::typeLabel_optional& ratingType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void ratingType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void ratingType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void ratingType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const ratingType::typeDefinition_optional& ratingType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  ratingType::typeDefinition_optional& ratingType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void ratingType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void ratingType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void ratingType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const ratingType::typeLink_optional& ratingType::
  typeLink () const
  {
    return this->typeLink_;
  }

  ratingType::typeLink_optional& ratingType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void ratingType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void ratingType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void ratingType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const ratingType::typeLanguage_optional& ratingType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  ratingType::typeLanguage_optional& ratingType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void ratingType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void ratingType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void ratingType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const ratingType::formatLabel_optional& ratingType::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  ratingType::formatLabel_optional& ratingType::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void ratingType::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void ratingType::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void ratingType::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const ratingType::formatDefinition_optional& ratingType::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  ratingType::formatDefinition_optional& ratingType::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void ratingType::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void ratingType::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void ratingType::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const ratingType::formatLink_optional& ratingType::
  formatLink () const
  {
    return this->formatLink_;
  }

  ratingType::formatLink_optional& ratingType::
  formatLink ()
  {
    return this->formatLink_;
  }

  void ratingType::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void ratingType::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void ratingType::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const ratingType::formatLanguage_optional& ratingType::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  ratingType::formatLanguage_optional& ratingType::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void ratingType::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void ratingType::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void ratingType::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }

  const ratingType::reason_optional& ratingType::
  reason () const
  {
    return this->reason_;
  }

  ratingType::reason_optional& ratingType::
  reason ()
  {
    return this->reason_;
  }

  void ratingType::
  reason (const reason_type& x)
  {
    this->reason_.set (x);
  }

  void ratingType::
  reason (const reason_optional& x)
  {
    this->reason_ = x;
  }

  void ratingType::
  reason (::std::auto_ptr< reason_type > x)
  {
    this->reason_.set (x);
  }

  const ratingType::linkToLogo_optional& ratingType::
  linkToLogo () const
  {
    return this->linkToLogo_;
  }

  ratingType::linkToLogo_optional& ratingType::
  linkToLogo ()
  {
    return this->linkToLogo_;
  }

  void ratingType::
  linkToLogo (const linkToLogo_type& x)
  {
    this->linkToLogo_.set (x);
  }

  void ratingType::
  linkToLogo (const linkToLogo_optional& x)
  {
    this->linkToLogo_ = x;
  }

  void ratingType::
  linkToLogo (::std::auto_ptr< linkToLogo_type > x)
  {
    this->linkToLogo_.set (x);
  }

  const ratingType::notRated_optional& ratingType::
  notRated () const
  {
    return this->notRated_;
  }

  ratingType::notRated_optional& ratingType::
  notRated ()
  {
    return this->notRated_;
  }

  void ratingType::
  notRated (const notRated_type& x)
  {
    this->notRated_.set (x);
  }

  void ratingType::
  notRated (const notRated_optional& x)
  {
    this->notRated_ = x;
  }

  const ratingType::adultContent_optional& ratingType::
  adultContent () const
  {
    return this->adultContent_;
  }

  ratingType::adultContent_optional& ratingType::
  adultContent ()
  {
    return this->adultContent_;
  }

  void ratingType::
  adultContent (const adultContent_type& x)
  {
    this->adultContent_.set (x);
  }

  void ratingType::
  adultContent (const adultContent_optional& x)
  {
    this->adultContent_ = x;
  }


  // lengthType
  // 

  const lengthType::unit_optional& lengthType::
  unit () const
  {
    return this->unit_;
  }

  lengthType::unit_optional& lengthType::
  unit ()
  {
    return this->unit_;
  }

  void lengthType::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void lengthType::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void lengthType::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }


  // dimensionType
  // 

  const dimensionType::unit_optional& dimensionType::
  unit () const
  {
    return this->unit_;
  }

  dimensionType::unit_optional& dimensionType::
  unit ()
  {
    return this->unit_;
  }

  void dimensionType::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void dimensionType::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void dimensionType::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }


  // imageFormatType
  // 

  const imageFormatType::regionDelimX_optional& imageFormatType::
  regionDelimX () const
  {
    return this->regionDelimX_;
  }

  imageFormatType::regionDelimX_optional& imageFormatType::
  regionDelimX ()
  {
    return this->regionDelimX_;
  }

  void imageFormatType::
  regionDelimX (const regionDelimX_type& x)
  {
    this->regionDelimX_.set (x);
  }

  void imageFormatType::
  regionDelimX (const regionDelimX_optional& x)
  {
    this->regionDelimX_ = x;
  }

  const imageFormatType::regionDelimY_optional& imageFormatType::
  regionDelimY () const
  {
    return this->regionDelimY_;
  }

  imageFormatType::regionDelimY_optional& imageFormatType::
  regionDelimY ()
  {
    return this->regionDelimY_;
  }

  void imageFormatType::
  regionDelimY (const regionDelimY_type& x)
  {
    this->regionDelimY_.set (x);
  }

  void imageFormatType::
  regionDelimY (const regionDelimY_optional& x)
  {
    this->regionDelimY_ = x;
  }

  const imageFormatType::width_optional& imageFormatType::
  width () const
  {
    return this->width_;
  }

  imageFormatType::width_optional& imageFormatType::
  width ()
  {
    return this->width_;
  }

  void imageFormatType::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void imageFormatType::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void imageFormatType::
  width (::std::auto_ptr< width_type > x)
  {
    this->width_.set (x);
  }

  const imageFormatType::height_optional& imageFormatType::
  height () const
  {
    return this->height_;
  }

  imageFormatType::height_optional& imageFormatType::
  height ()
  {
    return this->height_;
  }

  void imageFormatType::
  height (const height_type& x)
  {
    this->height_.set (x);
  }

  void imageFormatType::
  height (const height_optional& x)
  {
    this->height_ = x;
  }

  void imageFormatType::
  height (::std::auto_ptr< height_type > x)
  {
    this->height_.set (x);
  }

  const imageFormatType::orientation_optional& imageFormatType::
  orientation () const
  {
    return this->orientation_;
  }

  imageFormatType::orientation_optional& imageFormatType::
  orientation ()
  {
    return this->orientation_;
  }

  void imageFormatType::
  orientation (const orientation_type& x)
  {
    this->orientation_.set (x);
  }

  void imageFormatType::
  orientation (const orientation_optional& x)
  {
    this->orientation_ = x;
  }

  void imageFormatType::
  orientation (::std::auto_ptr< orientation_type > x)
  {
    this->orientation_.set (x);
  }

  const imageFormatType::aspectRatio_optional& imageFormatType::
  aspectRatio () const
  {
    return this->aspectRatio_;
  }

  imageFormatType::aspectRatio_optional& imageFormatType::
  aspectRatio ()
  {
    return this->aspectRatio_;
  }

  void imageFormatType::
  aspectRatio (const aspectRatio_type& x)
  {
    this->aspectRatio_.set (x);
  }

  void imageFormatType::
  aspectRatio (const aspectRatio_optional& x)
  {
    this->aspectRatio_ = x;
  }

  void imageFormatType::
  aspectRatio (::std::auto_ptr< aspectRatio_type > x)
  {
    this->aspectRatio_.set (x);
  }

  const imageFormatType::imageEncoding_optional& imageFormatType::
  imageEncoding () const
  {
    return this->imageEncoding_;
  }

  imageFormatType::imageEncoding_optional& imageFormatType::
  imageEncoding ()
  {
    return this->imageEncoding_;
  }

  void imageFormatType::
  imageEncoding (const imageEncoding_type& x)
  {
    this->imageEncoding_.set (x);
  }

  void imageFormatType::
  imageEncoding (const imageEncoding_optional& x)
  {
    this->imageEncoding_ = x;
  }

  void imageFormatType::
  imageEncoding (::std::auto_ptr< imageEncoding_type > x)
  {
    this->imageEncoding_.set (x);
  }

  const imageFormatType::technicalAttributeString_sequence& imageFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  imageFormatType::technicalAttributeString_sequence& imageFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void imageFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const imageFormatType::technicalAttributeByte_sequence& imageFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  imageFormatType::technicalAttributeByte_sequence& imageFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void imageFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const imageFormatType::technicalAttributeShort_sequence& imageFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  imageFormatType::technicalAttributeShort_sequence& imageFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void imageFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const imageFormatType::technicalAttributeInteger_sequence& imageFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  imageFormatType::technicalAttributeInteger_sequence& imageFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void imageFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const imageFormatType::technicalAttributeLong_sequence& imageFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  imageFormatType::technicalAttributeLong_sequence& imageFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void imageFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const imageFormatType::technicalAttributeUnsignedByte_sequence& imageFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  imageFormatType::technicalAttributeUnsignedByte_sequence& imageFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void imageFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const imageFormatType::technicalAttributeUnsignedShort_sequence& imageFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  imageFormatType::technicalAttributeUnsignedShort_sequence& imageFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void imageFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const imageFormatType::technicalAttributeUnsignedInteger_sequence& imageFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  imageFormatType::technicalAttributeUnsignedInteger_sequence& imageFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void imageFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const imageFormatType::technicalAttributeUnsignedLong_sequence& imageFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  imageFormatType::technicalAttributeUnsignedLong_sequence& imageFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void imageFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const imageFormatType::technicalAttributeBoolean_sequence& imageFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  imageFormatType::technicalAttributeBoolean_sequence& imageFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void imageFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const imageFormatType::technicalAttributeFloat_sequence& imageFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  imageFormatType::technicalAttributeFloat_sequence& imageFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void imageFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const imageFormatType::technicalAttributeRational_sequence& imageFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  imageFormatType::technicalAttributeRational_sequence& imageFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void imageFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const imageFormatType::technicalAttributeUri_sequence& imageFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  imageFormatType::technicalAttributeUri_sequence& imageFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void imageFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const imageFormatType::comment_sequence& imageFormatType::
  comment () const
  {
    return this->comment_;
  }

  imageFormatType::comment_sequence& imageFormatType::
  comment ()
  {
    return this->comment_;
  }

  void imageFormatType::
  comment (const comment_sequence& s)
  {
    this->comment_ = s;
  }

  const imageFormatType::imageFormatId_optional& imageFormatType::
  imageFormatId () const
  {
    return this->imageFormatId_;
  }

  imageFormatType::imageFormatId_optional& imageFormatType::
  imageFormatId ()
  {
    return this->imageFormatId_;
  }

  void imageFormatType::
  imageFormatId (const imageFormatId_type& x)
  {
    this->imageFormatId_.set (x);
  }

  void imageFormatType::
  imageFormatId (const imageFormatId_optional& x)
  {
    this->imageFormatId_ = x;
  }

  void imageFormatType::
  imageFormatId (::std::auto_ptr< imageFormatId_type > x)
  {
    this->imageFormatId_.set (x);
  }

  const imageFormatType::imageFormatVersionId_optional& imageFormatType::
  imageFormatVersionId () const
  {
    return this->imageFormatVersionId_;
  }

  imageFormatType::imageFormatVersionId_optional& imageFormatType::
  imageFormatVersionId ()
  {
    return this->imageFormatVersionId_;
  }

  void imageFormatType::
  imageFormatVersionId (const imageFormatVersionId_type& x)
  {
    this->imageFormatVersionId_.set (x);
  }

  void imageFormatType::
  imageFormatVersionId (const imageFormatVersionId_optional& x)
  {
    this->imageFormatVersionId_ = x;
  }

  void imageFormatType::
  imageFormatVersionId (::std::auto_ptr< imageFormatVersionId_type > x)
  {
    this->imageFormatVersionId_.set (x);
  }

  const imageFormatType::imageFormatName_optional& imageFormatType::
  imageFormatName () const
  {
    return this->imageFormatName_;
  }

  imageFormatType::imageFormatName_optional& imageFormatType::
  imageFormatName ()
  {
    return this->imageFormatName_;
  }

  void imageFormatType::
  imageFormatName (const imageFormatName_type& x)
  {
    this->imageFormatName_.set (x);
  }

  void imageFormatType::
  imageFormatName (const imageFormatName_optional& x)
  {
    this->imageFormatName_ = x;
  }

  void imageFormatType::
  imageFormatName (::std::auto_ptr< imageFormatName_type > x)
  {
    this->imageFormatName_.set (x);
  }

  const imageFormatType::imageFormatDefinition_optional& imageFormatType::
  imageFormatDefinition () const
  {
    return this->imageFormatDefinition_;
  }

  imageFormatType::imageFormatDefinition_optional& imageFormatType::
  imageFormatDefinition ()
  {
    return this->imageFormatDefinition_;
  }

  void imageFormatType::
  imageFormatDefinition (const imageFormatDefinition_type& x)
  {
    this->imageFormatDefinition_.set (x);
  }

  void imageFormatType::
  imageFormatDefinition (const imageFormatDefinition_optional& x)
  {
    this->imageFormatDefinition_ = x;
  }

  void imageFormatType::
  imageFormatDefinition (::std::auto_ptr< imageFormatDefinition_type > x)
  {
    this->imageFormatDefinition_.set (x);
  }


  // videoFormatType
  // 

  const videoFormatType::regionDelimX_optional& videoFormatType::
  regionDelimX () const
  {
    return this->regionDelimX_;
  }

  videoFormatType::regionDelimX_optional& videoFormatType::
  regionDelimX ()
  {
    return this->regionDelimX_;
  }

  void videoFormatType::
  regionDelimX (const regionDelimX_type& x)
  {
    this->regionDelimX_.set (x);
  }

  void videoFormatType::
  regionDelimX (const regionDelimX_optional& x)
  {
    this->regionDelimX_ = x;
  }

  const videoFormatType::regionDelimY_optional& videoFormatType::
  regionDelimY () const
  {
    return this->regionDelimY_;
  }

  videoFormatType::regionDelimY_optional& videoFormatType::
  regionDelimY ()
  {
    return this->regionDelimY_;
  }

  void videoFormatType::
  regionDelimY (const regionDelimY_type& x)
  {
    this->regionDelimY_.set (x);
  }

  void videoFormatType::
  regionDelimY (const regionDelimY_optional& x)
  {
    this->regionDelimY_ = x;
  }

  const videoFormatType::width_sequence& videoFormatType::
  width () const
  {
    return this->width_;
  }

  videoFormatType::width_sequence& videoFormatType::
  width ()
  {
    return this->width_;
  }

  void videoFormatType::
  width (const width_sequence& s)
  {
    this->width_ = s;
  }

  const videoFormatType::height_sequence& videoFormatType::
  height () const
  {
    return this->height_;
  }

  videoFormatType::height_sequence& videoFormatType::
  height ()
  {
    return this->height_;
  }

  void videoFormatType::
  height (const height_sequence& s)
  {
    this->height_ = s;
  }

  const videoFormatType::lines_optional& videoFormatType::
  lines () const
  {
    return this->lines_;
  }

  videoFormatType::lines_optional& videoFormatType::
  lines ()
  {
    return this->lines_;
  }

  void videoFormatType::
  lines (const lines_type& x)
  {
    this->lines_.set (x);
  }

  void videoFormatType::
  lines (const lines_optional& x)
  {
    this->lines_ = x;
  }

  const videoFormatType::frameRate_optional& videoFormatType::
  frameRate () const
  {
    return this->frameRate_;
  }

  videoFormatType::frameRate_optional& videoFormatType::
  frameRate ()
  {
    return this->frameRate_;
  }

  void videoFormatType::
  frameRate (const frameRate_type& x)
  {
    this->frameRate_.set (x);
  }

  void videoFormatType::
  frameRate (const frameRate_optional& x)
  {
    this->frameRate_ = x;
  }

  void videoFormatType::
  frameRate (::std::auto_ptr< frameRate_type > x)
  {
    this->frameRate_.set (x);
  }

  const videoFormatType::aspectRatio_sequence& videoFormatType::
  aspectRatio () const
  {
    return this->aspectRatio_;
  }

  videoFormatType::aspectRatio_sequence& videoFormatType::
  aspectRatio ()
  {
    return this->aspectRatio_;
  }

  void videoFormatType::
  aspectRatio (const aspectRatio_sequence& s)
  {
    this->aspectRatio_ = s;
  }

  const videoFormatType::videoEncoding_optional& videoFormatType::
  videoEncoding () const
  {
    return this->videoEncoding_;
  }

  videoFormatType::videoEncoding_optional& videoFormatType::
  videoEncoding ()
  {
    return this->videoEncoding_;
  }

  void videoFormatType::
  videoEncoding (const videoEncoding_type& x)
  {
    this->videoEncoding_.set (x);
  }

  void videoFormatType::
  videoEncoding (const videoEncoding_optional& x)
  {
    this->videoEncoding_ = x;
  }

  void videoFormatType::
  videoEncoding (::std::auto_ptr< videoEncoding_type > x)
  {
    this->videoEncoding_.set (x);
  }

  const videoFormatType::codec_optional& videoFormatType::
  codec () const
  {
    return this->codec_;
  }

  videoFormatType::codec_optional& videoFormatType::
  codec ()
  {
    return this->codec_;
  }

  void videoFormatType::
  codec (const codec_type& x)
  {
    this->codec_.set (x);
  }

  void videoFormatType::
  codec (const codec_optional& x)
  {
    this->codec_ = x;
  }

  void videoFormatType::
  codec (::std::auto_ptr< codec_type > x)
  {
    this->codec_.set (x);
  }

  const videoFormatType::bitRate_optional& videoFormatType::
  bitRate () const
  {
    return this->bitRate_;
  }

  videoFormatType::bitRate_optional& videoFormatType::
  bitRate ()
  {
    return this->bitRate_;
  }

  void videoFormatType::
  bitRate (const bitRate_type& x)
  {
    this->bitRate_.set (x);
  }

  void videoFormatType::
  bitRate (const bitRate_optional& x)
  {
    this->bitRate_ = x;
  }

  const videoFormatType::bitRateMax_optional& videoFormatType::
  bitRateMax () const
  {
    return this->bitRateMax_;
  }

  videoFormatType::bitRateMax_optional& videoFormatType::
  bitRateMax ()
  {
    return this->bitRateMax_;
  }

  void videoFormatType::
  bitRateMax (const bitRateMax_type& x)
  {
    this->bitRateMax_.set (x);
  }

  void videoFormatType::
  bitRateMax (const bitRateMax_optional& x)
  {
    this->bitRateMax_ = x;
  }

  const videoFormatType::bitRateMode_optional& videoFormatType::
  bitRateMode () const
  {
    return this->bitRateMode_;
  }

  videoFormatType::bitRateMode_optional& videoFormatType::
  bitRateMode ()
  {
    return this->bitRateMode_;
  }

  void videoFormatType::
  bitRateMode (const bitRateMode_type& x)
  {
    this->bitRateMode_.set (x);
  }

  void videoFormatType::
  bitRateMode (const bitRateMode_optional& x)
  {
    this->bitRateMode_ = x;
  }

  void videoFormatType::
  bitRateMode (::std::auto_ptr< bitRateMode_type > x)
  {
    this->bitRateMode_.set (x);
  }

  const videoFormatType::scanningFormat_optional& videoFormatType::
  scanningFormat () const
  {
    return this->scanningFormat_;
  }

  videoFormatType::scanningFormat_optional& videoFormatType::
  scanningFormat ()
  {
    return this->scanningFormat_;
  }

  void videoFormatType::
  scanningFormat (const scanningFormat_type& x)
  {
    this->scanningFormat_.set (x);
  }

  void videoFormatType::
  scanningFormat (const scanningFormat_optional& x)
  {
    this->scanningFormat_ = x;
  }

  void videoFormatType::
  scanningFormat (::std::auto_ptr< scanningFormat_type > x)
  {
    this->scanningFormat_.set (x);
  }

  const videoFormatType::scanningOrder_optional& videoFormatType::
  scanningOrder () const
  {
    return this->scanningOrder_;
  }

  videoFormatType::scanningOrder_optional& videoFormatType::
  scanningOrder ()
  {
    return this->scanningOrder_;
  }

  void videoFormatType::
  scanningOrder (const scanningOrder_type& x)
  {
    this->scanningOrder_.set (x);
  }

  void videoFormatType::
  scanningOrder (const scanningOrder_optional& x)
  {
    this->scanningOrder_ = x;
  }

  void videoFormatType::
  scanningOrder (::std::auto_ptr< scanningOrder_type > x)
  {
    this->scanningOrder_.set (x);
  }

  const videoFormatType::noiseFilter_optional& videoFormatType::
  noiseFilter () const
  {
    return this->noiseFilter_;
  }

  videoFormatType::noiseFilter_optional& videoFormatType::
  noiseFilter ()
  {
    return this->noiseFilter_;
  }

  void videoFormatType::
  noiseFilter (const noiseFilter_type& x)
  {
    this->noiseFilter_.set (x);
  }

  void videoFormatType::
  noiseFilter (const noiseFilter_optional& x)
  {
    this->noiseFilter_ = x;
  }

  const videoFormatType::videoTrack_sequence& videoFormatType::
  videoTrack () const
  {
    return this->videoTrack_;
  }

  videoFormatType::videoTrack_sequence& videoFormatType::
  videoTrack ()
  {
    return this->videoTrack_;
  }

  void videoFormatType::
  videoTrack (const videoTrack_sequence& s)
  {
    this->videoTrack_ = s;
  }

  const videoFormatType::flag_3D_optional& videoFormatType::
  flag_3D () const
  {
    return this->flag_3D_;
  }

  videoFormatType::flag_3D_optional& videoFormatType::
  flag_3D ()
  {
    return this->flag_3D_;
  }

  void videoFormatType::
  flag_3D (const flag_3D_type& x)
  {
    this->flag_3D_.set (x);
  }

  void videoFormatType::
  flag_3D (const flag_3D_optional& x)
  {
    this->flag_3D_ = x;
  }

  const videoFormatType::technicalAttributeString_sequence& videoFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  videoFormatType::technicalAttributeString_sequence& videoFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void videoFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const videoFormatType::technicalAttributeByte_sequence& videoFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  videoFormatType::technicalAttributeByte_sequence& videoFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void videoFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const videoFormatType::technicalAttributeShort_sequence& videoFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  videoFormatType::technicalAttributeShort_sequence& videoFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void videoFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const videoFormatType::technicalAttributeInteger_sequence& videoFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  videoFormatType::technicalAttributeInteger_sequence& videoFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void videoFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const videoFormatType::technicalAttributeLong_sequence& videoFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  videoFormatType::technicalAttributeLong_sequence& videoFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void videoFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const videoFormatType::technicalAttributeUnsignedByte_sequence& videoFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  videoFormatType::technicalAttributeUnsignedByte_sequence& videoFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void videoFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const videoFormatType::technicalAttributeUnsignedShort_sequence& videoFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  videoFormatType::technicalAttributeUnsignedShort_sequence& videoFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void videoFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const videoFormatType::technicalAttributeUnsignedInteger_sequence& videoFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  videoFormatType::technicalAttributeUnsignedInteger_sequence& videoFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void videoFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const videoFormatType::technicalAttributeUnsignedLong_sequence& videoFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  videoFormatType::technicalAttributeUnsignedLong_sequence& videoFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void videoFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const videoFormatType::technicalAttributeBoolean_sequence& videoFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  videoFormatType::technicalAttributeBoolean_sequence& videoFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void videoFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const videoFormatType::technicalAttributeFloat_sequence& videoFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  videoFormatType::technicalAttributeFloat_sequence& videoFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void videoFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const videoFormatType::technicalAttributeRational_sequence& videoFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  videoFormatType::technicalAttributeRational_sequence& videoFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void videoFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const videoFormatType::technicalAttributeUri_sequence& videoFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  videoFormatType::technicalAttributeUri_sequence& videoFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void videoFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const videoFormatType::comment_sequence& videoFormatType::
  comment () const
  {
    return this->comment_;
  }

  videoFormatType::comment_sequence& videoFormatType::
  comment ()
  {
    return this->comment_;
  }

  void videoFormatType::
  comment (const comment_sequence& s)
  {
    this->comment_ = s;
  }

  const videoFormatType::videoFormatId_optional& videoFormatType::
  videoFormatId () const
  {
    return this->videoFormatId_;
  }

  videoFormatType::videoFormatId_optional& videoFormatType::
  videoFormatId ()
  {
    return this->videoFormatId_;
  }

  void videoFormatType::
  videoFormatId (const videoFormatId_type& x)
  {
    this->videoFormatId_.set (x);
  }

  void videoFormatType::
  videoFormatId (const videoFormatId_optional& x)
  {
    this->videoFormatId_ = x;
  }

  void videoFormatType::
  videoFormatId (::std::auto_ptr< videoFormatId_type > x)
  {
    this->videoFormatId_.set (x);
  }

  const videoFormatType::videoFormatVersionId_optional& videoFormatType::
  videoFormatVersionId () const
  {
    return this->videoFormatVersionId_;
  }

  videoFormatType::videoFormatVersionId_optional& videoFormatType::
  videoFormatVersionId ()
  {
    return this->videoFormatVersionId_;
  }

  void videoFormatType::
  videoFormatVersionId (const videoFormatVersionId_type& x)
  {
    this->videoFormatVersionId_.set (x);
  }

  void videoFormatType::
  videoFormatVersionId (const videoFormatVersionId_optional& x)
  {
    this->videoFormatVersionId_ = x;
  }

  void videoFormatType::
  videoFormatVersionId (::std::auto_ptr< videoFormatVersionId_type > x)
  {
    this->videoFormatVersionId_.set (x);
  }

  const videoFormatType::videoFormatName_optional& videoFormatType::
  videoFormatName () const
  {
    return this->videoFormatName_;
  }

  videoFormatType::videoFormatName_optional& videoFormatType::
  videoFormatName ()
  {
    return this->videoFormatName_;
  }

  void videoFormatType::
  videoFormatName (const videoFormatName_type& x)
  {
    this->videoFormatName_.set (x);
  }

  void videoFormatType::
  videoFormatName (const videoFormatName_optional& x)
  {
    this->videoFormatName_ = x;
  }

  void videoFormatType::
  videoFormatName (::std::auto_ptr< videoFormatName_type > x)
  {
    this->videoFormatName_.set (x);
  }

  const videoFormatType::videoFormatDefinition_optional& videoFormatType::
  videoFormatDefinition () const
  {
    return this->videoFormatDefinition_;
  }

  videoFormatType::videoFormatDefinition_optional& videoFormatType::
  videoFormatDefinition ()
  {
    return this->videoFormatDefinition_;
  }

  void videoFormatType::
  videoFormatDefinition (const videoFormatDefinition_type& x)
  {
    this->videoFormatDefinition_.set (x);
  }

  void videoFormatType::
  videoFormatDefinition (const videoFormatDefinition_optional& x)
  {
    this->videoFormatDefinition_ = x;
  }

  void videoFormatType::
  videoFormatDefinition (::std::auto_ptr< videoFormatDefinition_type > x)
  {
    this->videoFormatDefinition_.set (x);
  }


  // audioFormatType
  // 

  const audioFormatType::audioEncoding_optional& audioFormatType::
  audioEncoding () const
  {
    return this->audioEncoding_;
  }

  audioFormatType::audioEncoding_optional& audioFormatType::
  audioEncoding ()
  {
    return this->audioEncoding_;
  }

  void audioFormatType::
  audioEncoding (const audioEncoding_type& x)
  {
    this->audioEncoding_.set (x);
  }

  void audioFormatType::
  audioEncoding (const audioEncoding_optional& x)
  {
    this->audioEncoding_ = x;
  }

  void audioFormatType::
  audioEncoding (::std::auto_ptr< audioEncoding_type > x)
  {
    this->audioEncoding_.set (x);
  }

  const audioFormatType::codec_optional& audioFormatType::
  codec () const
  {
    return this->codec_;
  }

  audioFormatType::codec_optional& audioFormatType::
  codec ()
  {
    return this->codec_;
  }

  void audioFormatType::
  codec (const codec_type& x)
  {
    this->codec_.set (x);
  }

  void audioFormatType::
  codec (const codec_optional& x)
  {
    this->codec_ = x;
  }

  void audioFormatType::
  codec (::std::auto_ptr< codec_type > x)
  {
    this->codec_.set (x);
  }

  const audioFormatType::audioTrackConfiguration_optional& audioFormatType::
  audioTrackConfiguration () const
  {
    return this->audioTrackConfiguration_;
  }

  audioFormatType::audioTrackConfiguration_optional& audioFormatType::
  audioTrackConfiguration ()
  {
    return this->audioTrackConfiguration_;
  }

  void audioFormatType::
  audioTrackConfiguration (const audioTrackConfiguration_type& x)
  {
    this->audioTrackConfiguration_.set (x);
  }

  void audioFormatType::
  audioTrackConfiguration (const audioTrackConfiguration_optional& x)
  {
    this->audioTrackConfiguration_ = x;
  }

  void audioFormatType::
  audioTrackConfiguration (::std::auto_ptr< audioTrackConfiguration_type > x)
  {
    this->audioTrackConfiguration_.set (x);
  }

  const audioFormatType::samplingRate_optional& audioFormatType::
  samplingRate () const
  {
    return this->samplingRate_;
  }

  audioFormatType::samplingRate_optional& audioFormatType::
  samplingRate ()
  {
    return this->samplingRate_;
  }

  void audioFormatType::
  samplingRate (const samplingRate_type& x)
  {
    this->samplingRate_.set (x);
  }

  void audioFormatType::
  samplingRate (const samplingRate_optional& x)
  {
    this->samplingRate_ = x;
  }

  const audioFormatType::sampleSize_optional& audioFormatType::
  sampleSize () const
  {
    return this->sampleSize_;
  }

  audioFormatType::sampleSize_optional& audioFormatType::
  sampleSize ()
  {
    return this->sampleSize_;
  }

  void audioFormatType::
  sampleSize (const sampleSize_type& x)
  {
    this->sampleSize_.set (x);
  }

  void audioFormatType::
  sampleSize (const sampleSize_optional& x)
  {
    this->sampleSize_ = x;
  }

  const audioFormatType::sampleType_optional& audioFormatType::
  sampleType () const
  {
    return this->sampleType_;
  }

  audioFormatType::sampleType_optional& audioFormatType::
  sampleType ()
  {
    return this->sampleType_;
  }

  void audioFormatType::
  sampleType (const sampleType_type& x)
  {
    this->sampleType_.set (x);
  }

  void audioFormatType::
  sampleType (const sampleType_optional& x)
  {
    this->sampleType_ = x;
  }

  void audioFormatType::
  sampleType (::std::auto_ptr< sampleType_type > x)
  {
    this->sampleType_.set (x);
  }

  const audioFormatType::bitRate_optional& audioFormatType::
  bitRate () const
  {
    return this->bitRate_;
  }

  audioFormatType::bitRate_optional& audioFormatType::
  bitRate ()
  {
    return this->bitRate_;
  }

  void audioFormatType::
  bitRate (const bitRate_type& x)
  {
    this->bitRate_.set (x);
  }

  void audioFormatType::
  bitRate (const bitRate_optional& x)
  {
    this->bitRate_ = x;
  }

  const audioFormatType::bitRateMax_optional& audioFormatType::
  bitRateMax () const
  {
    return this->bitRateMax_;
  }

  audioFormatType::bitRateMax_optional& audioFormatType::
  bitRateMax ()
  {
    return this->bitRateMax_;
  }

  void audioFormatType::
  bitRateMax (const bitRateMax_type& x)
  {
    this->bitRateMax_.set (x);
  }

  void audioFormatType::
  bitRateMax (const bitRateMax_optional& x)
  {
    this->bitRateMax_ = x;
  }

  const audioFormatType::bitRateMode_optional& audioFormatType::
  bitRateMode () const
  {
    return this->bitRateMode_;
  }

  audioFormatType::bitRateMode_optional& audioFormatType::
  bitRateMode ()
  {
    return this->bitRateMode_;
  }

  void audioFormatType::
  bitRateMode (const bitRateMode_type& x)
  {
    this->bitRateMode_.set (x);
  }

  void audioFormatType::
  bitRateMode (const bitRateMode_optional& x)
  {
    this->bitRateMode_ = x;
  }

  void audioFormatType::
  bitRateMode (::std::auto_ptr< bitRateMode_type > x)
  {
    this->bitRateMode_.set (x);
  }

  const audioFormatType::audioTrack_sequence& audioFormatType::
  audioTrack () const
  {
    return this->audioTrack_;
  }

  audioFormatType::audioTrack_sequence& audioFormatType::
  audioTrack ()
  {
    return this->audioTrack_;
  }

  void audioFormatType::
  audioTrack (const audioTrack_sequence& s)
  {
    this->audioTrack_ = s;
  }

  const audioFormatType::channels_optional& audioFormatType::
  channels () const
  {
    return this->channels_;
  }

  audioFormatType::channels_optional& audioFormatType::
  channels ()
  {
    return this->channels_;
  }

  void audioFormatType::
  channels (const channels_type& x)
  {
    this->channels_.set (x);
  }

  void audioFormatType::
  channels (const channels_optional& x)
  {
    this->channels_ = x;
  }

  const audioFormatType::technicalAttributeString_sequence& audioFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  audioFormatType::technicalAttributeString_sequence& audioFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void audioFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const audioFormatType::technicalAttributeByte_sequence& audioFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  audioFormatType::technicalAttributeByte_sequence& audioFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void audioFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const audioFormatType::technicalAttributeShort_sequence& audioFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  audioFormatType::technicalAttributeShort_sequence& audioFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void audioFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const audioFormatType::technicalAttributeInteger_sequence& audioFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  audioFormatType::technicalAttributeInteger_sequence& audioFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void audioFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const audioFormatType::technicalAttributeLong_sequence& audioFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  audioFormatType::technicalAttributeLong_sequence& audioFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void audioFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const audioFormatType::technicalAttributeUnsignedByte_sequence& audioFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  audioFormatType::technicalAttributeUnsignedByte_sequence& audioFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void audioFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const audioFormatType::technicalAttributeUnsignedShort_sequence& audioFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  audioFormatType::technicalAttributeUnsignedShort_sequence& audioFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void audioFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const audioFormatType::technicalAttributeUnsignedInteger_sequence& audioFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  audioFormatType::technicalAttributeUnsignedInteger_sequence& audioFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void audioFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const audioFormatType::technicalAttributeUnsignedLong_sequence& audioFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  audioFormatType::technicalAttributeUnsignedLong_sequence& audioFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void audioFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const audioFormatType::technicalAttributeBoolean_sequence& audioFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  audioFormatType::technicalAttributeBoolean_sequence& audioFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void audioFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const audioFormatType::technicalAttributeFloat_sequence& audioFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  audioFormatType::technicalAttributeFloat_sequence& audioFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void audioFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const audioFormatType::technicalAttributeRational_sequence& audioFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  audioFormatType::technicalAttributeRational_sequence& audioFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void audioFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const audioFormatType::technicalAttributeUri_sequence& audioFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  audioFormatType::technicalAttributeUri_sequence& audioFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void audioFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const audioFormatType::comment_sequence& audioFormatType::
  comment () const
  {
    return this->comment_;
  }

  audioFormatType::comment_sequence& audioFormatType::
  comment ()
  {
    return this->comment_;
  }

  void audioFormatType::
  comment (const comment_sequence& s)
  {
    this->comment_ = s;
  }

  const audioFormatType::audioFormatId_optional& audioFormatType::
  audioFormatId () const
  {
    return this->audioFormatId_;
  }

  audioFormatType::audioFormatId_optional& audioFormatType::
  audioFormatId ()
  {
    return this->audioFormatId_;
  }

  void audioFormatType::
  audioFormatId (const audioFormatId_type& x)
  {
    this->audioFormatId_.set (x);
  }

  void audioFormatType::
  audioFormatId (const audioFormatId_optional& x)
  {
    this->audioFormatId_ = x;
  }

  void audioFormatType::
  audioFormatId (::std::auto_ptr< audioFormatId_type > x)
  {
    this->audioFormatId_.set (x);
  }

  const audioFormatType::audioFormatVersionId_optional& audioFormatType::
  audioFormatVersionId () const
  {
    return this->audioFormatVersionId_;
  }

  audioFormatType::audioFormatVersionId_optional& audioFormatType::
  audioFormatVersionId ()
  {
    return this->audioFormatVersionId_;
  }

  void audioFormatType::
  audioFormatVersionId (const audioFormatVersionId_type& x)
  {
    this->audioFormatVersionId_.set (x);
  }

  void audioFormatType::
  audioFormatVersionId (const audioFormatVersionId_optional& x)
  {
    this->audioFormatVersionId_ = x;
  }

  void audioFormatType::
  audioFormatVersionId (::std::auto_ptr< audioFormatVersionId_type > x)
  {
    this->audioFormatVersionId_.set (x);
  }

  const audioFormatType::audioFormatName_optional& audioFormatType::
  audioFormatName () const
  {
    return this->audioFormatName_;
  }

  audioFormatType::audioFormatName_optional& audioFormatType::
  audioFormatName ()
  {
    return this->audioFormatName_;
  }

  void audioFormatType::
  audioFormatName (const audioFormatName_type& x)
  {
    this->audioFormatName_.set (x);
  }

  void audioFormatType::
  audioFormatName (const audioFormatName_optional& x)
  {
    this->audioFormatName_ = x;
  }

  void audioFormatType::
  audioFormatName (::std::auto_ptr< audioFormatName_type > x)
  {
    this->audioFormatName_.set (x);
  }

  const audioFormatType::audioFormatDefinition_optional& audioFormatType::
  audioFormatDefinition () const
  {
    return this->audioFormatDefinition_;
  }

  audioFormatType::audioFormatDefinition_optional& audioFormatType::
  audioFormatDefinition ()
  {
    return this->audioFormatDefinition_;
  }

  void audioFormatType::
  audioFormatDefinition (const audioFormatDefinition_type& x)
  {
    this->audioFormatDefinition_.set (x);
  }

  void audioFormatType::
  audioFormatDefinition (const audioFormatDefinition_optional& x)
  {
    this->audioFormatDefinition_ = x;
  }

  void audioFormatType::
  audioFormatDefinition (::std::auto_ptr< audioFormatDefinition_type > x)
  {
    this->audioFormatDefinition_.set (x);
  }


  // dataFormatType
  // 

  const dataFormatType::captioningFormat_sequence& dataFormatType::
  captioningFormat () const
  {
    return this->captioningFormat_;
  }

  dataFormatType::captioningFormat_sequence& dataFormatType::
  captioningFormat ()
  {
    return this->captioningFormat_;
  }

  void dataFormatType::
  captioningFormat (const captioningFormat_sequence& s)
  {
    this->captioningFormat_ = s;
  }

  const dataFormatType::subtitlingFormat_sequence& dataFormatType::
  subtitlingFormat () const
  {
    return this->subtitlingFormat_;
  }

  dataFormatType::subtitlingFormat_sequence& dataFormatType::
  subtitlingFormat ()
  {
    return this->subtitlingFormat_;
  }

  void dataFormatType::
  subtitlingFormat (const subtitlingFormat_sequence& s)
  {
    this->subtitlingFormat_ = s;
  }

  const dataFormatType::ancillaryDataFormat_sequence& dataFormatType::
  ancillaryDataFormat () const
  {
    return this->ancillaryDataFormat_;
  }

  dataFormatType::ancillaryDataFormat_sequence& dataFormatType::
  ancillaryDataFormat ()
  {
    return this->ancillaryDataFormat_;
  }

  void dataFormatType::
  ancillaryDataFormat (const ancillaryDataFormat_sequence& s)
  {
    this->ancillaryDataFormat_ = s;
  }

  const dataFormatType::technicalAttributeString_sequence& dataFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  dataFormatType::technicalAttributeString_sequence& dataFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void dataFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const dataFormatType::technicalAttributeByte_sequence& dataFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  dataFormatType::technicalAttributeByte_sequence& dataFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void dataFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const dataFormatType::technicalAttributeShort_sequence& dataFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  dataFormatType::technicalAttributeShort_sequence& dataFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void dataFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const dataFormatType::technicalAttributeInteger_sequence& dataFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  dataFormatType::technicalAttributeInteger_sequence& dataFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void dataFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const dataFormatType::technicalAttributeLong_sequence& dataFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  dataFormatType::technicalAttributeLong_sequence& dataFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void dataFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const dataFormatType::technicalAttributeUnsignedByte_sequence& dataFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  dataFormatType::technicalAttributeUnsignedByte_sequence& dataFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void dataFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const dataFormatType::technicalAttributeUnsignedShort_sequence& dataFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  dataFormatType::technicalAttributeUnsignedShort_sequence& dataFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void dataFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const dataFormatType::technicalAttributeUnsignedInteger_sequence& dataFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  dataFormatType::technicalAttributeUnsignedInteger_sequence& dataFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void dataFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const dataFormatType::technicalAttributeUnsignedLong_sequence& dataFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  dataFormatType::technicalAttributeUnsignedLong_sequence& dataFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void dataFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const dataFormatType::technicalAttributeBoolean_sequence& dataFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  dataFormatType::technicalAttributeBoolean_sequence& dataFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void dataFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const dataFormatType::technicalAttributeFloat_sequence& dataFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  dataFormatType::technicalAttributeFloat_sequence& dataFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void dataFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const dataFormatType::technicalAttributeRational_sequence& dataFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  dataFormatType::technicalAttributeRational_sequence& dataFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void dataFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const dataFormatType::technicalAttributeUri_sequence& dataFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  dataFormatType::technicalAttributeUri_sequence& dataFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void dataFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const dataFormatType::comment_sequence& dataFormatType::
  comment () const
  {
    return this->comment_;
  }

  dataFormatType::comment_sequence& dataFormatType::
  comment ()
  {
    return this->comment_;
  }

  void dataFormatType::
  comment (const comment_sequence& s)
  {
    this->comment_ = s;
  }

  const dataFormatType::dataFormatId_optional& dataFormatType::
  dataFormatId () const
  {
    return this->dataFormatId_;
  }

  dataFormatType::dataFormatId_optional& dataFormatType::
  dataFormatId ()
  {
    return this->dataFormatId_;
  }

  void dataFormatType::
  dataFormatId (const dataFormatId_type& x)
  {
    this->dataFormatId_.set (x);
  }

  void dataFormatType::
  dataFormatId (const dataFormatId_optional& x)
  {
    this->dataFormatId_ = x;
  }

  void dataFormatType::
  dataFormatId (::std::auto_ptr< dataFormatId_type > x)
  {
    this->dataFormatId_.set (x);
  }

  const dataFormatType::dataFormatVersionId_optional& dataFormatType::
  dataFormatVersionId () const
  {
    return this->dataFormatVersionId_;
  }

  dataFormatType::dataFormatVersionId_optional& dataFormatType::
  dataFormatVersionId ()
  {
    return this->dataFormatVersionId_;
  }

  void dataFormatType::
  dataFormatVersionId (const dataFormatVersionId_type& x)
  {
    this->dataFormatVersionId_.set (x);
  }

  void dataFormatType::
  dataFormatVersionId (const dataFormatVersionId_optional& x)
  {
    this->dataFormatVersionId_ = x;
  }

  void dataFormatType::
  dataFormatVersionId (::std::auto_ptr< dataFormatVersionId_type > x)
  {
    this->dataFormatVersionId_.set (x);
  }

  const dataFormatType::dataFormatName_optional& dataFormatType::
  dataFormatName () const
  {
    return this->dataFormatName_;
  }

  dataFormatType::dataFormatName_optional& dataFormatType::
  dataFormatName ()
  {
    return this->dataFormatName_;
  }

  void dataFormatType::
  dataFormatName (const dataFormatName_type& x)
  {
    this->dataFormatName_.set (x);
  }

  void dataFormatType::
  dataFormatName (const dataFormatName_optional& x)
  {
    this->dataFormatName_ = x;
  }

  void dataFormatType::
  dataFormatName (::std::auto_ptr< dataFormatName_type > x)
  {
    this->dataFormatName_.set (x);
  }

  const dataFormatType::dataFormatDefinition_optional& dataFormatType::
  dataFormatDefinition () const
  {
    return this->dataFormatDefinition_;
  }

  dataFormatType::dataFormatDefinition_optional& dataFormatType::
  dataFormatDefinition ()
  {
    return this->dataFormatDefinition_;
  }

  void dataFormatType::
  dataFormatDefinition (const dataFormatDefinition_type& x)
  {
    this->dataFormatDefinition_.set (x);
  }

  void dataFormatType::
  dataFormatDefinition (const dataFormatDefinition_optional& x)
  {
    this->dataFormatDefinition_ = x;
  }

  void dataFormatType::
  dataFormatDefinition (::std::auto_ptr< dataFormatDefinition_type > x)
  {
    this->dataFormatDefinition_.set (x);
  }

  const dataFormatType::dataTrackId_optional& dataFormatType::
  dataTrackId () const
  {
    return this->dataTrackId_;
  }

  dataFormatType::dataTrackId_optional& dataFormatType::
  dataTrackId ()
  {
    return this->dataTrackId_;
  }

  void dataFormatType::
  dataTrackId (const dataTrackId_type& x)
  {
    this->dataTrackId_.set (x);
  }

  void dataFormatType::
  dataTrackId (const dataTrackId_optional& x)
  {
    this->dataTrackId_ = x;
  }

  void dataFormatType::
  dataTrackId (::std::auto_ptr< dataTrackId_type > x)
  {
    this->dataTrackId_.set (x);
  }

  const dataFormatType::dataTrackName_optional& dataFormatType::
  dataTrackName () const
  {
    return this->dataTrackName_;
  }

  dataFormatType::dataTrackName_optional& dataFormatType::
  dataTrackName ()
  {
    return this->dataTrackName_;
  }

  void dataFormatType::
  dataTrackName (const dataTrackName_type& x)
  {
    this->dataTrackName_.set (x);
  }

  void dataFormatType::
  dataTrackName (const dataTrackName_optional& x)
  {
    this->dataTrackName_ = x;
  }

  void dataFormatType::
  dataTrackName (::std::auto_ptr< dataTrackName_type > x)
  {
    this->dataTrackName_.set (x);
  }

  const dataFormatType::dataTrackLanguage_optional& dataFormatType::
  dataTrackLanguage () const
  {
    return this->dataTrackLanguage_;
  }

  dataFormatType::dataTrackLanguage_optional& dataFormatType::
  dataTrackLanguage ()
  {
    return this->dataTrackLanguage_;
  }

  void dataFormatType::
  dataTrackLanguage (const dataTrackLanguage_type& x)
  {
    this->dataTrackLanguage_.set (x);
  }

  void dataFormatType::
  dataTrackLanguage (const dataTrackLanguage_optional& x)
  {
    this->dataTrackLanguage_ = x;
  }

  void dataFormatType::
  dataTrackLanguage (::std::auto_ptr< dataTrackLanguage_type > x)
  {
    this->dataTrackLanguage_.set (x);
  }


  // documentFormatType
  // 

  const documentFormatType::wordCount_optional& documentFormatType::
  wordCount () const
  {
    return this->wordCount_;
  }

  documentFormatType::wordCount_optional& documentFormatType::
  wordCount ()
  {
    return this->wordCount_;
  }

  void documentFormatType::
  wordCount (const wordCount_type& x)
  {
    this->wordCount_.set (x);
  }

  void documentFormatType::
  wordCount (const wordCount_optional& x)
  {
    this->wordCount_ = x;
  }

  const documentFormatType::regionDelimX_optional& documentFormatType::
  regionDelimX () const
  {
    return this->regionDelimX_;
  }

  documentFormatType::regionDelimX_optional& documentFormatType::
  regionDelimX ()
  {
    return this->regionDelimX_;
  }

  void documentFormatType::
  regionDelimX (const regionDelimX_type& x)
  {
    this->regionDelimX_.set (x);
  }

  void documentFormatType::
  regionDelimX (const regionDelimX_optional& x)
  {
    this->regionDelimX_ = x;
  }

  const documentFormatType::regionDelimY_optional& documentFormatType::
  regionDelimY () const
  {
    return this->regionDelimY_;
  }

  documentFormatType::regionDelimY_optional& documentFormatType::
  regionDelimY ()
  {
    return this->regionDelimY_;
  }

  void documentFormatType::
  regionDelimY (const regionDelimY_type& x)
  {
    this->regionDelimY_.set (x);
  }

  void documentFormatType::
  regionDelimY (const regionDelimY_optional& x)
  {
    this->regionDelimY_ = x;
  }

  const documentFormatType::width_optional& documentFormatType::
  width () const
  {
    return this->width_;
  }

  documentFormatType::width_optional& documentFormatType::
  width ()
  {
    return this->width_;
  }

  void documentFormatType::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void documentFormatType::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void documentFormatType::
  width (::std::auto_ptr< width_type > x)
  {
    this->width_.set (x);
  }

  const documentFormatType::height_optional& documentFormatType::
  height () const
  {
    return this->height_;
  }

  documentFormatType::height_optional& documentFormatType::
  height ()
  {
    return this->height_;
  }

  void documentFormatType::
  height (const height_type& x)
  {
    this->height_.set (x);
  }

  void documentFormatType::
  height (const height_optional& x)
  {
    this->height_ = x;
  }

  void documentFormatType::
  height (::std::auto_ptr< height_type > x)
  {
    this->height_.set (x);
  }

  const documentFormatType::technicalAttributeString_sequence& documentFormatType::
  technicalAttributeString () const
  {
    return this->technicalAttributeString_;
  }

  documentFormatType::technicalAttributeString_sequence& documentFormatType::
  technicalAttributeString ()
  {
    return this->technicalAttributeString_;
  }

  void documentFormatType::
  technicalAttributeString (const technicalAttributeString_sequence& s)
  {
    this->technicalAttributeString_ = s;
  }

  const documentFormatType::technicalAttributeByte_sequence& documentFormatType::
  technicalAttributeByte () const
  {
    return this->technicalAttributeByte_;
  }

  documentFormatType::technicalAttributeByte_sequence& documentFormatType::
  technicalAttributeByte ()
  {
    return this->technicalAttributeByte_;
  }

  void documentFormatType::
  technicalAttributeByte (const technicalAttributeByte_sequence& s)
  {
    this->technicalAttributeByte_ = s;
  }

  const documentFormatType::technicalAttributeShort_sequence& documentFormatType::
  technicalAttributeShort () const
  {
    return this->technicalAttributeShort_;
  }

  documentFormatType::technicalAttributeShort_sequence& documentFormatType::
  technicalAttributeShort ()
  {
    return this->technicalAttributeShort_;
  }

  void documentFormatType::
  technicalAttributeShort (const technicalAttributeShort_sequence& s)
  {
    this->technicalAttributeShort_ = s;
  }

  const documentFormatType::technicalAttributeInteger_sequence& documentFormatType::
  technicalAttributeInteger () const
  {
    return this->technicalAttributeInteger_;
  }

  documentFormatType::technicalAttributeInteger_sequence& documentFormatType::
  technicalAttributeInteger ()
  {
    return this->technicalAttributeInteger_;
  }

  void documentFormatType::
  technicalAttributeInteger (const technicalAttributeInteger_sequence& s)
  {
    this->technicalAttributeInteger_ = s;
  }

  const documentFormatType::technicalAttributeLong_sequence& documentFormatType::
  technicalAttributeLong () const
  {
    return this->technicalAttributeLong_;
  }

  documentFormatType::technicalAttributeLong_sequence& documentFormatType::
  technicalAttributeLong ()
  {
    return this->technicalAttributeLong_;
  }

  void documentFormatType::
  technicalAttributeLong (const technicalAttributeLong_sequence& s)
  {
    this->technicalAttributeLong_ = s;
  }

  const documentFormatType::technicalAttributeUnsignedByte_sequence& documentFormatType::
  technicalAttributeUnsignedByte () const
  {
    return this->technicalAttributeUnsignedByte_;
  }

  documentFormatType::technicalAttributeUnsignedByte_sequence& documentFormatType::
  technicalAttributeUnsignedByte ()
  {
    return this->technicalAttributeUnsignedByte_;
  }

  void documentFormatType::
  technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s)
  {
    this->technicalAttributeUnsignedByte_ = s;
  }

  const documentFormatType::technicalAttributeUnsignedShort_sequence& documentFormatType::
  technicalAttributeUnsignedShort () const
  {
    return this->technicalAttributeUnsignedShort_;
  }

  documentFormatType::technicalAttributeUnsignedShort_sequence& documentFormatType::
  technicalAttributeUnsignedShort ()
  {
    return this->technicalAttributeUnsignedShort_;
  }

  void documentFormatType::
  technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s)
  {
    this->technicalAttributeUnsignedShort_ = s;
  }

  const documentFormatType::technicalAttributeUnsignedInteger_sequence& documentFormatType::
  technicalAttributeUnsignedInteger () const
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  documentFormatType::technicalAttributeUnsignedInteger_sequence& documentFormatType::
  technicalAttributeUnsignedInteger ()
  {
    return this->technicalAttributeUnsignedInteger_;
  }

  void documentFormatType::
  technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s)
  {
    this->technicalAttributeUnsignedInteger_ = s;
  }

  const documentFormatType::technicalAttributeUnsignedLong_sequence& documentFormatType::
  technicalAttributeUnsignedLong () const
  {
    return this->technicalAttributeUnsignedLong_;
  }

  documentFormatType::technicalAttributeUnsignedLong_sequence& documentFormatType::
  technicalAttributeUnsignedLong ()
  {
    return this->technicalAttributeUnsignedLong_;
  }

  void documentFormatType::
  technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s)
  {
    this->technicalAttributeUnsignedLong_ = s;
  }

  const documentFormatType::technicalAttributeBoolean_sequence& documentFormatType::
  technicalAttributeBoolean () const
  {
    return this->technicalAttributeBoolean_;
  }

  documentFormatType::technicalAttributeBoolean_sequence& documentFormatType::
  technicalAttributeBoolean ()
  {
    return this->technicalAttributeBoolean_;
  }

  void documentFormatType::
  technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s)
  {
    this->technicalAttributeBoolean_ = s;
  }

  const documentFormatType::technicalAttributeFloat_sequence& documentFormatType::
  technicalAttributeFloat () const
  {
    return this->technicalAttributeFloat_;
  }

  documentFormatType::technicalAttributeFloat_sequence& documentFormatType::
  technicalAttributeFloat ()
  {
    return this->technicalAttributeFloat_;
  }

  void documentFormatType::
  technicalAttributeFloat (const technicalAttributeFloat_sequence& s)
  {
    this->technicalAttributeFloat_ = s;
  }

  const documentFormatType::technicalAttributeRational_sequence& documentFormatType::
  technicalAttributeRational () const
  {
    return this->technicalAttributeRational_;
  }

  documentFormatType::technicalAttributeRational_sequence& documentFormatType::
  technicalAttributeRational ()
  {
    return this->technicalAttributeRational_;
  }

  void documentFormatType::
  technicalAttributeRational (const technicalAttributeRational_sequence& s)
  {
    this->technicalAttributeRational_ = s;
  }

  const documentFormatType::technicalAttributeUri_sequence& documentFormatType::
  technicalAttributeUri () const
  {
    return this->technicalAttributeUri_;
  }

  documentFormatType::technicalAttributeUri_sequence& documentFormatType::
  technicalAttributeUri ()
  {
    return this->technicalAttributeUri_;
  }

  void documentFormatType::
  technicalAttributeUri (const technicalAttributeUri_sequence& s)
  {
    this->technicalAttributeUri_ = s;
  }

  const documentFormatType::comment_sequence& documentFormatType::
  comment () const
  {
    return this->comment_;
  }

  documentFormatType::comment_sequence& documentFormatType::
  comment ()
  {
    return this->comment_;
  }

  void documentFormatType::
  comment (const comment_sequence& s)
  {
    this->comment_ = s;
  }

  const documentFormatType::formatLabel_optional& documentFormatType::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  documentFormatType::formatLabel_optional& documentFormatType::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void documentFormatType::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void documentFormatType::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void documentFormatType::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const documentFormatType::formatDefinition_optional& documentFormatType::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  documentFormatType::formatDefinition_optional& documentFormatType::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void documentFormatType::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void documentFormatType::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void documentFormatType::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const documentFormatType::formatLink_optional& documentFormatType::
  formatLink () const
  {
    return this->formatLink_;
  }

  documentFormatType::formatLink_optional& documentFormatType::
  formatLink ()
  {
    return this->formatLink_;
  }

  void documentFormatType::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void documentFormatType::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void documentFormatType::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const documentFormatType::formatLanguage_optional& documentFormatType::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  documentFormatType::formatLanguage_optional& documentFormatType::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void documentFormatType::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void documentFormatType::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void documentFormatType::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }

  const documentFormatType::typeLabel_optional& documentFormatType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  documentFormatType::typeLabel_optional& documentFormatType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void documentFormatType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void documentFormatType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void documentFormatType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const documentFormatType::typeDefinition_optional& documentFormatType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  documentFormatType::typeDefinition_optional& documentFormatType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void documentFormatType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void documentFormatType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void documentFormatType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const documentFormatType::typeLink_optional& documentFormatType::
  typeLink () const
  {
    return this->typeLink_;
  }

  documentFormatType::typeLink_optional& documentFormatType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void documentFormatType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void documentFormatType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void documentFormatType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const documentFormatType::typeLanguage_optional& documentFormatType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  documentFormatType::typeLanguage_optional& documentFormatType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void documentFormatType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void documentFormatType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void documentFormatType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const documentFormatType::documentFormatId_optional& documentFormatType::
  documentFormatId () const
  {
    return this->documentFormatId_;
  }

  documentFormatType::documentFormatId_optional& documentFormatType::
  documentFormatId ()
  {
    return this->documentFormatId_;
  }

  void documentFormatType::
  documentFormatId (const documentFormatId_type& x)
  {
    this->documentFormatId_.set (x);
  }

  void documentFormatType::
  documentFormatId (const documentFormatId_optional& x)
  {
    this->documentFormatId_ = x;
  }

  void documentFormatType::
  documentFormatId (::std::auto_ptr< documentFormatId_type > x)
  {
    this->documentFormatId_.set (x);
  }

  const documentFormatType::documentFormatVersionId_optional& documentFormatType::
  documentFormatVersionId () const
  {
    return this->documentFormatVersionId_;
  }

  documentFormatType::documentFormatVersionId_optional& documentFormatType::
  documentFormatVersionId ()
  {
    return this->documentFormatVersionId_;
  }

  void documentFormatType::
  documentFormatVersionId (const documentFormatVersionId_type& x)
  {
    this->documentFormatVersionId_.set (x);
  }

  void documentFormatType::
  documentFormatVersionId (const documentFormatVersionId_optional& x)
  {
    this->documentFormatVersionId_ = x;
  }

  void documentFormatType::
  documentFormatVersionId (::std::auto_ptr< documentFormatVersionId_type > x)
  {
    this->documentFormatVersionId_.set (x);
  }

  const documentFormatType::documentFormatName_optional& documentFormatType::
  documentFormatName () const
  {
    return this->documentFormatName_;
  }

  documentFormatType::documentFormatName_optional& documentFormatType::
  documentFormatName ()
  {
    return this->documentFormatName_;
  }

  void documentFormatType::
  documentFormatName (const documentFormatName_type& x)
  {
    this->documentFormatName_.set (x);
  }

  void documentFormatType::
  documentFormatName (const documentFormatName_optional& x)
  {
    this->documentFormatName_ = x;
  }

  void documentFormatType::
  documentFormatName (::std::auto_ptr< documentFormatName_type > x)
  {
    this->documentFormatName_.set (x);
  }

  const documentFormatType::documentFormatDefinition_optional& documentFormatType::
  documentFormatDefinition () const
  {
    return this->documentFormatDefinition_;
  }

  documentFormatType::documentFormatDefinition_optional& documentFormatType::
  documentFormatDefinition ()
  {
    return this->documentFormatDefinition_;
  }

  void documentFormatType::
  documentFormatDefinition (const documentFormatDefinition_type& x)
  {
    this->documentFormatDefinition_.set (x);
  }

  void documentFormatType::
  documentFormatDefinition (const documentFormatDefinition_optional& x)
  {
    this->documentFormatDefinition_ = x;
  }

  void documentFormatType::
  documentFormatDefinition (::std::auto_ptr< documentFormatDefinition_type > x)
  {
    this->documentFormatDefinition_.set (x);
  }


  // codecType
  // 

  const codecType::codecIdentifier_optional& codecType::
  codecIdentifier () const
  {
    return this->codecIdentifier_;
  }

  codecType::codecIdentifier_optional& codecType::
  codecIdentifier ()
  {
    return this->codecIdentifier_;
  }

  void codecType::
  codecIdentifier (const codecIdentifier_type& x)
  {
    this->codecIdentifier_.set (x);
  }

  void codecType::
  codecIdentifier (const codecIdentifier_optional& x)
  {
    this->codecIdentifier_ = x;
  }

  void codecType::
  codecIdentifier (::std::auto_ptr< codecIdentifier_type > x)
  {
    this->codecIdentifier_.set (x);
  }

  const codecType::name_optional& codecType::
  name () const
  {
    return this->name_;
  }

  codecType::name_optional& codecType::
  name ()
  {
    return this->name_;
  }

  void codecType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void codecType::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void codecType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const codecType::vendor_optional& codecType::
  vendor () const
  {
    return this->vendor_;
  }

  codecType::vendor_optional& codecType::
  vendor ()
  {
    return this->vendor_;
  }

  void codecType::
  vendor (const vendor_type& x)
  {
    this->vendor_.set (x);
  }

  void codecType::
  vendor (const vendor_optional& x)
  {
    this->vendor_ = x;
  }

  void codecType::
  vendor (::std::auto_ptr< vendor_type > x)
  {
    this->vendor_.set (x);
  }

  const codecType::version_optional& codecType::
  version () const
  {
    return this->version_;
  }

  codecType::version_optional& codecType::
  version ()
  {
    return this->version_;
  }

  void codecType::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void codecType::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void codecType::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const codecType::family_optional& codecType::
  family () const
  {
    return this->family_;
  }

  codecType::family_optional& codecType::
  family ()
  {
    return this->family_;
  }

  void codecType::
  family (const family_type& x)
  {
    this->family_.set (x);
  }

  void codecType::
  family (const family_optional& x)
  {
    this->family_ = x;
  }

  void codecType::
  family (::std::auto_ptr< family_type > x)
  {
    this->family_.set (x);
  }


  // timeType
  // 

  const timeType::timecode_optional& timeType::
  timecode () const
  {
    return this->timecode_;
  }

  timeType::timecode_optional& timeType::
  timecode ()
  {
    return this->timecode_;
  }

  void timeType::
  timecode (const timecode_type& x)
  {
    this->timecode_.set (x);
  }

  void timeType::
  timecode (const timecode_optional& x)
  {
    this->timecode_ = x;
  }

  void timeType::
  timecode (::std::auto_ptr< timecode_type > x)
  {
    this->timecode_.set (x);
  }

  const timeType::normalPlayTime_optional& timeType::
  normalPlayTime () const
  {
    return this->normalPlayTime_;
  }

  timeType::normalPlayTime_optional& timeType::
  normalPlayTime ()
  {
    return this->normalPlayTime_;
  }

  void timeType::
  normalPlayTime (const normalPlayTime_type& x)
  {
    this->normalPlayTime_.set (x);
  }

  void timeType::
  normalPlayTime (const normalPlayTime_optional& x)
  {
    this->normalPlayTime_ = x;
  }

  void timeType::
  normalPlayTime (::std::auto_ptr< normalPlayTime_type > x)
  {
    this->normalPlayTime_.set (x);
  }

  const timeType::editUnitNumber_optional& timeType::
  editUnitNumber () const
  {
    return this->editUnitNumber_;
  }

  timeType::editUnitNumber_optional& timeType::
  editUnitNumber ()
  {
    return this->editUnitNumber_;
  }

  void timeType::
  editUnitNumber (const editUnitNumber_type& x)
  {
    this->editUnitNumber_.set (x);
  }

  void timeType::
  editUnitNumber (const editUnitNumber_optional& x)
  {
    this->editUnitNumber_ = x;
  }

  void timeType::
  editUnitNumber (::std::auto_ptr< editUnitNumber_type > x)
  {
    this->editUnitNumber_.set (x);
  }

  const timeType::time_optional& timeType::
  time () const
  {
    return this->time_;
  }

  timeType::time_optional& timeType::
  time ()
  {
    return this->time_;
  }

  void timeType::
  time (const time_type& x)
  {
    this->time_.set (x);
  }

  void timeType::
  time (const time_optional& x)
  {
    this->time_ = x;
  }

  void timeType::
  time (::std::auto_ptr< time_type > x)
  {
    this->time_.set (x);
  }

  const timeType::typeLabel_optional& timeType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  timeType::typeLabel_optional& timeType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void timeType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void timeType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void timeType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const timeType::typeDefinition_optional& timeType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  timeType::typeDefinition_optional& timeType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void timeType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void timeType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void timeType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const timeType::typeLink_optional& timeType::
  typeLink () const
  {
    return this->typeLink_;
  }

  timeType::typeLink_optional& timeType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void timeType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void timeType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void timeType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const timeType::typeLanguage_optional& timeType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  timeType::typeLanguage_optional& timeType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void timeType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void timeType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void timeType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // durationType
  // 

  const durationType::timecode_optional& durationType::
  timecode () const
  {
    return this->timecode_;
  }

  durationType::timecode_optional& durationType::
  timecode ()
  {
    return this->timecode_;
  }

  void durationType::
  timecode (const timecode_type& x)
  {
    this->timecode_.set (x);
  }

  void durationType::
  timecode (const timecode_optional& x)
  {
    this->timecode_ = x;
  }

  void durationType::
  timecode (::std::auto_ptr< timecode_type > x)
  {
    this->timecode_.set (x);
  }

  const durationType::normalPlayTime_optional& durationType::
  normalPlayTime () const
  {
    return this->normalPlayTime_;
  }

  durationType::normalPlayTime_optional& durationType::
  normalPlayTime ()
  {
    return this->normalPlayTime_;
  }

  void durationType::
  normalPlayTime (const normalPlayTime_type& x)
  {
    this->normalPlayTime_.set (x);
  }

  void durationType::
  normalPlayTime (const normalPlayTime_optional& x)
  {
    this->normalPlayTime_ = x;
  }

  void durationType::
  normalPlayTime (::std::auto_ptr< normalPlayTime_type > x)
  {
    this->normalPlayTime_.set (x);
  }

  const durationType::editUnitNumber_optional& durationType::
  editUnitNumber () const
  {
    return this->editUnitNumber_;
  }

  durationType::editUnitNumber_optional& durationType::
  editUnitNumber ()
  {
    return this->editUnitNumber_;
  }

  void durationType::
  editUnitNumber (const editUnitNumber_type& x)
  {
    this->editUnitNumber_.set (x);
  }

  void durationType::
  editUnitNumber (const editUnitNumber_optional& x)
  {
    this->editUnitNumber_ = x;
  }

  void durationType::
  editUnitNumber (::std::auto_ptr< editUnitNumber_type > x)
  {
    this->editUnitNumber_.set (x);
  }

  const durationType::duration_optional& durationType::
  duration () const
  {
    return this->duration_;
  }

  durationType::duration_optional& durationType::
  duration ()
  {
    return this->duration_;
  }

  void durationType::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void durationType::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void durationType::
  duration (::std::auto_ptr< duration_type > x)
  {
    this->duration_.set (x);
  }

  const durationType::typeLabel_optional& durationType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  durationType::typeLabel_optional& durationType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void durationType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void durationType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void durationType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const durationType::typeDefinition_optional& durationType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  durationType::typeDefinition_optional& durationType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void durationType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void durationType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void durationType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const durationType::typeLink_optional& durationType::
  typeLink () const
  {
    return this->typeLink_;
  }

  durationType::typeLink_optional& durationType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void durationType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void durationType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void durationType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const durationType::typeLanguage_optional& durationType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  durationType::typeLanguage_optional& durationType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void durationType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void durationType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void durationType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // hashType
  // 

  const hashType::hashValue_type& hashType::
  hashValue () const
  {
    return this->hashValue_.get ();
  }

  hashType::hashValue_type& hashType::
  hashValue ()
  {
    return this->hashValue_.get ();
  }

  void hashType::
  hashValue (const hashValue_type& x)
  {
    this->hashValue_.set (x);
  }

  void hashType::
  hashValue (::std::auto_ptr< hashValue_type > x)
  {
    this->hashValue_.set (x);
  }

  const hashType::hashFunction_type& hashType::
  hashFunction () const
  {
    return this->hashFunction_.get ();
  }

  hashType::hashFunction_type& hashType::
  hashFunction ()
  {
    return this->hashFunction_.get ();
  }

  void hashType::
  hashFunction (const hashFunction_type& x)
  {
    this->hashFunction_.set (x);
  }

  void hashType::
  hashFunction (::std::auto_ptr< hashFunction_type > x)
  {
    this->hashFunction_.set (x);
  }


  // String
  // 

  const String::typeLabel_optional& String::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  String::typeLabel_optional& String::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void String::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void String::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void String::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const String::typeDefinition_optional& String::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  String::typeDefinition_optional& String::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void String::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void String::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void String::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const String::typeLink_optional& String::
  typeLink () const
  {
    return this->typeLink_;
  }

  String::typeLink_optional& String::
  typeLink ()
  {
    return this->typeLink_;
  }

  void String::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void String::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void String::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const String::typeLanguage_optional& String::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  String::typeLanguage_optional& String::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void String::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void String::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void String::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const String::formatLabel_optional& String::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  String::formatLabel_optional& String::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void String::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void String::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void String::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const String::formatDefinition_optional& String::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  String::formatDefinition_optional& String::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void String::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void String::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void String::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const String::formatLink_optional& String::
  formatLink () const
  {
    return this->formatLink_;
  }

  String::formatLink_optional& String::
  formatLink ()
  {
    return this->formatLink_;
  }

  void String::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void String::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void String::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const String::formatLanguage_optional& String::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  String::formatLanguage_optional& String::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void String::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void String::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void String::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }


  // Boolean
  // 

  const Boolean::typeLabel_optional& Boolean::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Boolean::typeLabel_optional& Boolean::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Boolean::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Boolean::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Boolean::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Boolean::typeDefinition_optional& Boolean::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Boolean::typeDefinition_optional& Boolean::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Boolean::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Boolean::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Boolean::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Boolean::typeLink_optional& Boolean::
  typeLink () const
  {
    return this->typeLink_;
  }

  Boolean::typeLink_optional& Boolean::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Boolean::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Boolean::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Boolean::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const Boolean::typeLanguage_optional& Boolean::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  Boolean::typeLanguage_optional& Boolean::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void Boolean::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void Boolean::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void Boolean::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // Float
  // 

  const Float::typeLabel_optional& Float::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Float::typeLabel_optional& Float::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Float::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Float::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Float::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Float::typeDefinition_optional& Float::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Float::typeDefinition_optional& Float::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Float::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Float::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Float::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Float::typeLink_optional& Float::
  typeLink () const
  {
    return this->typeLink_;
  }

  Float::typeLink_optional& Float::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Float::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Float::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Float::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const Float::typeLanguage_optional& Float::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  Float::typeLanguage_optional& Float::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void Float::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void Float::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void Float::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // Int8
  // 

  const Int8::typeLabel_optional& Int8::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Int8::typeLabel_optional& Int8::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Int8::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Int8::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Int8::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Int8::typeDefinition_optional& Int8::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Int8::typeDefinition_optional& Int8::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Int8::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Int8::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Int8::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Int8::typeLink_optional& Int8::
  typeLink () const
  {
    return this->typeLink_;
  }

  Int8::typeLink_optional& Int8::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Int8::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Int8::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Int8::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const Int8::typeLanguage_optional& Int8::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  Int8::typeLanguage_optional& Int8::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void Int8::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void Int8::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void Int8::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // Int16
  // 

  const Int16::typeLabel_optional& Int16::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Int16::typeLabel_optional& Int16::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Int16::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Int16::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Int16::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Int16::typeDefinition_optional& Int16::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Int16::typeDefinition_optional& Int16::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Int16::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Int16::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Int16::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Int16::typeLink_optional& Int16::
  typeLink () const
  {
    return this->typeLink_;
  }

  Int16::typeLink_optional& Int16::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Int16::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Int16::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Int16::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const Int16::typeLanguage_optional& Int16::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  Int16::typeLanguage_optional& Int16::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void Int16::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void Int16::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void Int16::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // Int32
  // 

  const Int32::typeLabel_optional& Int32::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Int32::typeLabel_optional& Int32::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Int32::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Int32::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Int32::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Int32::typeDefinition_optional& Int32::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Int32::typeDefinition_optional& Int32::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Int32::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Int32::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Int32::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Int32::typeLink_optional& Int32::
  typeLink () const
  {
    return this->typeLink_;
  }

  Int32::typeLink_optional& Int32::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Int32::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Int32::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Int32::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const Int32::typeLanguage_optional& Int32::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  Int32::typeLanguage_optional& Int32::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void Int32::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void Int32::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void Int32::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // Int64
  // 

  const Int64::typeLabel_optional& Int64::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  Int64::typeLabel_optional& Int64::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void Int64::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void Int64::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void Int64::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const Int64::typeDefinition_optional& Int64::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  Int64::typeDefinition_optional& Int64::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void Int64::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void Int64::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void Int64::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const Int64::typeLink_optional& Int64::
  typeLink () const
  {
    return this->typeLink_;
  }

  Int64::typeLink_optional& Int64::
  typeLink ()
  {
    return this->typeLink_;
  }

  void Int64::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void Int64::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void Int64::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const Int64::typeLanguage_optional& Int64::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  Int64::typeLanguage_optional& Int64::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void Int64::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void Int64::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void Int64::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // UInt8
  // 

  const UInt8::typeLabel_optional& UInt8::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  UInt8::typeLabel_optional& UInt8::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void UInt8::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void UInt8::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void UInt8::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const UInt8::typeDefinition_optional& UInt8::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  UInt8::typeDefinition_optional& UInt8::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void UInt8::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void UInt8::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void UInt8::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const UInt8::typeLink_optional& UInt8::
  typeLink () const
  {
    return this->typeLink_;
  }

  UInt8::typeLink_optional& UInt8::
  typeLink ()
  {
    return this->typeLink_;
  }

  void UInt8::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void UInt8::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void UInt8::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const UInt8::typeLanguage_optional& UInt8::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  UInt8::typeLanguage_optional& UInt8::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void UInt8::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void UInt8::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void UInt8::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // UInt16
  // 

  const UInt16::typeLabel_optional& UInt16::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  UInt16::typeLabel_optional& UInt16::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void UInt16::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void UInt16::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void UInt16::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const UInt16::typeDefinition_optional& UInt16::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  UInt16::typeDefinition_optional& UInt16::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void UInt16::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void UInt16::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void UInt16::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const UInt16::typeLink_optional& UInt16::
  typeLink () const
  {
    return this->typeLink_;
  }

  UInt16::typeLink_optional& UInt16::
  typeLink ()
  {
    return this->typeLink_;
  }

  void UInt16::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void UInt16::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void UInt16::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const UInt16::typeLanguage_optional& UInt16::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  UInt16::typeLanguage_optional& UInt16::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void UInt16::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void UInt16::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void UInt16::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // UInt32
  // 

  const UInt32::typeLabel_optional& UInt32::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  UInt32::typeLabel_optional& UInt32::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void UInt32::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void UInt32::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void UInt32::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const UInt32::typeDefinition_optional& UInt32::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  UInt32::typeDefinition_optional& UInt32::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void UInt32::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void UInt32::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void UInt32::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const UInt32::typeLink_optional& UInt32::
  typeLink () const
  {
    return this->typeLink_;
  }

  UInt32::typeLink_optional& UInt32::
  typeLink ()
  {
    return this->typeLink_;
  }

  void UInt32::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void UInt32::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void UInt32::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const UInt32::typeLanguage_optional& UInt32::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  UInt32::typeLanguage_optional& UInt32::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void UInt32::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void UInt32::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void UInt32::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // UInt64
  // 

  const UInt64::typeLabel_optional& UInt64::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  UInt64::typeLabel_optional& UInt64::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void UInt64::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void UInt64::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void UInt64::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const UInt64::typeDefinition_optional& UInt64::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  UInt64::typeDefinition_optional& UInt64::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void UInt64::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void UInt64::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void UInt64::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const UInt64::typeLink_optional& UInt64::
  typeLink () const
  {
    return this->typeLink_;
  }

  UInt64::typeLink_optional& UInt64::
  typeLink ()
  {
    return this->typeLink_;
  }

  void UInt64::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void UInt64::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void UInt64::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const UInt64::typeLanguage_optional& UInt64::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  UInt64::typeLanguage_optional& UInt64::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void UInt64::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void UInt64::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void UInt64::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // rationalType
  // 

  const rationalType::factorNumerator_type& rationalType::
  factorNumerator () const
  {
    return this->factorNumerator_.get ();
  }

  rationalType::factorNumerator_type& rationalType::
  factorNumerator ()
  {
    return this->factorNumerator_.get ();
  }

  void rationalType::
  factorNumerator (const factorNumerator_type& x)
  {
    this->factorNumerator_.set (x);
  }

  rationalType::factorNumerator_type rationalType::
  factorNumerator_default_value ()
  {
    return factorNumerator_type (1LL);
  }

  const rationalType::factorDenominator_type& rationalType::
  factorDenominator () const
  {
    return this->factorDenominator_.get ();
  }

  rationalType::factorDenominator_type& rationalType::
  factorDenominator ()
  {
    return this->factorDenominator_.get ();
  }

  void rationalType::
  factorDenominator (const factorDenominator_type& x)
  {
    this->factorDenominator_.set (x);
  }

  rationalType::factorDenominator_type rationalType::
  factorDenominator_default_value ()
  {
    return factorDenominator_type (1LL);
  }


  // aspectRatioType
  // 

  const aspectRatioType::factorNumerator_type& aspectRatioType::
  factorNumerator () const
  {
    return this->factorNumerator_.get ();
  }

  aspectRatioType::factorNumerator_type& aspectRatioType::
  factorNumerator ()
  {
    return this->factorNumerator_.get ();
  }

  void aspectRatioType::
  factorNumerator (const factorNumerator_type& x)
  {
    this->factorNumerator_.set (x);
  }

  aspectRatioType::factorNumerator_type aspectRatioType::
  factorNumerator_default_value ()
  {
    return factorNumerator_type (1LL);
  }

  const aspectRatioType::factorDenominator_type& aspectRatioType::
  factorDenominator () const
  {
    return this->factorDenominator_.get ();
  }

  aspectRatioType::factorDenominator_type& aspectRatioType::
  factorDenominator ()
  {
    return this->factorDenominator_.get ();
  }

  void aspectRatioType::
  factorDenominator (const factorDenominator_type& x)
  {
    this->factorDenominator_.set (x);
  }

  aspectRatioType::factorDenominator_type aspectRatioType::
  factorDenominator_default_value ()
  {
    return factorDenominator_type (1LL);
  }

  const aspectRatioType::typeLabel_optional& aspectRatioType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  aspectRatioType::typeLabel_optional& aspectRatioType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void aspectRatioType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void aspectRatioType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void aspectRatioType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const aspectRatioType::typeDefinition_optional& aspectRatioType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  aspectRatioType::typeDefinition_optional& aspectRatioType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void aspectRatioType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void aspectRatioType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void aspectRatioType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const aspectRatioType::typeLink_optional& aspectRatioType::
  typeLink () const
  {
    return this->typeLink_;
  }

  aspectRatioType::typeLink_optional& aspectRatioType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void aspectRatioType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void aspectRatioType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void aspectRatioType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const aspectRatioType::typeLanguage_optional& aspectRatioType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  aspectRatioType::typeLanguage_optional& aspectRatioType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void aspectRatioType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void aspectRatioType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void aspectRatioType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // technicalAttributeRationalType
  // 

  const technicalAttributeRationalType::typeLabel_optional& technicalAttributeRationalType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  technicalAttributeRationalType::typeLabel_optional& technicalAttributeRationalType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void technicalAttributeRationalType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void technicalAttributeRationalType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void technicalAttributeRationalType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const technicalAttributeRationalType::typeDefinition_optional& technicalAttributeRationalType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  technicalAttributeRationalType::typeDefinition_optional& technicalAttributeRationalType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void technicalAttributeRationalType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void technicalAttributeRationalType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void technicalAttributeRationalType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const technicalAttributeRationalType::typeLink_optional& technicalAttributeRationalType::
  typeLink () const
  {
    return this->typeLink_;
  }

  technicalAttributeRationalType::typeLink_optional& technicalAttributeRationalType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void technicalAttributeRationalType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void technicalAttributeRationalType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void technicalAttributeRationalType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const technicalAttributeRationalType::typeLanguage_optional& technicalAttributeRationalType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  technicalAttributeRationalType::typeLanguage_optional& technicalAttributeRationalType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void technicalAttributeRationalType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void technicalAttributeRationalType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void technicalAttributeRationalType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // technicalAttributeUriType
  // 

  const technicalAttributeUriType::typeLabel_optional& technicalAttributeUriType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  technicalAttributeUriType::typeLabel_optional& technicalAttributeUriType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void technicalAttributeUriType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void technicalAttributeUriType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void technicalAttributeUriType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const technicalAttributeUriType::typeDefinition_optional& technicalAttributeUriType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  technicalAttributeUriType::typeDefinition_optional& technicalAttributeUriType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void technicalAttributeUriType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void technicalAttributeUriType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void technicalAttributeUriType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const technicalAttributeUriType::typeLink_optional& technicalAttributeUriType::
  typeLink () const
  {
    return this->typeLink_;
  }

  technicalAttributeUriType::typeLink_optional& technicalAttributeUriType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void technicalAttributeUriType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void technicalAttributeUriType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void technicalAttributeUriType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const technicalAttributeUriType::typeLanguage_optional& technicalAttributeUriType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  technicalAttributeUriType::typeLanguage_optional& technicalAttributeUriType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void technicalAttributeUriType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void technicalAttributeUriType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void technicalAttributeUriType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // versionType
  // 

  const versionType::typeLabel_optional& versionType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  versionType::typeLabel_optional& versionType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void versionType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void versionType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void versionType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const versionType::typeDefinition_optional& versionType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  versionType::typeDefinition_optional& versionType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void versionType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void versionType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void versionType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const versionType::typeLink_optional& versionType::
  typeLink () const
  {
    return this->typeLink_;
  }

  versionType::typeLink_optional& versionType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void versionType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void versionType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void versionType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const versionType::typeLanguage_optional& versionType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  versionType::typeLanguage_optional& versionType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void versionType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void versionType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void versionType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // hasTrackPart
  // 

  const hasTrackPart::trackPartTitle_type& hasTrackPart::
  trackPartTitle () const
  {
    return this->trackPartTitle_.get ();
  }

  hasTrackPart::trackPartTitle_type& hasTrackPart::
  trackPartTitle ()
  {
    return this->trackPartTitle_.get ();
  }

  void hasTrackPart::
  trackPartTitle (const trackPartTitle_type& x)
  {
    this->trackPartTitle_.set (x);
  }

  void hasTrackPart::
  trackPartTitle (::std::auto_ptr< trackPartTitle_type > x)
  {
    this->trackPartTitle_.set (x);
  }

  const hasTrackPart::destinationId_optional& hasTrackPart::
  destinationId () const
  {
    return this->destinationId_;
  }

  hasTrackPart::destinationId_optional& hasTrackPart::
  destinationId ()
  {
    return this->destinationId_;
  }

  void hasTrackPart::
  destinationId (const destinationId_type& x)
  {
    this->destinationId_.set (x);
  }

  void hasTrackPart::
  destinationId (const destinationId_optional& x)
  {
    this->destinationId_ = x;
  }

  void hasTrackPart::
  destinationId (::std::auto_ptr< destinationId_type > x)
  {
    this->destinationId_.set (x);
  }

  const hasTrackPart::destinationStart_optional& hasTrackPart::
  destinationStart () const
  {
    return this->destinationStart_;
  }

  hasTrackPart::destinationStart_optional& hasTrackPart::
  destinationStart ()
  {
    return this->destinationStart_;
  }

  void hasTrackPart::
  destinationStart (const destinationStart_type& x)
  {
    this->destinationStart_.set (x);
  }

  void hasTrackPart::
  destinationStart (const destinationStart_optional& x)
  {
    this->destinationStart_ = x;
  }

  void hasTrackPart::
  destinationStart (::std::auto_ptr< destinationStart_type > x)
  {
    this->destinationStart_.set (x);
  }

  const hasTrackPart::destinationEnd_optional& hasTrackPart::
  destinationEnd () const
  {
    return this->destinationEnd_;
  }

  hasTrackPart::destinationEnd_optional& hasTrackPart::
  destinationEnd ()
  {
    return this->destinationEnd_;
  }

  void hasTrackPart::
  destinationEnd (const destinationEnd_type& x)
  {
    this->destinationEnd_.set (x);
  }

  void hasTrackPart::
  destinationEnd (const destinationEnd_optional& x)
  {
    this->destinationEnd_ = x;
  }

  void hasTrackPart::
  destinationEnd (::std::auto_ptr< destinationEnd_type > x)
  {
    this->destinationEnd_.set (x);
  }

  const hasTrackPart::sourceId_optional& hasTrackPart::
  sourceId () const
  {
    return this->sourceId_;
  }

  hasTrackPart::sourceId_optional& hasTrackPart::
  sourceId ()
  {
    return this->sourceId_;
  }

  void hasTrackPart::
  sourceId (const sourceId_type& x)
  {
    this->sourceId_.set (x);
  }

  void hasTrackPart::
  sourceId (const sourceId_optional& x)
  {
    this->sourceId_ = x;
  }

  void hasTrackPart::
  sourceId (::std::auto_ptr< sourceId_type > x)
  {
    this->sourceId_.set (x);
  }

  const hasTrackPart::sourceStart_optional& hasTrackPart::
  sourceStart () const
  {
    return this->sourceStart_;
  }

  hasTrackPart::sourceStart_optional& hasTrackPart::
  sourceStart ()
  {
    return this->sourceStart_;
  }

  void hasTrackPart::
  sourceStart (const sourceStart_type& x)
  {
    this->sourceStart_.set (x);
  }

  void hasTrackPart::
  sourceStart (const sourceStart_optional& x)
  {
    this->sourceStart_ = x;
  }

  void hasTrackPart::
  sourceStart (::std::auto_ptr< sourceStart_type > x)
  {
    this->sourceStart_.set (x);
  }

  const hasTrackPart::sourceEnd_optional& hasTrackPart::
  sourceEnd () const
  {
    return this->sourceEnd_;
  }

  hasTrackPart::sourceEnd_optional& hasTrackPart::
  sourceEnd ()
  {
    return this->sourceEnd_;
  }

  void hasTrackPart::
  sourceEnd (const sourceEnd_type& x)
  {
    this->sourceEnd_.set (x);
  }

  void hasTrackPart::
  sourceEnd (const sourceEnd_optional& x)
  {
    this->sourceEnd_ = x;
  }

  void hasTrackPart::
  sourceEnd (::std::auto_ptr< sourceEnd_type > x)
  {
    this->sourceEnd_.set (x);
  }


  // genre
  // 

  const genre::typeLabel_optional& genre::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  genre::typeLabel_optional& genre::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void genre::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void genre::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void genre::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const genre::typeDefinition_optional& genre::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  genre::typeDefinition_optional& genre::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void genre::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void genre::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void genre::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const genre::typeLink_optional& genre::
  typeLink () const
  {
    return this->typeLink_;
  }

  genre::typeLink_optional& genre::
  typeLink ()
  {
    return this->typeLink_;
  }

  void genre::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void genre::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void genre::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const genre::typeLanguage_optional& genre::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  genre::typeLanguage_optional& genre::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void genre::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void genre::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void genre::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // objectType
  // 

  const objectType::typeLabel_optional& objectType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  objectType::typeLabel_optional& objectType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void objectType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void objectType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void objectType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const objectType::typeDefinition_optional& objectType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  objectType::typeDefinition_optional& objectType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void objectType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void objectType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void objectType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const objectType::typeLink_optional& objectType::
  typeLink () const
  {
    return this->typeLink_;
  }

  objectType::typeLink_optional& objectType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void objectType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void objectType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void objectType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const objectType::typeLanguage_optional& objectType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  objectType::typeLanguage_optional& objectType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void objectType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void objectType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void objectType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // targetAudience
  // 

  const targetAudience::targetRegion_sequence& targetAudience::
  targetRegion () const
  {
    return this->targetRegion_;
  }

  targetAudience::targetRegion_sequence& targetAudience::
  targetRegion ()
  {
    return this->targetRegion_;
  }

  void targetAudience::
  targetRegion (const targetRegion_sequence& s)
  {
    this->targetRegion_ = s;
  }

  const targetAudience::typeLabel_optional& targetAudience::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  targetAudience::typeLabel_optional& targetAudience::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void targetAudience::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void targetAudience::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void targetAudience::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const targetAudience::typeDefinition_optional& targetAudience::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  targetAudience::typeDefinition_optional& targetAudience::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void targetAudience::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void targetAudience::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void targetAudience::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const targetAudience::typeLink_optional& targetAudience::
  typeLink () const
  {
    return this->typeLink_;
  }

  targetAudience::typeLink_optional& targetAudience::
  typeLink ()
  {
    return this->typeLink_;
  }

  void targetAudience::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void targetAudience::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void targetAudience::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const targetAudience::typeLanguage_optional& targetAudience::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  targetAudience::typeLanguage_optional& targetAudience::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void targetAudience::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void targetAudience::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void targetAudience::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const targetAudience::reason_optional& targetAudience::
  reason () const
  {
    return this->reason_;
  }

  targetAudience::reason_optional& targetAudience::
  reason ()
  {
    return this->reason_;
  }

  void targetAudience::
  reason (const reason_type& x)
  {
    this->reason_.set (x);
  }

  void targetAudience::
  reason (const reason_optional& x)
  {
    this->reason_ = x;
  }

  void targetAudience::
  reason (::std::auto_ptr< reason_type > x)
  {
    this->reason_.set (x);
  }

  const targetAudience::linkToLogo_optional& targetAudience::
  linkToLogo () const
  {
    return this->linkToLogo_;
  }

  targetAudience::linkToLogo_optional& targetAudience::
  linkToLogo ()
  {
    return this->linkToLogo_;
  }

  void targetAudience::
  linkToLogo (const linkToLogo_type& x)
  {
    this->linkToLogo_.set (x);
  }

  void targetAudience::
  linkToLogo (const linkToLogo_optional& x)
  {
    this->linkToLogo_ = x;
  }

  void targetAudience::
  linkToLogo (::std::auto_ptr< linkToLogo_type > x)
  {
    this->linkToLogo_.set (x);
  }

  const targetAudience::notRated_optional& targetAudience::
  notRated () const
  {
    return this->notRated_;
  }

  targetAudience::notRated_optional& targetAudience::
  notRated ()
  {
    return this->notRated_;
  }

  void targetAudience::
  notRated (const notRated_type& x)
  {
    this->notRated_.set (x);
  }

  void targetAudience::
  notRated (const notRated_optional& x)
  {
    this->notRated_ = x;
  }

  const targetAudience::adultContent_optional& targetAudience::
  adultContent () const
  {
    return this->adultContent_;
  }

  targetAudience::adultContent_optional& targetAudience::
  adultContent ()
  {
    return this->adultContent_;
  }

  void targetAudience::
  adultContent (const adultContent_type& x)
  {
    this->adultContent_.set (x);
  }

  void targetAudience::
  adultContent (const adultContent_optional& x)
  {
    this->adultContent_ = x;
  }


  // temporal
  // 

  const temporal::PeriodOfTime_sequence& temporal::
  PeriodOfTime () const
  {
    return this->PeriodOfTime_;
  }

  temporal::PeriodOfTime_sequence& temporal::
  PeriodOfTime ()
  {
    return this->PeriodOfTime_;
  }

  void temporal::
  PeriodOfTime (const PeriodOfTime_sequence& s)
  {
    this->PeriodOfTime_ = s;
  }

  const temporal::typeLabel_optional& temporal::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  temporal::typeLabel_optional& temporal::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void temporal::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void temporal::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void temporal::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const temporal::typeDefinition_optional& temporal::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  temporal::typeDefinition_optional& temporal::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void temporal::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void temporal::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void temporal::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const temporal::typeLink_optional& temporal::
  typeLink () const
  {
    return this->typeLink_;
  }

  temporal::typeLink_optional& temporal::
  typeLink ()
  {
    return this->typeLink_;
  }

  void temporal::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void temporal::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void temporal::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const temporal::typeLanguage_optional& temporal::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  temporal::typeLanguage_optional& temporal::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void temporal::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void temporal::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void temporal::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const temporal::note_optional& temporal::
  note () const
  {
    return this->note_;
  }

  temporal::note_optional& temporal::
  note ()
  {
    return this->note_;
  }

  void temporal::
  note (const note_type& x)
  {
    this->note_.set (x);
  }

  void temporal::
  note (const note_optional& x)
  {
    this->note_ = x;
  }

  void temporal::
  note (::std::auto_ptr< note_type > x)
  {
    this->note_.set (x);
  }

  const temporal::periodId_optional& temporal::
  periodId () const
  {
    return this->periodId_;
  }

  temporal::periodId_optional& temporal::
  periodId ()
  {
    return this->periodId_;
  }

  void temporal::
  periodId (const periodId_type& x)
  {
    this->periodId_.set (x);
  }

  void temporal::
  periodId (const periodId_optional& x)
  {
    this->periodId_ = x;
  }

  void temporal::
  periodId (::std::auto_ptr< periodId_type > x)
  {
    this->periodId_.set (x);
  }


  // spatial
  // 

  const spatial::location_sequence& spatial::
  location () const
  {
    return this->location_;
  }

  spatial::location_sequence& spatial::
  location ()
  {
    return this->location_;
  }

  void spatial::
  location (const location_sequence& s)
  {
    this->location_ = s;
  }


  // coordinates
  // 

  const coordinates::posy_type& coordinates::
  posy () const
  {
    return this->posy_.get ();
  }

  coordinates::posy_type& coordinates::
  posy ()
  {
    return this->posy_.get ();
  }

  void coordinates::
  posy (const posy_type& x)
  {
    this->posy_.set (x);
  }

  const coordinates::posx_type& coordinates::
  posx () const
  {
    return this->posx_.get ();
  }

  coordinates::posx_type& coordinates::
  posx ()
  {
    return this->posx_.get ();
  }

  void coordinates::
  posx (const posx_type& x)
  {
    this->posx_.set (x);
  }

  const coordinates::formatLabel_optional& coordinates::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  coordinates::formatLabel_optional& coordinates::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void coordinates::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void coordinates::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void coordinates::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const coordinates::formatDefinition_optional& coordinates::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  coordinates::formatDefinition_optional& coordinates::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void coordinates::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void coordinates::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void coordinates::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const coordinates::formatLink_optional& coordinates::
  formatLink () const
  {
    return this->formatLink_;
  }

  coordinates::formatLink_optional& coordinates::
  formatLink ()
  {
    return this->formatLink_;
  }

  void coordinates::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void coordinates::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void coordinates::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const coordinates::formatLanguage_optional& coordinates::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  coordinates::formatLanguage_optional& coordinates::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void coordinates::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void coordinates::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void coordinates::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }


  // created
  // 

  const created::startYear_optional& created::
  startYear () const
  {
    return this->startYear_;
  }

  created::startYear_optional& created::
  startYear ()
  {
    return this->startYear_;
  }

  void created::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void created::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void created::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const created::startDate_optional& created::
  startDate () const
  {
    return this->startDate_;
  }

  created::startDate_optional& created::
  startDate ()
  {
    return this->startDate_;
  }

  void created::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void created::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void created::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const created::startTime_optional& created::
  startTime () const
  {
    return this->startTime_;
  }

  created::startTime_optional& created::
  startTime ()
  {
    return this->startTime_;
  }

  void created::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void created::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void created::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const created::endYear_optional& created::
  endYear () const
  {
    return this->endYear_;
  }

  created::endYear_optional& created::
  endYear ()
  {
    return this->endYear_;
  }

  void created::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void created::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void created::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const created::endDate_optional& created::
  endDate () const
  {
    return this->endDate_;
  }

  created::endDate_optional& created::
  endDate ()
  {
    return this->endDate_;
  }

  void created::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void created::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void created::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const created::endTime_optional& created::
  endTime () const
  {
    return this->endTime_;
  }

  created::endTime_optional& created::
  endTime ()
  {
    return this->endTime_;
  }

  void created::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void created::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void created::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }


  // issued
  // 

  const issued::startYear_optional& issued::
  startYear () const
  {
    return this->startYear_;
  }

  issued::startYear_optional& issued::
  startYear ()
  {
    return this->startYear_;
  }

  void issued::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void issued::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void issued::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const issued::startDate_optional& issued::
  startDate () const
  {
    return this->startDate_;
  }

  issued::startDate_optional& issued::
  startDate ()
  {
    return this->startDate_;
  }

  void issued::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void issued::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void issued::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const issued::startTime_optional& issued::
  startTime () const
  {
    return this->startTime_;
  }

  issued::startTime_optional& issued::
  startTime ()
  {
    return this->startTime_;
  }

  void issued::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void issued::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void issued::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const issued::endYear_optional& issued::
  endYear () const
  {
    return this->endYear_;
  }

  issued::endYear_optional& issued::
  endYear ()
  {
    return this->endYear_;
  }

  void issued::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void issued::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void issued::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const issued::endDate_optional& issued::
  endDate () const
  {
    return this->endDate_;
  }

  issued::endDate_optional& issued::
  endDate ()
  {
    return this->endDate_;
  }

  void issued::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void issued::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void issued::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const issued::endTime_optional& issued::
  endTime () const
  {
    return this->endTime_;
  }

  issued::endTime_optional& issued::
  endTime ()
  {
    return this->endTime_;
  }

  void issued::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void issued::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void issued::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }


  // modified
  // 

  const modified::startYear_optional& modified::
  startYear () const
  {
    return this->startYear_;
  }

  modified::startYear_optional& modified::
  startYear ()
  {
    return this->startYear_;
  }

  void modified::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void modified::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void modified::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const modified::startDate_optional& modified::
  startDate () const
  {
    return this->startDate_;
  }

  modified::startDate_optional& modified::
  startDate ()
  {
    return this->startDate_;
  }

  void modified::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void modified::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void modified::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const modified::startTime_optional& modified::
  startTime () const
  {
    return this->startTime_;
  }

  modified::startTime_optional& modified::
  startTime ()
  {
    return this->startTime_;
  }

  void modified::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void modified::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void modified::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const modified::endYear_optional& modified::
  endYear () const
  {
    return this->endYear_;
  }

  modified::endYear_optional& modified::
  endYear ()
  {
    return this->endYear_;
  }

  void modified::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void modified::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void modified::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const modified::endDate_optional& modified::
  endDate () const
  {
    return this->endDate_;
  }

  modified::endDate_optional& modified::
  endDate ()
  {
    return this->endDate_;
  }

  void modified::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void modified::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void modified::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const modified::endTime_optional& modified::
  endTime () const
  {
    return this->endTime_;
  }

  modified::endTime_optional& modified::
  endTime ()
  {
    return this->endTime_;
  }

  void modified::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void modified::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void modified::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }


  // digitised
  // 

  const digitised::startYear_optional& digitised::
  startYear () const
  {
    return this->startYear_;
  }

  digitised::startYear_optional& digitised::
  startYear ()
  {
    return this->startYear_;
  }

  void digitised::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void digitised::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void digitised::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const digitised::startDate_optional& digitised::
  startDate () const
  {
    return this->startDate_;
  }

  digitised::startDate_optional& digitised::
  startDate ()
  {
    return this->startDate_;
  }

  void digitised::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void digitised::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void digitised::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const digitised::startTime_optional& digitised::
  startTime () const
  {
    return this->startTime_;
  }

  digitised::startTime_optional& digitised::
  startTime ()
  {
    return this->startTime_;
  }

  void digitised::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void digitised::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void digitised::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const digitised::endYear_optional& digitised::
  endYear () const
  {
    return this->endYear_;
  }

  digitised::endYear_optional& digitised::
  endYear ()
  {
    return this->endYear_;
  }

  void digitised::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void digitised::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void digitised::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const digitised::endDate_optional& digitised::
  endDate () const
  {
    return this->endDate_;
  }

  digitised::endDate_optional& digitised::
  endDate ()
  {
    return this->endDate_;
  }

  void digitised::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void digitised::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void digitised::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const digitised::endTime_optional& digitised::
  endTime () const
  {
    return this->endTime_;
  }

  digitised::endTime_optional& digitised::
  endTime ()
  {
    return this->endTime_;
  }

  void digitised::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void digitised::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void digitised::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }


  // released
  // 

  const released::startYear_optional& released::
  startYear () const
  {
    return this->startYear_;
  }

  released::startYear_optional& released::
  startYear ()
  {
    return this->startYear_;
  }

  void released::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void released::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void released::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const released::startDate_optional& released::
  startDate () const
  {
    return this->startDate_;
  }

  released::startDate_optional& released::
  startDate ()
  {
    return this->startDate_;
  }

  void released::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void released::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void released::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const released::startTime_optional& released::
  startTime () const
  {
    return this->startTime_;
  }

  released::startTime_optional& released::
  startTime ()
  {
    return this->startTime_;
  }

  void released::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void released::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void released::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const released::endYear_optional& released::
  endYear () const
  {
    return this->endYear_;
  }

  released::endYear_optional& released::
  endYear ()
  {
    return this->endYear_;
  }

  void released::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void released::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void released::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const released::endDate_optional& released::
  endDate () const
  {
    return this->endDate_;
  }

  released::endDate_optional& released::
  endDate ()
  {
    return this->endDate_;
  }

  void released::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void released::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void released::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const released::endTime_optional& released::
  endTime () const
  {
    return this->endTime_;
  }

  released::endTime_optional& released::
  endTime ()
  {
    return this->endTime_;
  }

  void released::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void released::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void released::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }


  // copyrighted
  // 

  const copyrighted::startYear_optional& copyrighted::
  startYear () const
  {
    return this->startYear_;
  }

  copyrighted::startYear_optional& copyrighted::
  startYear ()
  {
    return this->startYear_;
  }

  void copyrighted::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void copyrighted::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void copyrighted::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const copyrighted::startDate_optional& copyrighted::
  startDate () const
  {
    return this->startDate_;
  }

  copyrighted::startDate_optional& copyrighted::
  startDate ()
  {
    return this->startDate_;
  }

  void copyrighted::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void copyrighted::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void copyrighted::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const copyrighted::startTime_optional& copyrighted::
  startTime () const
  {
    return this->startTime_;
  }

  copyrighted::startTime_optional& copyrighted::
  startTime ()
  {
    return this->startTime_;
  }

  void copyrighted::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void copyrighted::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void copyrighted::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const copyrighted::endYear_optional& copyrighted::
  endYear () const
  {
    return this->endYear_;
  }

  copyrighted::endYear_optional& copyrighted::
  endYear ()
  {
    return this->endYear_;
  }

  void copyrighted::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void copyrighted::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void copyrighted::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const copyrighted::endDate_optional& copyrighted::
  endDate () const
  {
    return this->endDate_;
  }

  copyrighted::endDate_optional& copyrighted::
  endDate ()
  {
    return this->endDate_;
  }

  void copyrighted::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void copyrighted::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void copyrighted::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const copyrighted::endTime_optional& copyrighted::
  endTime () const
  {
    return this->endTime_;
  }

  copyrighted::endTime_optional& copyrighted::
  endTime ()
  {
    return this->endTime_;
  }

  void copyrighted::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void copyrighted::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void copyrighted::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }


  // alternative
  // 

  const alternative::startYear_optional& alternative::
  startYear () const
  {
    return this->startYear_;
  }

  alternative::startYear_optional& alternative::
  startYear ()
  {
    return this->startYear_;
  }

  void alternative::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void alternative::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void alternative::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const alternative::startDate_optional& alternative::
  startDate () const
  {
    return this->startDate_;
  }

  alternative::startDate_optional& alternative::
  startDate ()
  {
    return this->startDate_;
  }

  void alternative::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void alternative::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void alternative::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const alternative::startTime_optional& alternative::
  startTime () const
  {
    return this->startTime_;
  }

  alternative::startTime_optional& alternative::
  startTime ()
  {
    return this->startTime_;
  }

  void alternative::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void alternative::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void alternative::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const alternative::endYear_optional& alternative::
  endYear () const
  {
    return this->endYear_;
  }

  alternative::endYear_optional& alternative::
  endYear ()
  {
    return this->endYear_;
  }

  void alternative::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void alternative::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void alternative::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const alternative::endDate_optional& alternative::
  endDate () const
  {
    return this->endDate_;
  }

  alternative::endDate_optional& alternative::
  endDate ()
  {
    return this->endDate_;
  }

  void alternative::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void alternative::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void alternative::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const alternative::endTime_optional& alternative::
  endTime () const
  {
    return this->endTime_;
  }

  alternative::endTime_optional& alternative::
  endTime ()
  {
    return this->endTime_;
  }

  void alternative::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void alternative::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void alternative::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }

  const alternative::typeLabel_optional& alternative::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  alternative::typeLabel_optional& alternative::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void alternative::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void alternative::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void alternative::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const alternative::typeDefinition_optional& alternative::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  alternative::typeDefinition_optional& alternative::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void alternative::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void alternative::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void alternative::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const alternative::typeLink_optional& alternative::
  typeLink () const
  {
    return this->typeLink_;
  }

  alternative::typeLink_optional& alternative::
  typeLink ()
  {
    return this->typeLink_;
  }

  void alternative::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void alternative::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void alternative::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const alternative::typeLanguage_optional& alternative::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  alternative::typeLanguage_optional& alternative::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void alternative::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void alternative::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void alternative::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // medium
  // 

  const medium::mediumId_optional& medium::
  mediumId () const
  {
    return this->mediumId_;
  }

  medium::mediumId_optional& medium::
  mediumId ()
  {
    return this->mediumId_;
  }

  void medium::
  mediumId (const mediumId_type& x)
  {
    this->mediumId_.set (x);
  }

  void medium::
  mediumId (const mediumId_optional& x)
  {
    this->mediumId_ = x;
  }

  void medium::
  mediumId (::std::auto_ptr< mediumId_type > x)
  {
    this->mediumId_.set (x);
  }

  const medium::typeLabel_optional& medium::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  medium::typeLabel_optional& medium::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void medium::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void medium::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void medium::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const medium::typeDefinition_optional& medium::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  medium::typeDefinition_optional& medium::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void medium::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void medium::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void medium::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const medium::typeLink_optional& medium::
  typeLink () const
  {
    return this->typeLink_;
  }

  medium::typeLink_optional& medium::
  typeLink ()
  {
    return this->typeLink_;
  }

  void medium::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void medium::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void medium::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const medium::typeLanguage_optional& medium::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  medium::typeLanguage_optional& medium::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void medium::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void medium::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void medium::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // containerFormat
  // 

  const containerFormat::comment_sequence& containerFormat::
  comment () const
  {
    return this->comment_;
  }

  containerFormat::comment_sequence& containerFormat::
  comment ()
  {
    return this->comment_;
  }

  void containerFormat::
  comment (const comment_sequence& s)
  {
    this->comment_ = s;
  }

  const containerFormat::formatLabel_optional& containerFormat::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  containerFormat::formatLabel_optional& containerFormat::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void containerFormat::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void containerFormat::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void containerFormat::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const containerFormat::formatDefinition_optional& containerFormat::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  containerFormat::formatDefinition_optional& containerFormat::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void containerFormat::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void containerFormat::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void containerFormat::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const containerFormat::formatLink_optional& containerFormat::
  formatLink () const
  {
    return this->formatLink_;
  }

  containerFormat::formatLink_optional& containerFormat::
  formatLink ()
  {
    return this->formatLink_;
  }

  void containerFormat::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void containerFormat::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void containerFormat::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const containerFormat::formatLanguage_optional& containerFormat::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  containerFormat::formatLanguage_optional& containerFormat::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void containerFormat::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void containerFormat::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void containerFormat::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }


  // signingFormat
  // 

  const signingFormat::signingFormatId_optional& signingFormat::
  signingFormatId () const
  {
    return this->signingFormatId_;
  }

  signingFormat::signingFormatId_optional& signingFormat::
  signingFormatId ()
  {
    return this->signingFormatId_;
  }

  void signingFormat::
  signingFormatId (const signingFormatId_type& x)
  {
    this->signingFormatId_.set (x);
  }

  void signingFormat::
  signingFormatId (const signingFormatId_optional& x)
  {
    this->signingFormatId_ = x;
  }

  void signingFormat::
  signingFormatId (::std::auto_ptr< signingFormatId_type > x)
  {
    this->signingFormatId_.set (x);
  }

  const signingFormat::signingFormatVersionId_optional& signingFormat::
  signingFormatVersionId () const
  {
    return this->signingFormatVersionId_;
  }

  signingFormat::signingFormatVersionId_optional& signingFormat::
  signingFormatVersionId ()
  {
    return this->signingFormatVersionId_;
  }

  void signingFormat::
  signingFormatVersionId (const signingFormatVersionId_type& x)
  {
    this->signingFormatVersionId_.set (x);
  }

  void signingFormat::
  signingFormatVersionId (const signingFormatVersionId_optional& x)
  {
    this->signingFormatVersionId_ = x;
  }

  void signingFormat::
  signingFormatVersionId (::std::auto_ptr< signingFormatVersionId_type > x)
  {
    this->signingFormatVersionId_.set (x);
  }

  const signingFormat::signingFormatName_optional& signingFormat::
  signingFormatName () const
  {
    return this->signingFormatName_;
  }

  signingFormat::signingFormatName_optional& signingFormat::
  signingFormatName ()
  {
    return this->signingFormatName_;
  }

  void signingFormat::
  signingFormatName (const signingFormatName_type& x)
  {
    this->signingFormatName_.set (x);
  }

  void signingFormat::
  signingFormatName (const signingFormatName_optional& x)
  {
    this->signingFormatName_ = x;
  }

  void signingFormat::
  signingFormatName (::std::auto_ptr< signingFormatName_type > x)
  {
    this->signingFormatName_.set (x);
  }

  const signingFormat::trackId_optional& signingFormat::
  trackId () const
  {
    return this->trackId_;
  }

  signingFormat::trackId_optional& signingFormat::
  trackId ()
  {
    return this->trackId_;
  }

  void signingFormat::
  trackId (const trackId_type& x)
  {
    this->trackId_.set (x);
  }

  void signingFormat::
  trackId (const trackId_optional& x)
  {
    this->trackId_ = x;
  }

  void signingFormat::
  trackId (::std::auto_ptr< trackId_type > x)
  {
    this->trackId_.set (x);
  }

  const signingFormat::trackName_optional& signingFormat::
  trackName () const
  {
    return this->trackName_;
  }

  signingFormat::trackName_optional& signingFormat::
  trackName ()
  {
    return this->trackName_;
  }

  void signingFormat::
  trackName (const trackName_type& x)
  {
    this->trackName_.set (x);
  }

  void signingFormat::
  trackName (const trackName_optional& x)
  {
    this->trackName_ = x;
  }

  void signingFormat::
  trackName (::std::auto_ptr< trackName_type > x)
  {
    this->trackName_.set (x);
  }

  const signingFormat::signingSourceUri_optional& signingFormat::
  signingSourceUri () const
  {
    return this->signingSourceUri_;
  }

  signingFormat::signingSourceUri_optional& signingFormat::
  signingSourceUri ()
  {
    return this->signingSourceUri_;
  }

  void signingFormat::
  signingSourceUri (const signingSourceUri_type& x)
  {
    this->signingSourceUri_.set (x);
  }

  void signingFormat::
  signingSourceUri (const signingSourceUri_optional& x)
  {
    this->signingSourceUri_ = x;
  }

  void signingFormat::
  signingSourceUri (::std::auto_ptr< signingSourceUri_type > x)
  {
    this->signingSourceUri_.set (x);
  }

  const signingFormat::language_optional& signingFormat::
  language () const
  {
    return this->language_;
  }

  signingFormat::language_optional& signingFormat::
  language ()
  {
    return this->language_;
  }

  void signingFormat::
  language (const language_type& x)
  {
    this->language_.set (x);
  }

  void signingFormat::
  language (const language_optional& x)
  {
    this->language_ = x;
  }

  void signingFormat::
  language (::std::auto_ptr< language_type > x)
  {
    this->language_.set (x);
  }

  const signingFormat::typeLabel_optional& signingFormat::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  signingFormat::typeLabel_optional& signingFormat::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void signingFormat::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void signingFormat::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void signingFormat::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const signingFormat::typeDefinition_optional& signingFormat::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  signingFormat::typeDefinition_optional& signingFormat::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void signingFormat::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void signingFormat::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void signingFormat::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const signingFormat::typeLink_optional& signingFormat::
  typeLink () const
  {
    return this->typeLink_;
  }

  signingFormat::typeLink_optional& signingFormat::
  typeLink ()
  {
    return this->typeLink_;
  }

  void signingFormat::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void signingFormat::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void signingFormat::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const signingFormat::typeLanguage_optional& signingFormat::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  signingFormat::typeLanguage_optional& signingFormat::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void signingFormat::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void signingFormat::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void signingFormat::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const signingFormat::formatLabel_optional& signingFormat::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  signingFormat::formatLabel_optional& signingFormat::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void signingFormat::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void signingFormat::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void signingFormat::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const signingFormat::formatDefinition_optional& signingFormat::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  signingFormat::formatDefinition_optional& signingFormat::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void signingFormat::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void signingFormat::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void signingFormat::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const signingFormat::formatLink_optional& signingFormat::
  formatLink () const
  {
    return this->formatLink_;
  }

  signingFormat::formatLink_optional& signingFormat::
  formatLink ()
  {
    return this->formatLink_;
  }

  void signingFormat::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void signingFormat::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void signingFormat::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const signingFormat::formatLanguage_optional& signingFormat::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  signingFormat::formatLanguage_optional& signingFormat::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void signingFormat::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void signingFormat::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void signingFormat::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }


  // dateCreated
  // 

  const dateCreated::startYear_optional& dateCreated::
  startYear () const
  {
    return this->startYear_;
  }

  dateCreated::startYear_optional& dateCreated::
  startYear ()
  {
    return this->startYear_;
  }

  void dateCreated::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void dateCreated::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void dateCreated::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const dateCreated::startDate_optional& dateCreated::
  startDate () const
  {
    return this->startDate_;
  }

  dateCreated::startDate_optional& dateCreated::
  startDate ()
  {
    return this->startDate_;
  }

  void dateCreated::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void dateCreated::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void dateCreated::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const dateCreated::startTime_optional& dateCreated::
  startTime () const
  {
    return this->startTime_;
  }

  dateCreated::startTime_optional& dateCreated::
  startTime ()
  {
    return this->startTime_;
  }

  void dateCreated::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void dateCreated::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void dateCreated::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const dateCreated::endYear_optional& dateCreated::
  endYear () const
  {
    return this->endYear_;
  }

  dateCreated::endYear_optional& dateCreated::
  endYear ()
  {
    return this->endYear_;
  }

  void dateCreated::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void dateCreated::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void dateCreated::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const dateCreated::endDate_optional& dateCreated::
  endDate () const
  {
    return this->endDate_;
  }

  dateCreated::endDate_optional& dateCreated::
  endDate ()
  {
    return this->endDate_;
  }

  void dateCreated::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void dateCreated::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void dateCreated::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const dateCreated::endTime_optional& dateCreated::
  endTime () const
  {
    return this->endTime_;
  }

  dateCreated::endTime_optional& dateCreated::
  endTime ()
  {
    return this->endTime_;
  }

  void dateCreated::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void dateCreated::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void dateCreated::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }


  // dateModified
  // 

  const dateModified::startYear_optional& dateModified::
  startYear () const
  {
    return this->startYear_;
  }

  dateModified::startYear_optional& dateModified::
  startYear ()
  {
    return this->startYear_;
  }

  void dateModified::
  startYear (const startYear_type& x)
  {
    this->startYear_.set (x);
  }

  void dateModified::
  startYear (const startYear_optional& x)
  {
    this->startYear_ = x;
  }

  void dateModified::
  startYear (::std::auto_ptr< startYear_type > x)
  {
    this->startYear_.set (x);
  }

  const dateModified::startDate_optional& dateModified::
  startDate () const
  {
    return this->startDate_;
  }

  dateModified::startDate_optional& dateModified::
  startDate ()
  {
    return this->startDate_;
  }

  void dateModified::
  startDate (const startDate_type& x)
  {
    this->startDate_.set (x);
  }

  void dateModified::
  startDate (const startDate_optional& x)
  {
    this->startDate_ = x;
  }

  void dateModified::
  startDate (::std::auto_ptr< startDate_type > x)
  {
    this->startDate_.set (x);
  }

  const dateModified::startTime_optional& dateModified::
  startTime () const
  {
    return this->startTime_;
  }

  dateModified::startTime_optional& dateModified::
  startTime ()
  {
    return this->startTime_;
  }

  void dateModified::
  startTime (const startTime_type& x)
  {
    this->startTime_.set (x);
  }

  void dateModified::
  startTime (const startTime_optional& x)
  {
    this->startTime_ = x;
  }

  void dateModified::
  startTime (::std::auto_ptr< startTime_type > x)
  {
    this->startTime_.set (x);
  }

  const dateModified::endYear_optional& dateModified::
  endYear () const
  {
    return this->endYear_;
  }

  dateModified::endYear_optional& dateModified::
  endYear ()
  {
    return this->endYear_;
  }

  void dateModified::
  endYear (const endYear_type& x)
  {
    this->endYear_.set (x);
  }

  void dateModified::
  endYear (const endYear_optional& x)
  {
    this->endYear_ = x;
  }

  void dateModified::
  endYear (::std::auto_ptr< endYear_type > x)
  {
    this->endYear_.set (x);
  }

  const dateModified::endDate_optional& dateModified::
  endDate () const
  {
    return this->endDate_;
  }

  dateModified::endDate_optional& dateModified::
  endDate ()
  {
    return this->endDate_;
  }

  void dateModified::
  endDate (const endDate_type& x)
  {
    this->endDate_.set (x);
  }

  void dateModified::
  endDate (const endDate_optional& x)
  {
    this->endDate_ = x;
  }

  void dateModified::
  endDate (::std::auto_ptr< endDate_type > x)
  {
    this->endDate_.set (x);
  }

  const dateModified::endTime_optional& dateModified::
  endTime () const
  {
    return this->endTime_;
  }

  dateModified::endTime_optional& dateModified::
  endTime ()
  {
    return this->endTime_;
  }

  void dateModified::
  endTime (const endTime_type& x)
  {
    this->endTime_.set (x);
  }

  void dateModified::
  endTime (const endTime_optional& x)
  {
    this->endTime_ = x;
  }

  void dateModified::
  endTime (::std::auto_ptr< endTime_type > x)
  {
    this->endTime_.set (x);
  }


  // role
  // 

  const role::typeLabel_optional& role::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  role::typeLabel_optional& role::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void role::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void role::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void role::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const role::typeDefinition_optional& role::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  role::typeDefinition_optional& role::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void role::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void role::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void role::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const role::typeLink_optional& role::
  typeLink () const
  {
    return this->typeLink_;
  }

  role::typeLink_optional& role::
  typeLink ()
  {
    return this->typeLink_;
  }

  void role::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void role::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void role::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const role::typeLanguage_optional& role::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  role::typeLanguage_optional& role::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void role::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void role::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void role::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const role::costCentre_optional& role::
  costCentre () const
  {
    return this->costCentre_;
  }

  role::costCentre_optional& role::
  costCentre ()
  {
    return this->costCentre_;
  }

  void role::
  costCentre (const costCentre_type& x)
  {
    this->costCentre_.set (x);
  }

  void role::
  costCentre (const costCentre_optional& x)
  {
    this->costCentre_ = x;
  }

  void role::
  costCentre (::std::auto_ptr< costCentre_type > x)
  {
    this->costCentre_.set (x);
  }


  // relatedInformationLink
  // 

  const relatedInformationLink::typeLabel_optional& relatedInformationLink::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  relatedInformationLink::typeLabel_optional& relatedInformationLink::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void relatedInformationLink::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void relatedInformationLink::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void relatedInformationLink::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const relatedInformationLink::typeDefinition_optional& relatedInformationLink::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  relatedInformationLink::typeDefinition_optional& relatedInformationLink::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void relatedInformationLink::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void relatedInformationLink::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void relatedInformationLink::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const relatedInformationLink::typeLink_optional& relatedInformationLink::
  typeLink () const
  {
    return this->typeLink_;
  }

  relatedInformationLink::typeLink_optional& relatedInformationLink::
  typeLink ()
  {
    return this->typeLink_;
  }

  void relatedInformationLink::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void relatedInformationLink::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void relatedInformationLink::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const relatedInformationLink::typeLanguage_optional& relatedInformationLink::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  relatedInformationLink::typeLanguage_optional& relatedInformationLink::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void relatedInformationLink::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void relatedInformationLink::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void relatedInformationLink::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // organisationDepartment
  // 

  const organisationDepartment::departmentId_optional& organisationDepartment::
  departmentId () const
  {
    return this->departmentId_;
  }

  organisationDepartment::departmentId_optional& organisationDepartment::
  departmentId ()
  {
    return this->departmentId_;
  }

  void organisationDepartment::
  departmentId (const departmentId_type& x)
  {
    this->departmentId_.set (x);
  }

  void organisationDepartment::
  departmentId (const departmentId_optional& x)
  {
    this->departmentId_ = x;
  }

  void organisationDepartment::
  departmentId (::std::auto_ptr< departmentId_type > x)
  {
    this->departmentId_.set (x);
  }


  // relatedInformationLink1
  // 

  const relatedInformationLink1::typeLabel_optional& relatedInformationLink1::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  relatedInformationLink1::typeLabel_optional& relatedInformationLink1::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void relatedInformationLink1::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void relatedInformationLink1::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void relatedInformationLink1::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const relatedInformationLink1::typeDefinition_optional& relatedInformationLink1::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  relatedInformationLink1::typeDefinition_optional& relatedInformationLink1::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void relatedInformationLink1::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void relatedInformationLink1::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void relatedInformationLink1::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const relatedInformationLink1::typeLink_optional& relatedInformationLink1::
  typeLink () const
  {
    return this->typeLink_;
  }

  relatedInformationLink1::typeLink_optional& relatedInformationLink1::
  typeLink ()
  {
    return this->typeLink_;
  }

  void relatedInformationLink1::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void relatedInformationLink1::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void relatedInformationLink1::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const relatedInformationLink1::typeLanguage_optional& relatedInformationLink1::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  relatedInformationLink1::typeLanguage_optional& relatedInformationLink1::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void relatedInformationLink1::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void relatedInformationLink1::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void relatedInformationLink1::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // country
  // 

  const country::typeLabel_optional& country::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  country::typeLabel_optional& country::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void country::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void country::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void country::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const country::typeDefinition_optional& country::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  country::typeDefinition_optional& country::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void country::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void country::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void country::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const country::typeLink_optional& country::
  typeLink () const
  {
    return this->typeLink_;
  }

  country::typeLink_optional& country::
  typeLink ()
  {
    return this->typeLink_;
  }

  void country::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void country::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void country::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const country::typeLanguage_optional& country::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  country::typeLanguage_optional& country::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void country::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void country::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void country::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // country1
  // 

  const country1::typeLabel_optional& country1::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  country1::typeLabel_optional& country1::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void country1::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void country1::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void country1::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const country1::typeDefinition_optional& country1::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  country1::typeDefinition_optional& country1::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void country1::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void country1::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void country1::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const country1::typeLink_optional& country1::
  typeLink () const
  {
    return this->typeLink_;
  }

  country1::typeLink_optional& country1::
  typeLink ()
  {
    return this->typeLink_;
  }

  void country1::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void country1::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void country1::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const country1::typeLanguage_optional& country1::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  country1::typeLanguage_optional& country1::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void country1::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void country1::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void country1::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // countryRegion
  // 

  const countryRegion::typeLabel_optional& countryRegion::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  countryRegion::typeLabel_optional& countryRegion::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void countryRegion::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void countryRegion::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void countryRegion::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const countryRegion::typeDefinition_optional& countryRegion::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  countryRegion::typeDefinition_optional& countryRegion::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void countryRegion::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void countryRegion::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void countryRegion::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const countryRegion::typeLink_optional& countryRegion::
  typeLink () const
  {
    return this->typeLink_;
  }

  countryRegion::typeLink_optional& countryRegion::
  typeLink ()
  {
    return this->typeLink_;
  }

  void countryRegion::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void countryRegion::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void countryRegion::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const countryRegion::typeLanguage_optional& countryRegion::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  countryRegion::typeLanguage_optional& countryRegion::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void countryRegion::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void countryRegion::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void countryRegion::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // orientation
  // 

  orientation::
  orientation (value v)
  : ::xml_schema::string (_xsd_orientation_literals_[v])
  {
  }

  orientation::
  orientation (const char* v)
  : ::xml_schema::string (v)
  {
  }

  orientation::
  orientation (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  orientation::
  orientation (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  orientation::
  orientation (const orientation& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  orientation& orientation::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_orientation_literals_[v]);

    return *this;
  }


  // imageEncoding
  // 

  const imageEncoding::typeLabel_optional& imageEncoding::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  imageEncoding::typeLabel_optional& imageEncoding::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void imageEncoding::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void imageEncoding::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void imageEncoding::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const imageEncoding::typeDefinition_optional& imageEncoding::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  imageEncoding::typeDefinition_optional& imageEncoding::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void imageEncoding::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void imageEncoding::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void imageEncoding::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const imageEncoding::typeLink_optional& imageEncoding::
  typeLink () const
  {
    return this->typeLink_;
  }

  imageEncoding::typeLink_optional& imageEncoding::
  typeLink ()
  {
    return this->typeLink_;
  }

  void imageEncoding::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void imageEncoding::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void imageEncoding::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const imageEncoding::typeLanguage_optional& imageEncoding::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  imageEncoding::typeLanguage_optional& imageEncoding::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void imageEncoding::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void imageEncoding::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void imageEncoding::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // comment
  // 

  const comment::typeLabel_optional& comment::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  comment::typeLabel_optional& comment::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void comment::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void comment::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void comment::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const comment::typeDefinition_optional& comment::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  comment::typeDefinition_optional& comment::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void comment::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void comment::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void comment::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const comment::typeLink_optional& comment::
  typeLink () const
  {
    return this->typeLink_;
  }

  comment::typeLink_optional& comment::
  typeLink ()
  {
    return this->typeLink_;
  }

  void comment::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void comment::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void comment::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const comment::typeLanguage_optional& comment::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  comment::typeLanguage_optional& comment::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void comment::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void comment::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void comment::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // width
  // 

  const width::typeLabel_optional& width::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  width::typeLabel_optional& width::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void width::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void width::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void width::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const width::typeDefinition_optional& width::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  width::typeDefinition_optional& width::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void width::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void width::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void width::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const width::typeLink_optional& width::
  typeLink () const
  {
    return this->typeLink_;
  }

  width::typeLink_optional& width::
  typeLink ()
  {
    return this->typeLink_;
  }

  void width::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void width::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void width::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const width::typeLanguage_optional& width::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  width::typeLanguage_optional& width::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void width::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void width::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void width::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // height
  // 

  const height::typeLabel_optional& height::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  height::typeLabel_optional& height::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void height::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void height::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void height::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const height::typeDefinition_optional& height::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  height::typeDefinition_optional& height::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void height::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void height::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void height::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const height::typeLink_optional& height::
  typeLink () const
  {
    return this->typeLink_;
  }

  height::typeLink_optional& height::
  typeLink ()
  {
    return this->typeLink_;
  }

  void height::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void height::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void height::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const height::typeLanguage_optional& height::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  height::typeLanguage_optional& height::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void height::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void height::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void height::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // videoEncoding
  // 

  const videoEncoding::typeLabel_optional& videoEncoding::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  videoEncoding::typeLabel_optional& videoEncoding::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void videoEncoding::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void videoEncoding::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void videoEncoding::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const videoEncoding::typeDefinition_optional& videoEncoding::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  videoEncoding::typeDefinition_optional& videoEncoding::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void videoEncoding::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void videoEncoding::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void videoEncoding::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const videoEncoding::typeLink_optional& videoEncoding::
  typeLink () const
  {
    return this->typeLink_;
  }

  videoEncoding::typeLink_optional& videoEncoding::
  typeLink ()
  {
    return this->typeLink_;
  }

  void videoEncoding::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void videoEncoding::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void videoEncoding::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const videoEncoding::typeLanguage_optional& videoEncoding::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  videoEncoding::typeLanguage_optional& videoEncoding::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void videoEncoding::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void videoEncoding::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void videoEncoding::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // bitRateMode
  // 

  bitRateMode::
  bitRateMode (value v)
  : ::xml_schema::string (_xsd_bitRateMode_literals_[v])
  {
  }

  bitRateMode::
  bitRateMode (const char* v)
  : ::xml_schema::string (v)
  {
  }

  bitRateMode::
  bitRateMode (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  bitRateMode::
  bitRateMode (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  bitRateMode::
  bitRateMode (const bitRateMode& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  bitRateMode& bitRateMode::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_bitRateMode_literals_[v]);

    return *this;
  }


  // scanningFormat
  // 

  scanningFormat::
  scanningFormat (value v)
  : ::xml_schema::string (_xsd_scanningFormat_literals_[v])
  {
  }

  scanningFormat::
  scanningFormat (const char* v)
  : ::xml_schema::string (v)
  {
  }

  scanningFormat::
  scanningFormat (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  scanningFormat::
  scanningFormat (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  scanningFormat::
  scanningFormat (const scanningFormat& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  scanningFormat& scanningFormat::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_scanningFormat_literals_[v]);

    return *this;
  }


  // scanningOrder
  // 

  scanningOrder::
  scanningOrder (value v)
  : ::xml_schema::string (_xsd_scanningOrder_literals_[v])
  {
  }

  scanningOrder::
  scanningOrder (const char* v)
  : ::xml_schema::string (v)
  {
  }

  scanningOrder::
  scanningOrder (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  scanningOrder::
  scanningOrder (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  scanningOrder::
  scanningOrder (const scanningOrder& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  scanningOrder& scanningOrder::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_scanningOrder_literals_[v]);

    return *this;
  }


  // videoTrack
  // 

  const videoTrack::trackId_optional& videoTrack::
  trackId () const
  {
    return this->trackId_;
  }

  videoTrack::trackId_optional& videoTrack::
  trackId ()
  {
    return this->trackId_;
  }

  void videoTrack::
  trackId (const trackId_type& x)
  {
    this->trackId_.set (x);
  }

  void videoTrack::
  trackId (const trackId_optional& x)
  {
    this->trackId_ = x;
  }

  void videoTrack::
  trackId (::std::auto_ptr< trackId_type > x)
  {
    this->trackId_.set (x);
  }

  const videoTrack::trackName_optional& videoTrack::
  trackName () const
  {
    return this->trackName_;
  }

  videoTrack::trackName_optional& videoTrack::
  trackName ()
  {
    return this->trackName_;
  }

  void videoTrack::
  trackName (const trackName_type& x)
  {
    this->trackName_.set (x);
  }

  void videoTrack::
  trackName (const trackName_optional& x)
  {
    this->trackName_ = x;
  }

  void videoTrack::
  trackName (::std::auto_ptr< trackName_type > x)
  {
    this->trackName_.set (x);
  }

  const videoTrack::typeLabel_optional& videoTrack::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  videoTrack::typeLabel_optional& videoTrack::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void videoTrack::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void videoTrack::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void videoTrack::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const videoTrack::typeDefinition_optional& videoTrack::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  videoTrack::typeDefinition_optional& videoTrack::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void videoTrack::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void videoTrack::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void videoTrack::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const videoTrack::typeLink_optional& videoTrack::
  typeLink () const
  {
    return this->typeLink_;
  }

  videoTrack::typeLink_optional& videoTrack::
  typeLink ()
  {
    return this->typeLink_;
  }

  void videoTrack::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void videoTrack::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void videoTrack::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const videoTrack::typeLanguage_optional& videoTrack::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  videoTrack::typeLanguage_optional& videoTrack::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void videoTrack::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void videoTrack::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void videoTrack::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // comment1
  // 

  const comment1::typeLabel_optional& comment1::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  comment1::typeLabel_optional& comment1::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void comment1::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void comment1::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void comment1::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const comment1::typeDefinition_optional& comment1::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  comment1::typeDefinition_optional& comment1::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void comment1::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void comment1::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void comment1::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const comment1::typeLink_optional& comment1::
  typeLink () const
  {
    return this->typeLink_;
  }

  comment1::typeLink_optional& comment1::
  typeLink ()
  {
    return this->typeLink_;
  }

  void comment1::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void comment1::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void comment1::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const comment1::typeLanguage_optional& comment1::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  comment1::typeLanguage_optional& comment1::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void comment1::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void comment1::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void comment1::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // audioEncoding
  // 

  const audioEncoding::typeLabel_optional& audioEncoding::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  audioEncoding::typeLabel_optional& audioEncoding::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void audioEncoding::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void audioEncoding::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void audioEncoding::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const audioEncoding::typeDefinition_optional& audioEncoding::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  audioEncoding::typeDefinition_optional& audioEncoding::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void audioEncoding::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void audioEncoding::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void audioEncoding::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const audioEncoding::typeLink_optional& audioEncoding::
  typeLink () const
  {
    return this->typeLink_;
  }

  audioEncoding::typeLink_optional& audioEncoding::
  typeLink ()
  {
    return this->typeLink_;
  }

  void audioEncoding::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void audioEncoding::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void audioEncoding::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const audioEncoding::typeLanguage_optional& audioEncoding::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  audioEncoding::typeLanguage_optional& audioEncoding::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void audioEncoding::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void audioEncoding::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void audioEncoding::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // audioTrackConfiguration
  // 

  const audioTrackConfiguration::typeLabel_optional& audioTrackConfiguration::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  audioTrackConfiguration::typeLabel_optional& audioTrackConfiguration::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void audioTrackConfiguration::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void audioTrackConfiguration::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void audioTrackConfiguration::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const audioTrackConfiguration::typeDefinition_optional& audioTrackConfiguration::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  audioTrackConfiguration::typeDefinition_optional& audioTrackConfiguration::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void audioTrackConfiguration::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void audioTrackConfiguration::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void audioTrackConfiguration::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const audioTrackConfiguration::typeLink_optional& audioTrackConfiguration::
  typeLink () const
  {
    return this->typeLink_;
  }

  audioTrackConfiguration::typeLink_optional& audioTrackConfiguration::
  typeLink ()
  {
    return this->typeLink_;
  }

  void audioTrackConfiguration::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void audioTrackConfiguration::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void audioTrackConfiguration::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const audioTrackConfiguration::typeLanguage_optional& audioTrackConfiguration::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  audioTrackConfiguration::typeLanguage_optional& audioTrackConfiguration::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void audioTrackConfiguration::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void audioTrackConfiguration::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void audioTrackConfiguration::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // sampleType
  // 

  sampleType::
  sampleType (value v)
  : ::xml_schema::string (_xsd_sampleType_literals_[v])
  {
  }

  sampleType::
  sampleType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  sampleType::
  sampleType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  sampleType::
  sampleType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  sampleType::
  sampleType (const sampleType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  sampleType& sampleType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_sampleType_literals_[v]);

    return *this;
  }


  // bitRateMode1
  // 

  bitRateMode1::
  bitRateMode1 (value v)
  : ::xml_schema::string (_xsd_bitRateMode1_literals_[v])
  {
  }

  bitRateMode1::
  bitRateMode1 (const char* v)
  : ::xml_schema::string (v)
  {
  }

  bitRateMode1::
  bitRateMode1 (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  bitRateMode1::
  bitRateMode1 (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  bitRateMode1::
  bitRateMode1 (const bitRateMode1& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  bitRateMode1& bitRateMode1::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_bitRateMode1_literals_[v]);

    return *this;
  }


  // audioTrack
  // 

  const audioTrack::trackLanguage_optional& audioTrack::
  trackLanguage () const
  {
    return this->trackLanguage_;
  }

  audioTrack::trackLanguage_optional& audioTrack::
  trackLanguage ()
  {
    return this->trackLanguage_;
  }

  void audioTrack::
  trackLanguage (const trackLanguage_type& x)
  {
    this->trackLanguage_.set (x);
  }

  void audioTrack::
  trackLanguage (const trackLanguage_optional& x)
  {
    this->trackLanguage_ = x;
  }

  void audioTrack::
  trackLanguage (::std::auto_ptr< trackLanguage_type > x)
  {
    this->trackLanguage_.set (x);
  }

  const audioTrack::trackId_optional& audioTrack::
  trackId () const
  {
    return this->trackId_;
  }

  audioTrack::trackId_optional& audioTrack::
  trackId ()
  {
    return this->trackId_;
  }

  void audioTrack::
  trackId (const trackId_type& x)
  {
    this->trackId_.set (x);
  }

  void audioTrack::
  trackId (const trackId_optional& x)
  {
    this->trackId_ = x;
  }

  void audioTrack::
  trackId (::std::auto_ptr< trackId_type > x)
  {
    this->trackId_.set (x);
  }

  const audioTrack::trackName_optional& audioTrack::
  trackName () const
  {
    return this->trackName_;
  }

  audioTrack::trackName_optional& audioTrack::
  trackName ()
  {
    return this->trackName_;
  }

  void audioTrack::
  trackName (const trackName_type& x)
  {
    this->trackName_.set (x);
  }

  void audioTrack::
  trackName (const trackName_optional& x)
  {
    this->trackName_ = x;
  }

  void audioTrack::
  trackName (::std::auto_ptr< trackName_type > x)
  {
    this->trackName_.set (x);
  }

  const audioTrack::typeLabel_optional& audioTrack::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  audioTrack::typeLabel_optional& audioTrack::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void audioTrack::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void audioTrack::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void audioTrack::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const audioTrack::typeDefinition_optional& audioTrack::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  audioTrack::typeDefinition_optional& audioTrack::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void audioTrack::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void audioTrack::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void audioTrack::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const audioTrack::typeLink_optional& audioTrack::
  typeLink () const
  {
    return this->typeLink_;
  }

  audioTrack::typeLink_optional& audioTrack::
  typeLink ()
  {
    return this->typeLink_;
  }

  void audioTrack::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void audioTrack::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void audioTrack::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const audioTrack::typeLanguage_optional& audioTrack::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  audioTrack::typeLanguage_optional& audioTrack::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void audioTrack::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void audioTrack::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void audioTrack::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // comment2
  // 

  const comment2::typeLabel_optional& comment2::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  comment2::typeLabel_optional& comment2::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void comment2::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void comment2::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void comment2::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const comment2::typeDefinition_optional& comment2::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  comment2::typeDefinition_optional& comment2::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void comment2::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void comment2::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void comment2::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const comment2::typeLink_optional& comment2::
  typeLink () const
  {
    return this->typeLink_;
  }

  comment2::typeLink_optional& comment2::
  typeLink ()
  {
    return this->typeLink_;
  }

  void comment2::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void comment2::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void comment2::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const comment2::typeLanguage_optional& comment2::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  comment2::typeLanguage_optional& comment2::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void comment2::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void comment2::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void comment2::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // captioningFormat
  // 

  const captioningFormat::captioningFormatId_optional& captioningFormat::
  captioningFormatId () const
  {
    return this->captioningFormatId_;
  }

  captioningFormat::captioningFormatId_optional& captioningFormat::
  captioningFormatId ()
  {
    return this->captioningFormatId_;
  }

  void captioningFormat::
  captioningFormatId (const captioningFormatId_type& x)
  {
    this->captioningFormatId_.set (x);
  }

  void captioningFormat::
  captioningFormatId (const captioningFormatId_optional& x)
  {
    this->captioningFormatId_ = x;
  }

  void captioningFormat::
  captioningFormatId (::std::auto_ptr< captioningFormatId_type > x)
  {
    this->captioningFormatId_.set (x);
  }

  const captioningFormat::captioningFormatName_optional& captioningFormat::
  captioningFormatName () const
  {
    return this->captioningFormatName_;
  }

  captioningFormat::captioningFormatName_optional& captioningFormat::
  captioningFormatName ()
  {
    return this->captioningFormatName_;
  }

  void captioningFormat::
  captioningFormatName (const captioningFormatName_type& x)
  {
    this->captioningFormatName_.set (x);
  }

  void captioningFormat::
  captioningFormatName (const captioningFormatName_optional& x)
  {
    this->captioningFormatName_ = x;
  }

  void captioningFormat::
  captioningFormatName (::std::auto_ptr< captioningFormatName_type > x)
  {
    this->captioningFormatName_.set (x);
  }

  const captioningFormat::trackId_optional& captioningFormat::
  trackId () const
  {
    return this->trackId_;
  }

  captioningFormat::trackId_optional& captioningFormat::
  trackId ()
  {
    return this->trackId_;
  }

  void captioningFormat::
  trackId (const trackId_type& x)
  {
    this->trackId_.set (x);
  }

  void captioningFormat::
  trackId (const trackId_optional& x)
  {
    this->trackId_ = x;
  }

  void captioningFormat::
  trackId (::std::auto_ptr< trackId_type > x)
  {
    this->trackId_.set (x);
  }

  const captioningFormat::trackName_optional& captioningFormat::
  trackName () const
  {
    return this->trackName_;
  }

  captioningFormat::trackName_optional& captioningFormat::
  trackName ()
  {
    return this->trackName_;
  }

  void captioningFormat::
  trackName (const trackName_type& x)
  {
    this->trackName_.set (x);
  }

  void captioningFormat::
  trackName (const trackName_optional& x)
  {
    this->trackName_ = x;
  }

  void captioningFormat::
  trackName (::std::auto_ptr< trackName_type > x)
  {
    this->trackName_.set (x);
  }

  const captioningFormat::captioningSourceUri_optional& captioningFormat::
  captioningSourceUri () const
  {
    return this->captioningSourceUri_;
  }

  captioningFormat::captioningSourceUri_optional& captioningFormat::
  captioningSourceUri ()
  {
    return this->captioningSourceUri_;
  }

  void captioningFormat::
  captioningSourceUri (const captioningSourceUri_type& x)
  {
    this->captioningSourceUri_.set (x);
  }

  void captioningFormat::
  captioningSourceUri (const captioningSourceUri_optional& x)
  {
    this->captioningSourceUri_ = x;
  }

  void captioningFormat::
  captioningSourceUri (::std::auto_ptr< captioningSourceUri_type > x)
  {
    this->captioningSourceUri_.set (x);
  }

  const captioningFormat::language_optional& captioningFormat::
  language () const
  {
    return this->language_;
  }

  captioningFormat::language_optional& captioningFormat::
  language ()
  {
    return this->language_;
  }

  void captioningFormat::
  language (const language_type& x)
  {
    this->language_.set (x);
  }

  void captioningFormat::
  language (const language_optional& x)
  {
    this->language_ = x;
  }

  void captioningFormat::
  language (::std::auto_ptr< language_type > x)
  {
    this->language_.set (x);
  }

  const captioningFormat::closed_optional& captioningFormat::
  closed () const
  {
    return this->closed_;
  }

  captioningFormat::closed_optional& captioningFormat::
  closed ()
  {
    return this->closed_;
  }

  void captioningFormat::
  closed (const closed_type& x)
  {
    this->closed_.set (x);
  }

  void captioningFormat::
  closed (const closed_optional& x)
  {
    this->closed_ = x;
  }

  const captioningFormat::typeLabel_optional& captioningFormat::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  captioningFormat::typeLabel_optional& captioningFormat::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void captioningFormat::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void captioningFormat::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void captioningFormat::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const captioningFormat::typeDefinition_optional& captioningFormat::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  captioningFormat::typeDefinition_optional& captioningFormat::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void captioningFormat::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void captioningFormat::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void captioningFormat::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const captioningFormat::typeLink_optional& captioningFormat::
  typeLink () const
  {
    return this->typeLink_;
  }

  captioningFormat::typeLink_optional& captioningFormat::
  typeLink ()
  {
    return this->typeLink_;
  }

  void captioningFormat::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void captioningFormat::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void captioningFormat::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const captioningFormat::typeLanguage_optional& captioningFormat::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  captioningFormat::typeLanguage_optional& captioningFormat::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void captioningFormat::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void captioningFormat::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void captioningFormat::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const captioningFormat::formatLabel_optional& captioningFormat::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  captioningFormat::formatLabel_optional& captioningFormat::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void captioningFormat::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void captioningFormat::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void captioningFormat::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const captioningFormat::formatDefinition_optional& captioningFormat::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  captioningFormat::formatDefinition_optional& captioningFormat::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void captioningFormat::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void captioningFormat::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void captioningFormat::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const captioningFormat::formatLink_optional& captioningFormat::
  formatLink () const
  {
    return this->formatLink_;
  }

  captioningFormat::formatLink_optional& captioningFormat::
  formatLink ()
  {
    return this->formatLink_;
  }

  void captioningFormat::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void captioningFormat::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void captioningFormat::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const captioningFormat::formatLanguage_optional& captioningFormat::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  captioningFormat::formatLanguage_optional& captioningFormat::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void captioningFormat::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void captioningFormat::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void captioningFormat::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }


  // subtitlingFormat
  // 

  const subtitlingFormat::subtitlingFormatId_optional& subtitlingFormat::
  subtitlingFormatId () const
  {
    return this->subtitlingFormatId_;
  }

  subtitlingFormat::subtitlingFormatId_optional& subtitlingFormat::
  subtitlingFormatId ()
  {
    return this->subtitlingFormatId_;
  }

  void subtitlingFormat::
  subtitlingFormatId (const subtitlingFormatId_type& x)
  {
    this->subtitlingFormatId_.set (x);
  }

  void subtitlingFormat::
  subtitlingFormatId (const subtitlingFormatId_optional& x)
  {
    this->subtitlingFormatId_ = x;
  }

  void subtitlingFormat::
  subtitlingFormatId (::std::auto_ptr< subtitlingFormatId_type > x)
  {
    this->subtitlingFormatId_.set (x);
  }

  const subtitlingFormat::subtitlingFormatName_optional& subtitlingFormat::
  subtitlingFormatName () const
  {
    return this->subtitlingFormatName_;
  }

  subtitlingFormat::subtitlingFormatName_optional& subtitlingFormat::
  subtitlingFormatName ()
  {
    return this->subtitlingFormatName_;
  }

  void subtitlingFormat::
  subtitlingFormatName (const subtitlingFormatName_type& x)
  {
    this->subtitlingFormatName_.set (x);
  }

  void subtitlingFormat::
  subtitlingFormatName (const subtitlingFormatName_optional& x)
  {
    this->subtitlingFormatName_ = x;
  }

  void subtitlingFormat::
  subtitlingFormatName (::std::auto_ptr< subtitlingFormatName_type > x)
  {
    this->subtitlingFormatName_.set (x);
  }

  const subtitlingFormat::trackId_optional& subtitlingFormat::
  trackId () const
  {
    return this->trackId_;
  }

  subtitlingFormat::trackId_optional& subtitlingFormat::
  trackId ()
  {
    return this->trackId_;
  }

  void subtitlingFormat::
  trackId (const trackId_type& x)
  {
    this->trackId_.set (x);
  }

  void subtitlingFormat::
  trackId (const trackId_optional& x)
  {
    this->trackId_ = x;
  }

  void subtitlingFormat::
  trackId (::std::auto_ptr< trackId_type > x)
  {
    this->trackId_.set (x);
  }

  const subtitlingFormat::trackName_optional& subtitlingFormat::
  trackName () const
  {
    return this->trackName_;
  }

  subtitlingFormat::trackName_optional& subtitlingFormat::
  trackName ()
  {
    return this->trackName_;
  }

  void subtitlingFormat::
  trackName (const trackName_type& x)
  {
    this->trackName_.set (x);
  }

  void subtitlingFormat::
  trackName (const trackName_optional& x)
  {
    this->trackName_ = x;
  }

  void subtitlingFormat::
  trackName (::std::auto_ptr< trackName_type > x)
  {
    this->trackName_.set (x);
  }

  const subtitlingFormat::subtitlingSourceUri_optional& subtitlingFormat::
  subtitlingSourceUri () const
  {
    return this->subtitlingSourceUri_;
  }

  subtitlingFormat::subtitlingSourceUri_optional& subtitlingFormat::
  subtitlingSourceUri ()
  {
    return this->subtitlingSourceUri_;
  }

  void subtitlingFormat::
  subtitlingSourceUri (const subtitlingSourceUri_type& x)
  {
    this->subtitlingSourceUri_.set (x);
  }

  void subtitlingFormat::
  subtitlingSourceUri (const subtitlingSourceUri_optional& x)
  {
    this->subtitlingSourceUri_ = x;
  }

  void subtitlingFormat::
  subtitlingSourceUri (::std::auto_ptr< subtitlingSourceUri_type > x)
  {
    this->subtitlingSourceUri_.set (x);
  }

  const subtitlingFormat::language_optional& subtitlingFormat::
  language () const
  {
    return this->language_;
  }

  subtitlingFormat::language_optional& subtitlingFormat::
  language ()
  {
    return this->language_;
  }

  void subtitlingFormat::
  language (const language_type& x)
  {
    this->language_.set (x);
  }

  void subtitlingFormat::
  language (const language_optional& x)
  {
    this->language_ = x;
  }

  void subtitlingFormat::
  language (::std::auto_ptr< language_type > x)
  {
    this->language_.set (x);
  }

  const subtitlingFormat::closed_optional& subtitlingFormat::
  closed () const
  {
    return this->closed_;
  }

  subtitlingFormat::closed_optional& subtitlingFormat::
  closed ()
  {
    return this->closed_;
  }

  void subtitlingFormat::
  closed (const closed_type& x)
  {
    this->closed_.set (x);
  }

  void subtitlingFormat::
  closed (const closed_optional& x)
  {
    this->closed_ = x;
  }

  const subtitlingFormat::typeLabel_optional& subtitlingFormat::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  subtitlingFormat::typeLabel_optional& subtitlingFormat::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void subtitlingFormat::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void subtitlingFormat::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void subtitlingFormat::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const subtitlingFormat::typeDefinition_optional& subtitlingFormat::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  subtitlingFormat::typeDefinition_optional& subtitlingFormat::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void subtitlingFormat::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void subtitlingFormat::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void subtitlingFormat::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const subtitlingFormat::typeLink_optional& subtitlingFormat::
  typeLink () const
  {
    return this->typeLink_;
  }

  subtitlingFormat::typeLink_optional& subtitlingFormat::
  typeLink ()
  {
    return this->typeLink_;
  }

  void subtitlingFormat::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void subtitlingFormat::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void subtitlingFormat::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const subtitlingFormat::typeLanguage_optional& subtitlingFormat::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  subtitlingFormat::typeLanguage_optional& subtitlingFormat::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void subtitlingFormat::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void subtitlingFormat::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void subtitlingFormat::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }

  const subtitlingFormat::formatLabel_optional& subtitlingFormat::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  subtitlingFormat::formatLabel_optional& subtitlingFormat::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void subtitlingFormat::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void subtitlingFormat::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void subtitlingFormat::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const subtitlingFormat::formatDefinition_optional& subtitlingFormat::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  subtitlingFormat::formatDefinition_optional& subtitlingFormat::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void subtitlingFormat::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void subtitlingFormat::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void subtitlingFormat::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const subtitlingFormat::formatLink_optional& subtitlingFormat::
  formatLink () const
  {
    return this->formatLink_;
  }

  subtitlingFormat::formatLink_optional& subtitlingFormat::
  formatLink ()
  {
    return this->formatLink_;
  }

  void subtitlingFormat::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void subtitlingFormat::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void subtitlingFormat::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const subtitlingFormat::formatLanguage_optional& subtitlingFormat::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  subtitlingFormat::formatLanguage_optional& subtitlingFormat::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void subtitlingFormat::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void subtitlingFormat::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void subtitlingFormat::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }


  // ancillaryDataFormat
  // 

  const ancillaryDataFormat::DID_optional& ancillaryDataFormat::
  DID () const
  {
    return this->DID_;
  }

  ancillaryDataFormat::DID_optional& ancillaryDataFormat::
  DID ()
  {
    return this->DID_;
  }

  void ancillaryDataFormat::
  DID (const DID_type& x)
  {
    this->DID_.set (x);
  }

  void ancillaryDataFormat::
  DID (const DID_optional& x)
  {
    this->DID_ = x;
  }

  const ancillaryDataFormat::SDID_optional& ancillaryDataFormat::
  SDID () const
  {
    return this->SDID_;
  }

  ancillaryDataFormat::SDID_optional& ancillaryDataFormat::
  SDID ()
  {
    return this->SDID_;
  }

  void ancillaryDataFormat::
  SDID (const SDID_type& x)
  {
    this->SDID_.set (x);
  }

  void ancillaryDataFormat::
  SDID (const SDID_optional& x)
  {
    this->SDID_ = x;
  }

  const ancillaryDataFormat::lineNumber_sequence& ancillaryDataFormat::
  lineNumber () const
  {
    return this->lineNumber_;
  }

  ancillaryDataFormat::lineNumber_sequence& ancillaryDataFormat::
  lineNumber ()
  {
    return this->lineNumber_;
  }

  void ancillaryDataFormat::
  lineNumber (const lineNumber_sequence& s)
  {
    this->lineNumber_ = s;
  }

  const ancillaryDataFormat::wrappingType_optional& ancillaryDataFormat::
  wrappingType () const
  {
    return this->wrappingType_;
  }

  ancillaryDataFormat::wrappingType_optional& ancillaryDataFormat::
  wrappingType ()
  {
    return this->wrappingType_;
  }

  void ancillaryDataFormat::
  wrappingType (const wrappingType_type& x)
  {
    this->wrappingType_.set (x);
  }

  void ancillaryDataFormat::
  wrappingType (const wrappingType_optional& x)
  {
    this->wrappingType_ = x;
  }

  const ancillaryDataFormat::ancillaryDataFormatId_optional& ancillaryDataFormat::
  ancillaryDataFormatId () const
  {
    return this->ancillaryDataFormatId_;
  }

  ancillaryDataFormat::ancillaryDataFormatId_optional& ancillaryDataFormat::
  ancillaryDataFormatId ()
  {
    return this->ancillaryDataFormatId_;
  }

  void ancillaryDataFormat::
  ancillaryDataFormatId (const ancillaryDataFormatId_type& x)
  {
    this->ancillaryDataFormatId_.set (x);
  }

  void ancillaryDataFormat::
  ancillaryDataFormatId (const ancillaryDataFormatId_optional& x)
  {
    this->ancillaryDataFormatId_ = x;
  }

  void ancillaryDataFormat::
  ancillaryDataFormatId (::std::auto_ptr< ancillaryDataFormatId_type > x)
  {
    this->ancillaryDataFormatId_.set (x);
  }

  const ancillaryDataFormat::ancillaryDataFormatName_optional& ancillaryDataFormat::
  ancillaryDataFormatName () const
  {
    return this->ancillaryDataFormatName_;
  }

  ancillaryDataFormat::ancillaryDataFormatName_optional& ancillaryDataFormat::
  ancillaryDataFormatName ()
  {
    return this->ancillaryDataFormatName_;
  }

  void ancillaryDataFormat::
  ancillaryDataFormatName (const ancillaryDataFormatName_type& x)
  {
    this->ancillaryDataFormatName_.set (x);
  }

  void ancillaryDataFormat::
  ancillaryDataFormatName (const ancillaryDataFormatName_optional& x)
  {
    this->ancillaryDataFormatName_ = x;
  }

  void ancillaryDataFormat::
  ancillaryDataFormatName (::std::auto_ptr< ancillaryDataFormatName_type > x)
  {
    this->ancillaryDataFormatName_.set (x);
  }


  // comment3
  // 

  const comment3::typeLabel_optional& comment3::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  comment3::typeLabel_optional& comment3::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void comment3::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void comment3::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void comment3::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const comment3::typeDefinition_optional& comment3::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  comment3::typeDefinition_optional& comment3::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void comment3::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void comment3::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void comment3::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const comment3::typeLink_optional& comment3::
  typeLink () const
  {
    return this->typeLink_;
  }

  comment3::typeLink_optional& comment3::
  typeLink ()
  {
    return this->typeLink_;
  }

  void comment3::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void comment3::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void comment3::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const comment3::typeLanguage_optional& comment3::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  comment3::typeLanguage_optional& comment3::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void comment3::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void comment3::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void comment3::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // comment4
  // 

  const comment4::typeLabel_optional& comment4::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  comment4::typeLabel_optional& comment4::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void comment4::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void comment4::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void comment4::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const comment4::typeDefinition_optional& comment4::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  comment4::typeDefinition_optional& comment4::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void comment4::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void comment4::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void comment4::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const comment4::typeLink_optional& comment4::
  typeLink () const
  {
    return this->typeLink_;
  }

  comment4::typeLink_optional& comment4::
  typeLink ()
  {
    return this->typeLink_;
  }

  void comment4::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void comment4::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void comment4::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const comment4::typeLanguage_optional& comment4::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  comment4::typeLanguage_optional& comment4::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void comment4::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void comment4::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void comment4::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // timecode
  // 


  // time
  // 

  const time::formatLabel_optional& time::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  time::formatLabel_optional& time::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void time::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void time::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void time::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const time::formatDefinition_optional& time::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  time::formatDefinition_optional& time::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void time::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void time::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void time::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const time::formatLink_optional& time::
  formatLink () const
  {
    return this->formatLink_;
  }

  time::formatLink_optional& time::
  formatLink ()
  {
    return this->formatLink_;
  }

  void time::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void time::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void time::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const time::formatLanguage_optional& time::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  time::formatLanguage_optional& time::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void time::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void time::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void time::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }


  // timecode1
  // 


  // duration
  // 

  const duration::formatLabel_optional& duration::
  formatLabel () const
  {
    return this->formatLabel_;
  }

  duration::formatLabel_optional& duration::
  formatLabel ()
  {
    return this->formatLabel_;
  }

  void duration::
  formatLabel (const formatLabel_type& x)
  {
    this->formatLabel_.set (x);
  }

  void duration::
  formatLabel (const formatLabel_optional& x)
  {
    this->formatLabel_ = x;
  }

  void duration::
  formatLabel (::std::auto_ptr< formatLabel_type > x)
  {
    this->formatLabel_.set (x);
  }

  const duration::formatDefinition_optional& duration::
  formatDefinition () const
  {
    return this->formatDefinition_;
  }

  duration::formatDefinition_optional& duration::
  formatDefinition ()
  {
    return this->formatDefinition_;
  }

  void duration::
  formatDefinition (const formatDefinition_type& x)
  {
    this->formatDefinition_.set (x);
  }

  void duration::
  formatDefinition (const formatDefinition_optional& x)
  {
    this->formatDefinition_ = x;
  }

  void duration::
  formatDefinition (::std::auto_ptr< formatDefinition_type > x)
  {
    this->formatDefinition_.set (x);
  }

  const duration::formatLink_optional& duration::
  formatLink () const
  {
    return this->formatLink_;
  }

  duration::formatLink_optional& duration::
  formatLink ()
  {
    return this->formatLink_;
  }

  void duration::
  formatLink (const formatLink_type& x)
  {
    this->formatLink_.set (x);
  }

  void duration::
  formatLink (const formatLink_optional& x)
  {
    this->formatLink_ = x;
  }

  void duration::
  formatLink (::std::auto_ptr< formatLink_type > x)
  {
    this->formatLink_.set (x);
  }

  const duration::formatLanguage_optional& duration::
  formatLanguage () const
  {
    return this->formatLanguage_;
  }

  duration::formatLanguage_optional& duration::
  formatLanguage ()
  {
    return this->formatLanguage_;
  }

  void duration::
  formatLanguage (const formatLanguage_type& x)
  {
    this->formatLanguage_.set (x);
  }

  void duration::
  formatLanguage (const formatLanguage_optional& x)
  {
    this->formatLanguage_ = x;
  }

  void duration::
  formatLanguage (::std::auto_ptr< formatLanguage_type > x)
  {
    this->formatLanguage_.set (x);
  }


  // hashFunction
  // 

  const hashFunction::typeLabel_optional& hashFunction::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  hashFunction::typeLabel_optional& hashFunction::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void hashFunction::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void hashFunction::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void hashFunction::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const hashFunction::typeDefinition_optional& hashFunction::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  hashFunction::typeDefinition_optional& hashFunction::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void hashFunction::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void hashFunction::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void hashFunction::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const hashFunction::typeLink_optional& hashFunction::
  typeLink () const
  {
    return this->typeLink_;
  }

  hashFunction::typeLink_optional& hashFunction::
  typeLink ()
  {
    return this->typeLink_;
  }

  void hashFunction::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void hashFunction::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void hashFunction::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const hashFunction::typeLanguage_optional& hashFunction::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  hashFunction::typeLanguage_optional& hashFunction::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void hashFunction::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void hashFunction::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void hashFunction::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // mimeType
  // 

  const mimeType::typeLabel_optional& mimeType::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  mimeType::typeLabel_optional& mimeType::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void mimeType::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void mimeType::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void mimeType::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const mimeType::typeDefinition_optional& mimeType::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  mimeType::typeDefinition_optional& mimeType::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void mimeType::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void mimeType::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void mimeType::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const mimeType::typeLink_optional& mimeType::
  typeLink () const
  {
    return this->typeLink_;
  }

  mimeType::typeLink_optional& mimeType::
  typeLink ()
  {
    return this->typeLink_;
  }

  void mimeType::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void mimeType::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void mimeType::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const mimeType::typeLanguage_optional& mimeType::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  mimeType::typeLanguage_optional& mimeType::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void mimeType::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void mimeType::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void mimeType::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }


  // locator
  // 

  const locator::typeLabel_optional& locator::
  typeLabel () const
  {
    return this->typeLabel_;
  }

  locator::typeLabel_optional& locator::
  typeLabel ()
  {
    return this->typeLabel_;
  }

  void locator::
  typeLabel (const typeLabel_type& x)
  {
    this->typeLabel_.set (x);
  }

  void locator::
  typeLabel (const typeLabel_optional& x)
  {
    this->typeLabel_ = x;
  }

  void locator::
  typeLabel (::std::auto_ptr< typeLabel_type > x)
  {
    this->typeLabel_.set (x);
  }

  const locator::typeDefinition_optional& locator::
  typeDefinition () const
  {
    return this->typeDefinition_;
  }

  locator::typeDefinition_optional& locator::
  typeDefinition ()
  {
    return this->typeDefinition_;
  }

  void locator::
  typeDefinition (const typeDefinition_type& x)
  {
    this->typeDefinition_.set (x);
  }

  void locator::
  typeDefinition (const typeDefinition_optional& x)
  {
    this->typeDefinition_ = x;
  }

  void locator::
  typeDefinition (::std::auto_ptr< typeDefinition_type > x)
  {
    this->typeDefinition_.set (x);
  }

  const locator::typeLink_optional& locator::
  typeLink () const
  {
    return this->typeLink_;
  }

  locator::typeLink_optional& locator::
  typeLink ()
  {
    return this->typeLink_;
  }

  void locator::
  typeLink (const typeLink_type& x)
  {
    this->typeLink_.set (x);
  }

  void locator::
  typeLink (const typeLink_optional& x)
  {
    this->typeLink_ = x;
  }

  void locator::
  typeLink (::std::auto_ptr< typeLink_type > x)
  {
    this->typeLink_.set (x);
  }

  const locator::typeLanguage_optional& locator::
  typeLanguage () const
  {
    return this->typeLanguage_;
  }

  locator::typeLanguage_optional& locator::
  typeLanguage ()
  {
    return this->typeLanguage_;
  }

  void locator::
  typeLanguage (const typeLanguage_type& x)
  {
    this->typeLanguage_.set (x);
  }

  void locator::
  typeLanguage (const typeLanguage_optional& x)
  {
    this->typeLanguage_ = x;
  }

  void locator::
  typeLanguage (::std::auto_ptr< typeLanguage_type > x)
  {
    this->typeLanguage_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace ebuCore_2012
{
  // ebuCoreMainType
  //

  const ebuCoreMainType::version_type ebuCoreMainType::version_default_value_ (
    ::xml_schema::simple_type ("1.4"));

  ebuCoreMainType::
  ebuCoreMainType (const coreMetadata_type& coreMetadata)
  : ::xml_schema::type (),
    coreMetadata_ (coreMetadata, ::xml_schema::flags (), this),
    metadataProvider_ (::xml_schema::flags (), this),
    schema_ (::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this),
    dateLastModified_ (::xml_schema::flags (), this),
    documentId_ (::xml_schema::flags (), this),
    documentLocation_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ebuCoreMainType::
  ebuCoreMainType (::std::auto_ptr< coreMetadata_type >& coreMetadata)
  : ::xml_schema::type (),
    coreMetadata_ (coreMetadata, ::xml_schema::flags (), this),
    metadataProvider_ (::xml_schema::flags (), this),
    schema_ (::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this),
    dateLastModified_ (::xml_schema::flags (), this),
    documentId_ (::xml_schema::flags (), this),
    documentLocation_ (::xml_schema::flags (), this),
    lang_ (::xml_schema::flags (), this)
  {
  }

  ebuCoreMainType::
  ebuCoreMainType (const ebuCoreMainType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    coreMetadata_ (x.coreMetadata_, f, this),
    metadataProvider_ (x.metadataProvider_, f, this),
    schema_ (x.schema_, f, this),
    version_ (x.version_, f, this),
    dateLastModified_ (x.dateLastModified_, f, this),
    documentId_ (x.documentId_, f, this),
    documentLocation_ (x.documentLocation_, f, this),
    lang_ (x.lang_, f, this)
  {
  }

  ebuCoreMainType::
  ebuCoreMainType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    coreMetadata_ (f, this),
    metadataProvider_ (f, this),
    schema_ (f, this),
    version_ (f, this),
    dateLastModified_ (f, this),
    documentId_ (f, this),
    documentLocation_ (f, this),
    lang_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ebuCoreMainType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // coreMetadata
      //
      if (n.name () == "coreMetadata" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< coreMetadata_type > r (
          coreMetadata_traits::create (i, f, this));

        if (!coreMetadata_.present ())
        {
          this->coreMetadata_.set (r);
          continue;
        }
      }

      // metadataProvider
      //
      if (n.name () == "metadataProvider" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< metadataProvider_type > r (
          metadataProvider_traits::create (i, f, this));

        if (!this->metadataProvider_)
        {
          this->metadataProvider_.set (r);
          continue;
        }
      }

      break;
    }

    if (!coreMetadata_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "coreMetadata",
        "urn:ebu:metadata-schema:ebuCore_2012");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "schema" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< schema_type > r (
          schema_traits::create (i, f, this));

        this->schema_.set (r);
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }

      if (n.name () == "dateLastModified" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dateLastModified_type > r (
          dateLastModified_traits::create (i, f, this));

        this->dateLastModified_.set (r);
        continue;
      }

      if (n.name () == "documentId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentId_type > r (
          documentId_traits::create (i, f, this));

        this->documentId_.set (r);
        continue;
      }

      if (n.name () == "documentLocation" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentLocation_type > r (
          documentLocation_traits::create (i, f, this));

        this->documentLocation_.set (r);
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        ::std::auto_ptr< lang_type > r (
          lang_traits::create (i, f, this));

        this->lang_.set (r);
        continue;
      }
    }

    if (!version_.present ())
    {
      this->version_.set (version_default_value ());
    }
  }

  ebuCoreMainType* ebuCoreMainType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ebuCoreMainType (*this, f, c);
  }

  ebuCoreMainType::
  ~ebuCoreMainType ()
  {
  }

  // coreMetadataType
  //

  coreMetadataType::
  coreMetadataType ()
  : ::xml_schema::type (),
    title_ (::xml_schema::flags (), this),
    alternativeTitle_ (::xml_schema::flags (), this),
    creator_ (::xml_schema::flags (), this),
    subject_ (::xml_schema::flags (), this),
    description_ (::xml_schema::flags (), this),
    publisher_ (::xml_schema::flags (), this),
    contributor_ (::xml_schema::flags (), this),
    date_ (::xml_schema::flags (), this),
    type_ (::xml_schema::flags (), this),
    format_ (::xml_schema::flags (), this),
    identifier_ (::xml_schema::flags (), this),
    source_ (::xml_schema::flags (), this),
    language_ (::xml_schema::flags (), this),
    relation_ (::xml_schema::flags (), this),
    isVersionOf_ (::xml_schema::flags (), this),
    hasVersion_ (::xml_schema::flags (), this),
    isReplacedBy_ (::xml_schema::flags (), this),
    replaces_ (::xml_schema::flags (), this),
    isRequiredBy_ (::xml_schema::flags (), this),
    requires_ (::xml_schema::flags (), this),
    isPartOf_ (::xml_schema::flags (), this),
    hasPart_ (::xml_schema::flags (), this),
    hasTrackPart_ (::xml_schema::flags (), this),
    isReferencedBy_ (::xml_schema::flags (), this),
    references_ (::xml_schema::flags (), this),
    isFormatOf_ (::xml_schema::flags (), this),
    hasFormat_ (::xml_schema::flags (), this),
    isEpisodeOf_ (::xml_schema::flags (), this),
    isMemberOf_ (::xml_schema::flags (), this),
    hasMember_ (::xml_schema::flags (), this),
    coverage_ (::xml_schema::flags (), this),
    rights_ (::xml_schema::flags (), this),
    version_ (::xml_schema::flags (), this),
    publicationHistory_ (::xml_schema::flags (), this),
    rating_ (::xml_schema::flags (), this),
    part_ (::xml_schema::flags (), this)
  {
  }

  coreMetadataType::
  coreMetadataType (const coreMetadataType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    title_ (x.title_, f, this),
    alternativeTitle_ (x.alternativeTitle_, f, this),
    creator_ (x.creator_, f, this),
    subject_ (x.subject_, f, this),
    description_ (x.description_, f, this),
    publisher_ (x.publisher_, f, this),
    contributor_ (x.contributor_, f, this),
    date_ (x.date_, f, this),
    type_ (x.type_, f, this),
    format_ (x.format_, f, this),
    identifier_ (x.identifier_, f, this),
    source_ (x.source_, f, this),
    language_ (x.language_, f, this),
    relation_ (x.relation_, f, this),
    isVersionOf_ (x.isVersionOf_, f, this),
    hasVersion_ (x.hasVersion_, f, this),
    isReplacedBy_ (x.isReplacedBy_, f, this),
    replaces_ (x.replaces_, f, this),
    isRequiredBy_ (x.isRequiredBy_, f, this),
    requires_ (x.requires_, f, this),
    isPartOf_ (x.isPartOf_, f, this),
    hasPart_ (x.hasPart_, f, this),
    hasTrackPart_ (x.hasTrackPart_, f, this),
    isReferencedBy_ (x.isReferencedBy_, f, this),
    references_ (x.references_, f, this),
    isFormatOf_ (x.isFormatOf_, f, this),
    hasFormat_ (x.hasFormat_, f, this),
    isEpisodeOf_ (x.isEpisodeOf_, f, this),
    isMemberOf_ (x.isMemberOf_, f, this),
    hasMember_ (x.hasMember_, f, this),
    coverage_ (x.coverage_, f, this),
    rights_ (x.rights_, f, this),
    version_ (x.version_, f, this),
    publicationHistory_ (x.publicationHistory_, f, this),
    rating_ (x.rating_, f, this),
    part_ (x.part_, f, this)
  {
  }

  coreMetadataType::
  coreMetadataType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    title_ (f, this),
    alternativeTitle_ (f, this),
    creator_ (f, this),
    subject_ (f, this),
    description_ (f, this),
    publisher_ (f, this),
    contributor_ (f, this),
    date_ (f, this),
    type_ (f, this),
    format_ (f, this),
    identifier_ (f, this),
    source_ (f, this),
    language_ (f, this),
    relation_ (f, this),
    isVersionOf_ (f, this),
    hasVersion_ (f, this),
    isReplacedBy_ (f, this),
    replaces_ (f, this),
    isRequiredBy_ (f, this),
    requires_ (f, this),
    isPartOf_ (f, this),
    hasPart_ (f, this),
    hasTrackPart_ (f, this),
    isReferencedBy_ (f, this),
    references_ (f, this),
    isFormatOf_ (f, this),
    hasFormat_ (f, this),
    isEpisodeOf_ (f, this),
    isMemberOf_ (f, this),
    hasMember_ (f, this),
    coverage_ (f, this),
    rights_ (f, this),
    version_ (f, this),
    publicationHistory_ (f, this),
    rating_ (f, this),
    part_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void coreMetadataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // title
      //
      if (n.name () == "title" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< title_type > r (
          title_traits::create (i, f, this));

        this->title_.push_back (r);
        continue;
      }

      // alternativeTitle
      //
      if (n.name () == "alternativeTitle" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< alternativeTitle_type > r (
          alternativeTitle_traits::create (i, f, this));

        this->alternativeTitle_.push_back (r);
        continue;
      }

      // creator
      //
      if (n.name () == "creator" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< creator_type > r (
          creator_traits::create (i, f, this));

        this->creator_.push_back (r);
        continue;
      }

      // subject
      //
      if (n.name () == "subject" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< subject_type > r (
          subject_traits::create (i, f, this));

        this->subject_.push_back (r);
        continue;
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        this->description_.push_back (r);
        continue;
      }

      // publisher
      //
      if (n.name () == "publisher" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publisher_type > r (
          publisher_traits::create (i, f, this));

        this->publisher_.push_back (r);
        continue;
      }

      // contributor
      //
      if (n.name () == "contributor" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< contributor_type > r (
          contributor_traits::create (i, f, this));

        this->contributor_.push_back (r);
        continue;
      }

      // date
      //
      if (n.name () == "date" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< date_type > r (
          date_traits::create (i, f, this));

        this->date_.push_back (r);
        continue;
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.push_back (r);
        continue;
      }

      // format
      //
      if (n.name () == "format" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< format_type > r (
          format_traits::create (i, f, this));

        this->format_.push_back (r);
        continue;
      }

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        this->identifier_.push_back (r);
        continue;
      }

      // source
      //
      if (n.name () == "source" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< source_type > r (
          source_traits::create (i, f, this));

        this->source_.push_back (r);
        continue;
      }

      // language
      //
      if (n.name () == "language" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< language_type > r (
          language_traits::create (i, f, this));

        this->language_.push_back (r);
        continue;
      }

      // relation
      //
      if (n.name () == "relation" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< relation_type > r (
          relation_traits::create (i, f, this));

        this->relation_.push_back (r);
        continue;
      }

      // isVersionOf
      //
      if (n.name () == "isVersionOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< isVersionOf_type > r (
          isVersionOf_traits::create (i, f, this));

        this->isVersionOf_.push_back (r);
        continue;
      }

      // hasVersion
      //
      if (n.name () == "hasVersion" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< hasVersion_type > r (
          hasVersion_traits::create (i, f, this));

        this->hasVersion_.push_back (r);
        continue;
      }

      // isReplacedBy
      //
      if (n.name () == "isReplacedBy" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< isReplacedBy_type > r (
          isReplacedBy_traits::create (i, f, this));

        this->isReplacedBy_.push_back (r);
        continue;
      }

      // replaces
      //
      if (n.name () == "replaces" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< replaces_type > r (
          replaces_traits::create (i, f, this));

        this->replaces_.push_back (r);
        continue;
      }

      // isRequiredBy
      //
      if (n.name () == "isRequiredBy" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< isRequiredBy_type > r (
          isRequiredBy_traits::create (i, f, this));

        this->isRequiredBy_.push_back (r);
        continue;
      }

      // requires
      //
      if (n.name () == "requires" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< requires_type > r (
          requires_traits::create (i, f, this));

        this->requires_.push_back (r);
        continue;
      }

      // isPartOf
      //
      if (n.name () == "isPartOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< isPartOf_type > r (
          isPartOf_traits::create (i, f, this));

        this->isPartOf_.push_back (r);
        continue;
      }

      // hasPart
      //
      if (n.name () == "hasPart" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< hasPart_type > r (
          hasPart_traits::create (i, f, this));

        this->hasPart_.push_back (r);
        continue;
      }

      // hasTrackPart
      //
      if (n.name () == "hasTrackPart" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< hasTrackPart_type > r (
          hasTrackPart_traits::create (i, f, this));

        this->hasTrackPart_.push_back (r);
        continue;
      }

      // isReferencedBy
      //
      if (n.name () == "isReferencedBy" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< isReferencedBy_type > r (
          isReferencedBy_traits::create (i, f, this));

        this->isReferencedBy_.push_back (r);
        continue;
      }

      // references
      //
      if (n.name () == "references" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< references_type > r (
          references_traits::create (i, f, this));

        this->references_.push_back (r);
        continue;
      }

      // isFormatOf
      //
      if (n.name () == "isFormatOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< isFormatOf_type > r (
          isFormatOf_traits::create (i, f, this));

        this->isFormatOf_.push_back (r);
        continue;
      }

      // hasFormat
      //
      if (n.name () == "hasFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< hasFormat_type > r (
          hasFormat_traits::create (i, f, this));

        this->hasFormat_.push_back (r);
        continue;
      }

      // isEpisodeOf
      //
      if (n.name () == "isEpisodeOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< isEpisodeOf_type > r (
          isEpisodeOf_traits::create (i, f, this));

        this->isEpisodeOf_.push_back (r);
        continue;
      }

      // isMemberOf
      //
      if (n.name () == "isMemberOf" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< isMemberOf_type > r (
          isMemberOf_traits::create (i, f, this));

        this->isMemberOf_.push_back (r);
        continue;
      }

      // hasMember
      //
      if (n.name () == "hasMember" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< hasMember_type > r (
          hasMember_traits::create (i, f, this));

        this->hasMember_.push_back (r);
        continue;
      }

      // coverage
      //
      if (n.name () == "coverage" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< coverage_type > r (
          coverage_traits::create (i, f, this));

        this->coverage_.push_back (r);
        continue;
      }

      // rights
      //
      if (n.name () == "rights" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< rights_type > r (
          rights_traits::create (i, f, this));

        this->rights_.push_back (r);
        continue;
      }

      // version
      //
      if (n.name () == "version" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.push_back (r);
        continue;
      }

      // publicationHistory
      //
      if (n.name () == "publicationHistory" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationHistory_type > r (
          publicationHistory_traits::create (i, f, this));

        if (!this->publicationHistory_)
        {
          this->publicationHistory_.set (r);
          continue;
        }
      }

      // rating
      //
      if (n.name () == "rating" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< rating_type > r (
          rating_traits::create (i, f, this));

        this->rating_.push_back (r);
        continue;
      }

      // part
      //
      if (n.name () == "part" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< part_type > r (
          part_traits::create (i, f, this));

        this->part_.push_back (r);
        continue;
      }

      break;
    }
  }

  coreMetadataType* coreMetadataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class coreMetadataType (*this, f, c);
  }

  coreMetadataType::
  ~coreMetadataType ()
  {
  }

  // partType
  //

  partType::
  partType ()
  : ::ebuCore_2012::coreMetadataType (),
    partStartTime_ (::xml_schema::flags (), this),
    partDuration_ (::xml_schema::flags (), this),
    partId_ (::xml_schema::flags (), this),
    partName_ (::xml_schema::flags (), this),
    partDefinition_ (::xml_schema::flags (), this),
    partNumber_ (::xml_schema::flags (), this),
    partTotalNumber_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  partType::
  partType (const partType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::ebuCore_2012::coreMetadataType (x, f, c),
    partStartTime_ (x.partStartTime_, f, this),
    partDuration_ (x.partDuration_, f, this),
    partId_ (x.partId_, f, this),
    partName_ (x.partName_, f, this),
    partDefinition_ (x.partDefinition_, f, this),
    partNumber_ (x.partNumber_, f, this),
    partTotalNumber_ (x.partTotalNumber_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  partType::
  partType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::ebuCore_2012::coreMetadataType (e, f | ::xml_schema::flags::base, c),
    partStartTime_ (f, this),
    partDuration_ (f, this),
    partId_ (f, this),
    partName_ (f, this),
    partDefinition_ (f, this),
    partNumber_ (f, this),
    partTotalNumber_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void partType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::ebuCore_2012::coreMetadataType::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // partStartTime
      //
      if (n.name () == "partStartTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< partStartTime_type > r (
          partStartTime_traits::create (i, f, this));

        if (!this->partStartTime_)
        {
          this->partStartTime_.set (r);
          continue;
        }
      }

      // partDuration
      //
      if (n.name () == "partDuration" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< partDuration_type > r (
          partDuration_traits::create (i, f, this));

        if (!this->partDuration_)
        {
          this->partDuration_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "partId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< partId_type > r (
          partId_traits::create (i, f, this));

        this->partId_.set (r);
        continue;
      }

      if (n.name () == "partName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< partName_type > r (
          partName_traits::create (i, f, this));

        this->partName_.set (r);
        continue;
      }

      if (n.name () == "partDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< partDefinition_type > r (
          partDefinition_traits::create (i, f, this));

        this->partDefinition_.set (r);
        continue;
      }

      if (n.name () == "partNumber" && n.namespace_ ().empty ())
      {
        this->partNumber_.set (partNumber_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "partTotalNumber" && n.namespace_ ().empty ())
      {
        this->partTotalNumber_.set (partTotalNumber_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  partType* partType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class partType (*this, f, c);
  }

  partType::
  ~partType ()
  {
  }

  // titleType
  //

  titleType::
  titleType ()
  : ::xml_schema::type (),
    title_ (::xml_schema::flags (), this),
    attributiondate_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  titleType::
  titleType (const titleType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    title_ (x.title_, f, this),
    attributiondate_ (x.attributiondate_, f, this),
    note_ (x.note_, f, this)
  {
  }

  titleType::
  titleType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    title_ (f, this),
    attributiondate_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void titleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // title
      //
      if (n.name () == "title" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< title_type > r (
          title_traits::create (i, f, this));

        this->title_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "attributiondate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< attributiondate_type > r (
          attributiondate_traits::create (i, f, this));

        this->attributiondate_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  titleType* titleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class titleType (*this, f, c);
  }

  titleType::
  ~titleType ()
  {
  }

  // alternativeTitleType
  //

  alternativeTitleType::
  alternativeTitleType ()
  : ::xml_schema::type (),
    title_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    statusLabel_ (::xml_schema::flags (), this),
    statusDefinition_ (::xml_schema::flags (), this),
    statusLink_ (::xml_schema::flags (), this),
    statusLanguage_ (::xml_schema::flags (), this),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  alternativeTitleType::
  alternativeTitleType (const alternativeTitleType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    title_ (x.title_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    statusLabel_ (x.statusLabel_, f, this),
    statusDefinition_ (x.statusDefinition_, f, this),
    statusLink_ (x.statusLink_, f, this),
    statusLanguage_ (x.statusLanguage_, f, this),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    note_ (x.note_, f, this)
  {
  }

  alternativeTitleType::
  alternativeTitleType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    title_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    statusLabel_ (f, this),
    statusDefinition_ (f, this),
    statusLink_ (f, this),
    statusLanguage_ (f, this),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void alternativeTitleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // title
      //
      if (n.name () == "title" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< title_type > r (
          title_traits::create (i, f, this));

        this->title_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "statusLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< statusLabel_type > r (
          statusLabel_traits::create (i, f, this));

        this->statusLabel_.set (r);
        continue;
      }

      if (n.name () == "statusDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< statusDefinition_type > r (
          statusDefinition_traits::create (i, f, this));

        this->statusDefinition_.set (r);
        continue;
      }

      if (n.name () == "statusLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< statusLink_type > r (
          statusLink_traits::create (i, f, this));

        this->statusLink_.set (r);
        continue;
      }

      if (n.name () == "statusLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< statusLanguage_type > r (
          statusLanguage_traits::create (i, f, this));

        this->statusLanguage_.set (r);
        continue;
      }

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  alternativeTitleType* alternativeTitleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class alternativeTitleType (*this, f, c);
  }

  alternativeTitleType::
  ~alternativeTitleType ()
  {
  }

  // identifierType
  //

  identifierType::
  identifierType (const identifier_type& identifier)
  : ::xml_schema::type (),
    identifier_ (identifier, ::xml_schema::flags (), this),
    attributor_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  identifierType::
  identifierType (::std::auto_ptr< identifier_type >& identifier)
  : ::xml_schema::type (),
    identifier_ (identifier, ::xml_schema::flags (), this),
    attributor_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  identifierType::
  identifierType (const identifierType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    attributor_ (x.attributor_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this),
    note_ (x.note_, f, this)
  {
  }

  identifierType::
  identifierType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (f, this),
    attributor_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void identifierType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!identifier_.present ())
        {
          this->identifier_.set (r);
          continue;
        }
      }

      // attributor
      //
      if (n.name () == "attributor" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< attributor_type > r (
          attributor_traits::create (i, f, this));

        if (!this->attributor_)
        {
          this->attributor_.set (r);
          continue;
        }
      }

      break;
    }

    if (!identifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "identifier",
        "http://purl.org/dc/elements/1.1/");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  identifierType* identifierType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class identifierType (*this, f, c);
  }

  identifierType::
  ~identifierType ()
  {
  }

  // subjectType
  //

  subjectType::
  subjectType ()
  : ::xml_schema::type (),
    subject_ (::xml_schema::flags (), this),
    subjectCode_ (::xml_schema::flags (), this),
    subjectDefinition_ (::xml_schema::flags (), this),
    attributor_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  subjectType::
  subjectType (const subjectType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    subject_ (x.subject_, f, this),
    subjectCode_ (x.subjectCode_, f, this),
    subjectDefinition_ (x.subjectDefinition_, f, this),
    attributor_ (x.attributor_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    note_ (x.note_, f, this)
  {
  }

  subjectType::
  subjectType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    subject_ (f, this),
    subjectCode_ (f, this),
    subjectDefinition_ (f, this),
    attributor_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void subjectType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // subject
      //
      if (n.name () == "subject" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< subject_type > r (
          subject_traits::create (i, f, this));

        this->subject_.push_back (r);
        continue;
      }

      // subjectCode
      //
      if (n.name () == "subjectCode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< subjectCode_type > r (
          subjectCode_traits::create (i, f, this));

        if (!this->subjectCode_)
        {
          this->subjectCode_.set (r);
          continue;
        }
      }

      // subjectDefinition
      //
      if (n.name () == "subjectDefinition" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< subjectDefinition_type > r (
          subjectDefinition_traits::create (i, f, this));

        this->subjectDefinition_.push_back (r);
        continue;
      }

      // attributor
      //
      if (n.name () == "attributor" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< attributor_type > r (
          attributor_traits::create (i, f, this));

        if (!this->attributor_)
        {
          this->attributor_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  subjectType* subjectType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subjectType (*this, f, c);
  }

  subjectType::
  ~subjectType ()
  {
  }

  // typeType
  //

  typeType::
  typeType ()
  : ::xml_schema::type (),
    type_ (::xml_schema::flags (), this),
    genre_ (::xml_schema::flags (), this),
    objectType_ (::xml_schema::flags (), this),
    targetAudience_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  typeType::
  typeType (const typeType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    genre_ (x.genre_, f, this),
    objectType_ (x.objectType_, f, this),
    targetAudience_ (x.targetAudience_, f, this),
    note_ (x.note_, f, this)
  {
  }

  typeType::
  typeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    genre_ (f, this),
    objectType_ (f, this),
    targetAudience_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void typeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.push_back (r);
        continue;
      }

      // genre
      //
      if (n.name () == "genre" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< genre_type > r (
          genre_traits::create (i, f, this));

        this->genre_.push_back (r);
        continue;
      }

      // objectType
      //
      if (n.name () == "objectType" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< objectType_type > r (
          objectType_traits::create (i, f, this));

        this->objectType_.push_back (r);
        continue;
      }

      // targetAudience
      //
      if (n.name () == "targetAudience" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< targetAudience_type > r (
          targetAudience_traits::create (i, f, this));

        this->targetAudience_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  typeType* typeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class typeType (*this, f, c);
  }

  typeType::
  ~typeType ()
  {
  }

  // descriptionType
  //

  descriptionType::
  descriptionType ()
  : ::xml_schema::type (),
    description_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  descriptionType::
  descriptionType (const descriptionType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    description_ (x.description_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    note_ (x.note_, f, this)
  {
  }

  descriptionType::
  descriptionType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    description_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void descriptionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        this->description_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  descriptionType* descriptionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class descriptionType (*this, f, c);
  }

  descriptionType::
  ~descriptionType ()
  {
  }

  // coverageType
  //

  coverageType::
  coverageType ()
  : ::xml_schema::type (),
    coverage_ (::xml_schema::flags (), this),
    temporal_ (::xml_schema::flags (), this),
    spatial_ (::xml_schema::flags (), this)
  {
  }

  coverageType::
  coverageType (const coverageType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    coverage_ (x.coverage_, f, this),
    temporal_ (x.temporal_, f, this),
    spatial_ (x.spatial_, f, this)
  {
  }

  coverageType::
  coverageType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    coverage_ (f, this),
    temporal_ (f, this),
    spatial_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void coverageType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // coverage
      //
      if (n.name () == "coverage" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< coverage_type > r (
          coverage_traits::create (i, f, this));

        if (!this->coverage_)
        {
          this->coverage_.set (r);
          continue;
        }
      }

      // temporal
      //
      if (n.name () == "temporal" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< temporal_type > r (
          temporal_traits::create (i, f, this));

        if (!this->temporal_)
        {
          this->temporal_.set (r);
          continue;
        }
      }

      // spatial
      //
      if (n.name () == "spatial" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< spatial_type > r (
          spatial_traits::create (i, f, this));

        if (!this->spatial_)
        {
          this->spatial_.set (r);
          continue;
        }
      }

      break;
    }
  }

  coverageType* coverageType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class coverageType (*this, f, c);
  }

  coverageType::
  ~coverageType ()
  {
  }

  // locationType
  //

  locationType::
  locationType ()
  : ::xml_schema::type (),
    name_ (::xml_schema::flags (), this),
    coordinates_ (::xml_schema::flags (), this),
    code_ (::xml_schema::flags (), this),
    region_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this),
    locationId_ (::xml_schema::flags (), this)
  {
  }

  locationType::
  locationType (const locationType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    coordinates_ (x.coordinates_, f, this),
    code_ (x.code_, f, this),
    region_ (x.region_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    note_ (x.note_, f, this),
    locationId_ (x.locationId_, f, this)
  {
  }

  locationType::
  locationType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    coordinates_ (f, this),
    code_ (f, this),
    region_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    note_ (f, this),
    locationId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void locationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (r);
          continue;
        }
      }

      // coordinates
      //
      if (n.name () == "coordinates" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< coordinates_type > r (
          coordinates_traits::create (i, f, this));

        if (!this->coordinates_)
        {
          this->coordinates_.set (r);
          continue;
        }
      }

      // code
      //
      if (n.name () == "code" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< code_type > r (
          code_traits::create (i, f, this));

        if (!this->code_)
        {
          this->code_.set (r);
          continue;
        }
      }

      // region
      //
      if (n.name () == "region" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< region_type > r (
          region_traits::create (i, f, this));

        if (!this->region_)
        {
          this->region_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }

      if (n.name () == "locationId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< locationId_type > r (
          locationId_traits::create (i, f, this));

        this->locationId_.set (r);
        continue;
      }
    }
  }

  locationType* locationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class locationType (*this, f, c);
  }

  locationType::
  ~locationType ()
  {
  }

  // periodOfTimeType
  //

  periodOfTimeType::
  periodOfTimeType ()
  : ::xml_schema::type (),
    periodName_ (::xml_schema::flags (), this),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this)
  {
  }

  periodOfTimeType::
  periodOfTimeType (const periodOfTimeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    periodName_ (x.periodName_, f, this),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this)
  {
  }

  periodOfTimeType::
  periodOfTimeType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    periodName_ (f, this),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void periodOfTimeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // periodName
      //
      if (n.name () == "periodName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< periodName_type > r (
          periodName_traits::create (i, f, this));

        if (!this->periodName_)
        {
          this->periodName_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }
    }
  }

  periodOfTimeType* periodOfTimeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class periodOfTimeType (*this, f, c);
  }

  periodOfTimeType::
  ~periodOfTimeType ()
  {
  }

  // rightsType
  //

  rightsType::
  rightsType ()
  : ::xml_schema::type (),
    rights_ (::xml_schema::flags (), this),
    rightsLink_ (::xml_schema::flags (), this),
    rightsHolder_ (::xml_schema::flags (), this),
    exploitationIssues_ (::xml_schema::flags (), this),
    copyrightStatement_ (::xml_schema::flags (), this),
    coverage_ (::xml_schema::flags (), this),
    rightsClearanceFlag_ (::xml_schema::flags (), this),
    disclaimer_ (::xml_schema::flags (), this),
    rightsAttributedId_ (::xml_schema::flags (), this),
    contactDetails_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this),
    formatIDRefs_ (::xml_schema::flags (), this),
    rightsID_ (::xml_schema::flags (), this)
  {
  }

  rightsType::
  rightsType (const rightsType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    rights_ (x.rights_, f, this),
    rightsLink_ (x.rightsLink_, f, this),
    rightsHolder_ (x.rightsHolder_, f, this),
    exploitationIssues_ (x.exploitationIssues_, f, this),
    copyrightStatement_ (x.copyrightStatement_, f, this),
    coverage_ (x.coverage_, f, this),
    rightsClearanceFlag_ (x.rightsClearanceFlag_, f, this),
    disclaimer_ (x.disclaimer_, f, this),
    rightsAttributedId_ (x.rightsAttributedId_, f, this),
    contactDetails_ (x.contactDetails_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    note_ (x.note_, f, this),
    formatIDRefs_ (x.formatIDRefs_, f, this),
    rightsID_ (x.rightsID_, f, this)
  {
  }

  rightsType::
  rightsType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    rights_ (f, this),
    rightsLink_ (f, this),
    rightsHolder_ (f, this),
    exploitationIssues_ (f, this),
    copyrightStatement_ (f, this),
    coverage_ (f, this),
    rightsClearanceFlag_ (f, this),
    disclaimer_ (f, this),
    rightsAttributedId_ (f, this),
    contactDetails_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    note_ (f, this),
    formatIDRefs_ (f, this),
    rightsID_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void rightsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // rights
      //
      if (n.name () == "rights" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< rights_type > r (
          rights_traits::create (i, f, this));

        this->rights_.push_back (r);
        continue;
      }

      // rightsLink
      //
      if (n.name () == "rightsLink" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< rightsLink_type > r (
          rightsLink_traits::create (i, f, this));

        if (!this->rightsLink_)
        {
          this->rightsLink_.set (r);
          continue;
        }
      }

      // rightsHolder
      //
      if (n.name () == "rightsHolder" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< rightsHolder_type > r (
          rightsHolder_traits::create (i, f, this));

        this->rightsHolder_.push_back (r);
        continue;
      }

      // exploitationIssues
      //
      if (n.name () == "exploitationIssues" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< exploitationIssues_type > r (
          exploitationIssues_traits::create (i, f, this));

        this->exploitationIssues_.push_back (r);
        continue;
      }

      // copyrightStatement
      //
      if (n.name () == "copyrightStatement" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< copyrightStatement_type > r (
          copyrightStatement_traits::create (i, f, this));

        this->copyrightStatement_.push_back (r);
        continue;
      }

      // coverage
      //
      if (n.name () == "coverage" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< coverage_type > r (
          coverage_traits::create (i, f, this));

        if (!this->coverage_)
        {
          this->coverage_.set (r);
          continue;
        }
      }

      // rightsClearanceFlag
      //
      if (n.name () == "rightsClearanceFlag" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->rightsClearanceFlag_)
        {
          this->rightsClearanceFlag_.set (rightsClearanceFlag_traits::create (i, f, this));
          continue;
        }
      }

      // disclaimer
      //
      if (n.name () == "disclaimer" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< disclaimer_type > r (
          disclaimer_traits::create (i, f, this));

        this->disclaimer_.push_back (r);
        continue;
      }

      // rightsAttributedId
      //
      if (n.name () == "rightsAttributedId" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< rightsAttributedId_type > r (
          rightsAttributedId_traits::create (i, f, this));

        this->rightsAttributedId_.push_back (r);
        continue;
      }

      // contactDetails
      //
      if (n.name () == "contactDetails" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< contactDetails_type > r (
          contactDetails_traits::create (i, f, this));

        this->contactDetails_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }

      if (n.name () == "formatIDRefs" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatIDRefs_type > r (
          formatIDRefs_traits::create (i, f, this));

        this->formatIDRefs_.set (r);
        continue;
      }

      if (n.name () == "rightsID" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< rightsID_type > r (
          rightsID_traits::create (i, f, this));

        this->rightsID_.set (r);
        continue;
      }
    }
  }

  rightsType* rightsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class rightsType (*this, f, c);
  }

  rightsType::
  ~rightsType ()
  {
  }

  // relationType
  //

  relationType::
  relationType ()
  : ::xml_schema::type (),
    relation_ (::xml_schema::flags (), this),
    relationIdentifier_ (::xml_schema::flags (), this),
    relationLink_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    runningOrderNumber_ (::xml_schema::flags (), this),
    totalNumberOfGroupMembers_ (::xml_schema::flags (), this),
    orderedGroupFlag_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  relationType::
  relationType (const relationType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    relation_ (x.relation_, f, this),
    relationIdentifier_ (x.relationIdentifier_, f, this),
    relationLink_ (x.relationLink_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    runningOrderNumber_ (x.runningOrderNumber_, f, this),
    totalNumberOfGroupMembers_ (x.totalNumberOfGroupMembers_, f, this),
    orderedGroupFlag_ (x.orderedGroupFlag_, f, this),
    note_ (x.note_, f, this)
  {
  }

  relationType::
  relationType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    relation_ (f, this),
    relationIdentifier_ (f, this),
    relationLink_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    runningOrderNumber_ (f, this),
    totalNumberOfGroupMembers_ (f, this),
    orderedGroupFlag_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void relationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // relation
      //
      if (n.name () == "relation" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< relation_type > r (
          relation_traits::create (i, f, this));

        if (!this->relation_)
        {
          this->relation_.set (r);
          continue;
        }
      }

      // relationIdentifier
      //
      if (n.name () == "relationIdentifier" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< relationIdentifier_type > r (
          relationIdentifier_traits::create (i, f, this));

        if (!this->relationIdentifier_)
        {
          this->relationIdentifier_.set (r);
          continue;
        }
      }

      // relationLink
      //
      if (n.name () == "relationLink" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< relationLink_type > r (
          relationLink_traits::create (i, f, this));

        if (!this->relationLink_)
        {
          this->relationLink_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "runningOrderNumber" && n.namespace_ ().empty ())
      {
        this->runningOrderNumber_.set (runningOrderNumber_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "totalNumberOfGroupMembers" && n.namespace_ ().empty ())
      {
        this->totalNumberOfGroupMembers_.set (totalNumberOfGroupMembers_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "orderedGroupFlag" && n.namespace_ ().empty ())
      {
        this->orderedGroupFlag_.set (orderedGroupFlag_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  relationType* relationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class relationType (*this, f, c);
  }

  relationType::
  ~relationType ()
  {
  }

  // languageType
  //

  languageType::
  languageType ()
  : ::xml_schema::type (),
    language_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this)
  {
  }

  languageType::
  languageType (const languageType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    language_ (x.language_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    note_ (x.note_, f, this)
  {
  }

  languageType::
  languageType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    language_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    note_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void languageType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // language
      //
      if (n.name () == "language" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< language_type > r (
          language_traits::create (i, f, this));

        if (!this->language_)
        {
          this->language_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }
    }
  }

  languageType* languageType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class languageType (*this, f, c);
  }

  languageType::
  ~languageType ()
  {
  }

  // dateType
  //

  dateType::
  dateType ()
  : ::xml_schema::type (),
    date_ (::xml_schema::flags (), this),
    created_ (::xml_schema::flags (), this),
    issued_ (::xml_schema::flags (), this),
    modified_ (::xml_schema::flags (), this),
    digitised_ (::xml_schema::flags (), this),
    released_ (::xml_schema::flags (), this),
    copyrighted_ (::xml_schema::flags (), this),
    alternative_ (::xml_schema::flags (), this)
  {
  }

  dateType::
  dateType (const dateType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    date_ (x.date_, f, this),
    created_ (x.created_, f, this),
    issued_ (x.issued_, f, this),
    modified_ (x.modified_, f, this),
    digitised_ (x.digitised_, f, this),
    released_ (x.released_, f, this),
    copyrighted_ (x.copyrighted_, f, this),
    alternative_ (x.alternative_, f, this)
  {
  }

  dateType::
  dateType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    date_ (f, this),
    created_ (f, this),
    issued_ (f, this),
    modified_ (f, this),
    digitised_ (f, this),
    released_ (f, this),
    copyrighted_ (f, this),
    alternative_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void dateType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // date
      //
      if (n.name () == "date" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< date_type > r (
          date_traits::create (i, f, this));

        this->date_.push_back (r);
        continue;
      }

      // created
      //
      if (n.name () == "created" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< created_type > r (
          created_traits::create (i, f, this));

        if (!this->created_)
        {
          this->created_.set (r);
          continue;
        }
      }

      // issued
      //
      if (n.name () == "issued" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< issued_type > r (
          issued_traits::create (i, f, this));

        if (!this->issued_)
        {
          this->issued_.set (r);
          continue;
        }
      }

      // modified
      //
      if (n.name () == "modified" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< modified_type > r (
          modified_traits::create (i, f, this));

        if (!this->modified_)
        {
          this->modified_.set (r);
          continue;
        }
      }

      // digitised
      //
      if (n.name () == "digitised" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< digitised_type > r (
          digitised_traits::create (i, f, this));

        if (!this->digitised_)
        {
          this->digitised_.set (r);
          continue;
        }
      }

      // released
      //
      if (n.name () == "released" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< released_type > r (
          released_traits::create (i, f, this));

        if (!this->released_)
        {
          this->released_.set (r);
          continue;
        }
      }

      // copyrighted
      //
      if (n.name () == "copyrighted" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< copyrighted_type > r (
          copyrighted_traits::create (i, f, this));

        if (!this->copyrighted_)
        {
          this->copyrighted_.set (r);
          continue;
        }
      }

      // alternative
      //
      if (n.name () == "alternative" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< alternative_type > r (
          alternative_traits::create (i, f, this));

        this->alternative_.push_back (r);
        continue;
      }

      break;
    }
  }

  dateType* dateType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dateType (*this, f, c);
  }

  dateType::
  ~dateType ()
  {
  }

  // publicationHistoryType
  //

  publicationHistoryType::
  publicationHistoryType ()
  : ::xml_schema::type (),
    publicationEvent_ (::xml_schema::flags (), this)
  {
  }

  publicationHistoryType::
  publicationHistoryType (const publicationHistoryType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    publicationEvent_ (x.publicationEvent_, f, this)
  {
  }

  publicationHistoryType::
  publicationHistoryType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    publicationEvent_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void publicationHistoryType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // publicationEvent
      //
      if (n.name () == "publicationEvent" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationEvent_type > r (
          publicationEvent_traits::create (i, f, this));

        this->publicationEvent_.push_back (r);
        continue;
      }

      break;
    }
  }

  publicationHistoryType* publicationHistoryType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class publicationHistoryType (*this, f, c);
  }

  publicationHistoryType::
  ~publicationHistoryType ()
  {
  }

  // publicationEventType
  //

  publicationEventType::
  publicationEventType ()
  : ::xml_schema::type (),
    publicationDate_ (::xml_schema::flags (), this),
    publicationTime_ (::xml_schema::flags (), this),
    publicationService_ (::xml_schema::flags (), this),
    publicationMedium_ (::xml_schema::flags (), this),
    publicationChannel_ (::xml_schema::flags (), this),
    publicationRegion_ (::xml_schema::flags (), this),
    firstShowing_ (::xml_schema::flags (), this),
    live_ (::xml_schema::flags (), this),
    free_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this),
    formatIdRef_ (::xml_schema::flags (), this),
    rightsIDRefs_ (::xml_schema::flags (), this)
  {
  }

  publicationEventType::
  publicationEventType (const publicationEventType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    publicationDate_ (x.publicationDate_, f, this),
    publicationTime_ (x.publicationTime_, f, this),
    publicationService_ (x.publicationService_, f, this),
    publicationMedium_ (x.publicationMedium_, f, this),
    publicationChannel_ (x.publicationChannel_, f, this),
    publicationRegion_ (x.publicationRegion_, f, this),
    firstShowing_ (x.firstShowing_, f, this),
    live_ (x.live_, f, this),
    free_ (x.free_, f, this),
    note_ (x.note_, f, this),
    formatIdRef_ (x.formatIdRef_, f, this),
    rightsIDRefs_ (x.rightsIDRefs_, f, this)
  {
  }

  publicationEventType::
  publicationEventType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    publicationDate_ (f, this),
    publicationTime_ (f, this),
    publicationService_ (f, this),
    publicationMedium_ (f, this),
    publicationChannel_ (f, this),
    publicationRegion_ (f, this),
    firstShowing_ (f, this),
    live_ (f, this),
    free_ (f, this),
    note_ (f, this),
    formatIdRef_ (f, this),
    rightsIDRefs_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void publicationEventType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // publicationDate
      //
      if (n.name () == "publicationDate" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationDate_type > r (
          publicationDate_traits::create (i, f, this));

        if (!this->publicationDate_)
        {
          this->publicationDate_.set (r);
          continue;
        }
      }

      // publicationTime
      //
      if (n.name () == "publicationTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationTime_type > r (
          publicationTime_traits::create (i, f, this));

        if (!this->publicationTime_)
        {
          this->publicationTime_.set (r);
          continue;
        }
      }

      // publicationService
      //
      if (n.name () == "publicationService" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationService_type > r (
          publicationService_traits::create (i, f, this));

        if (!this->publicationService_)
        {
          this->publicationService_.set (r);
          continue;
        }
      }

      // publicationMedium
      //
      if (n.name () == "publicationMedium" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationMedium_type > r (
          publicationMedium_traits::create (i, f, this));

        if (!this->publicationMedium_)
        {
          this->publicationMedium_.set (r);
          continue;
        }
      }

      // publicationChannel
      //
      if (n.name () == "publicationChannel" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationChannel_type > r (
          publicationChannel_traits::create (i, f, this));

        if (!this->publicationChannel_)
        {
          this->publicationChannel_.set (r);
          continue;
        }
      }

      // publicationRegion
      //
      if (n.name () == "publicationRegion" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationRegion_type > r (
          publicationRegion_traits::create (i, f, this));

        this->publicationRegion_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "firstShowing" && n.namespace_ ().empty ())
      {
        this->firstShowing_.set (firstShowing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "live" && n.namespace_ ().empty ())
      {
        this->live_.set (live_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "free" && n.namespace_ ().empty ())
      {
        this->free_.set (free_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }

      if (n.name () == "formatIdRef" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatIdRef_type > r (
          formatIdRef_traits::create (i, f, this));

        this->formatIdRef_.set (r);
        continue;
      }

      if (n.name () == "rightsIDRefs" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< rightsIDRefs_type > r (
          rightsIDRefs_traits::create (i, f, this));

        this->rightsIDRefs_.set (r);
        continue;
      }
    }
  }

  publicationEventType* publicationEventType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class publicationEventType (*this, f, c);
  }

  publicationEventType::
  ~publicationEventType ()
  {
  }

  // publicationServiceType
  //

  publicationServiceType::
  publicationServiceType ()
  : ::xml_schema::type (),
    publicationServiceName_ (::xml_schema::flags (), this),
    publicationSource_ (::xml_schema::flags (), this)
  {
  }

  publicationServiceType::
  publicationServiceType (const publicationServiceType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    publicationServiceName_ (x.publicationServiceName_, f, this),
    publicationSource_ (x.publicationSource_, f, this)
  {
  }

  publicationServiceType::
  publicationServiceType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    publicationServiceName_ (f, this),
    publicationSource_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void publicationServiceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // publicationServiceName
      //
      if (n.name () == "publicationServiceName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationServiceName_type > r (
          publicationServiceName_traits::create (i, f, this));

        if (!this->publicationServiceName_)
        {
          this->publicationServiceName_.set (r);
          continue;
        }
      }

      // publicationSource
      //
      if (n.name () == "publicationSource" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< publicationSource_type > r (
          publicationSource_traits::create (i, f, this));

        if (!this->publicationSource_)
        {
          this->publicationSource_.set (r);
          continue;
        }
      }

      break;
    }
  }

  publicationServiceType* publicationServiceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class publicationServiceType (*this, f, c);
  }

  publicationServiceType::
  ~publicationServiceType ()
  {
  }

  // publicationMediumType
  //

  publicationMediumType::
  publicationMediumType ()
  : ::xml_schema::string (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  publicationMediumType::
  publicationMediumType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  publicationMediumType::
  publicationMediumType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  publicationMediumType::
  publicationMediumType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  publicationMediumType::
  publicationMediumType (const publicationMediumType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  publicationMediumType::
  publicationMediumType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void publicationMediumType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  publicationMediumType* publicationMediumType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class publicationMediumType (*this, f, c);
  }

  publicationMediumType::
  ~publicationMediumType ()
  {
  }

  // publicationChannelType
  //

  publicationChannelType::
  publicationChannelType ()
  : ::xml_schema::string (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  publicationChannelType::
  publicationChannelType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  publicationChannelType::
  publicationChannelType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  publicationChannelType::
  publicationChannelType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  publicationChannelType::
  publicationChannelType (const publicationChannelType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  publicationChannelType::
  publicationChannelType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void publicationChannelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  publicationChannelType* publicationChannelType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class publicationChannelType (*this, f, c);
  }

  publicationChannelType::
  ~publicationChannelType ()
  {
  }

  // formatType
  //

  formatType::
  formatType ()
  : ::xml_schema::type (),
    format_ (::xml_schema::flags (), this),
    medium_ (::xml_schema::flags (), this),
    imageFormat_ (::xml_schema::flags (), this),
    videoFormat_ (::xml_schema::flags (), this),
    audioFormat_ (::xml_schema::flags (), this),
    containerFormat_ (::xml_schema::flags (), this),
    dataFormat_ (::xml_schema::flags (), this),
    signingFormat_ (::xml_schema::flags (), this),
    start_ (::xml_schema::flags (), this),
    end_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    fileSize_ (::xml_schema::flags (), this),
    fileName_ (::xml_schema::flags (), this),
    mimeType_ (::xml_schema::flags (), this),
    locator_ (::xml_schema::flags (), this),
    hash_ (::xml_schema::flags (), this),
    documentFormat_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    dateCreated_ (::xml_schema::flags (), this),
    dateModified_ (::xml_schema::flags (), this),
    formatId_ (::xml_schema::flags (), this),
    formatVersionId_ (::xml_schema::flags (), this),
    formatName_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this)
  {
  }

  formatType::
  formatType (const formatType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    format_ (x.format_, f, this),
    medium_ (x.medium_, f, this),
    imageFormat_ (x.imageFormat_, f, this),
    videoFormat_ (x.videoFormat_, f, this),
    audioFormat_ (x.audioFormat_, f, this),
    containerFormat_ (x.containerFormat_, f, this),
    dataFormat_ (x.dataFormat_, f, this),
    signingFormat_ (x.signingFormat_, f, this),
    start_ (x.start_, f, this),
    end_ (x.end_, f, this),
    duration_ (x.duration_, f, this),
    fileSize_ (x.fileSize_, f, this),
    fileName_ (x.fileName_, f, this),
    mimeType_ (x.mimeType_, f, this),
    locator_ (x.locator_, f, this),
    hash_ (x.hash_, f, this),
    documentFormat_ (x.documentFormat_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    dateCreated_ (x.dateCreated_, f, this),
    dateModified_ (x.dateModified_, f, this),
    formatId_ (x.formatId_, f, this),
    formatVersionId_ (x.formatVersionId_, f, this),
    formatName_ (x.formatName_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this)
  {
  }

  formatType::
  formatType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    format_ (f, this),
    medium_ (f, this),
    imageFormat_ (f, this),
    videoFormat_ (f, this),
    audioFormat_ (f, this),
    containerFormat_ (f, this),
    dataFormat_ (f, this),
    signingFormat_ (f, this),
    start_ (f, this),
    end_ (f, this),
    duration_ (f, this),
    fileSize_ (f, this),
    fileName_ (f, this),
    mimeType_ (f, this),
    locator_ (f, this),
    hash_ (f, this),
    documentFormat_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    dateCreated_ (f, this),
    dateModified_ (f, this),
    formatId_ (f, this),
    formatVersionId_ (f, this),
    formatName_ (f, this),
    formatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void formatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // format
      //
      if (n.name () == "format" && n.namespace_ () == "http://purl.org/dc/elements/1.1/")
      {
        ::std::auto_ptr< format_type > r (
          format_traits::create (i, f, this));

        if (!this->format_)
        {
          this->format_.set (r);
          continue;
        }
      }

      // medium
      //
      if (n.name () == "medium" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< medium_type > r (
          medium_traits::create (i, f, this));

        this->medium_.push_back (r);
        continue;
      }

      // imageFormat
      //
      if (n.name () == "imageFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< imageFormat_type > r (
          imageFormat_traits::create (i, f, this));

        this->imageFormat_.push_back (r);
        continue;
      }

      // videoFormat
      //
      if (n.name () == "videoFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< videoFormat_type > r (
          videoFormat_traits::create (i, f, this));

        this->videoFormat_.push_back (r);
        continue;
      }

      // audioFormat
      //
      if (n.name () == "audioFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< audioFormat_type > r (
          audioFormat_traits::create (i, f, this));

        this->audioFormat_.push_back (r);
        continue;
      }

      // containerFormat
      //
      if (n.name () == "containerFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< containerFormat_type > r (
          containerFormat_traits::create (i, f, this));

        this->containerFormat_.push_back (r);
        continue;
      }

      // dataFormat
      //
      if (n.name () == "dataFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< dataFormat_type > r (
          dataFormat_traits::create (i, f, this));

        this->dataFormat_.push_back (r);
        continue;
      }

      // signingFormat
      //
      if (n.name () == "signingFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< signingFormat_type > r (
          signingFormat_traits::create (i, f, this));

        this->signingFormat_.push_back (r);
        continue;
      }

      // start
      //
      if (n.name () == "start" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< start_type > r (
          start_traits::create (i, f, this));

        if (!this->start_)
        {
          this->start_.set (r);
          continue;
        }
      }

      // end
      //
      if (n.name () == "end" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< end_type > r (
          end_traits::create (i, f, this));

        if (!this->end_)
        {
          this->end_.set (r);
          continue;
        }
      }

      // duration
      //
      if (n.name () == "duration" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        if (!this->duration_)
        {
          this->duration_.set (r);
          continue;
        }
      }

      // fileSize
      //
      if (n.name () == "fileSize" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->fileSize_)
        {
          this->fileSize_.set (fileSize_traits::create (i, f, this));
          continue;
        }
      }

      // fileName
      //
      if (n.name () == "fileName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< fileName_type > r (
          fileName_traits::create (i, f, this));

        if (!this->fileName_)
        {
          this->fileName_.set (r);
          continue;
        }
      }

      // mimeType
      //
      if (n.name () == "mimeType" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< mimeType_type > r (
          mimeType_traits::create (i, f, this));

        this->mimeType_.push_back (r);
        continue;
      }

      // locator
      //
      if (n.name () == "locator" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< locator_type > r (
          locator_traits::create (i, f, this));

        this->locator_.push_back (r);
        continue;
      }

      // hash
      //
      if (n.name () == "hash" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< hash_type > r (
          hash_traits::create (i, f, this));

        if (!this->hash_)
        {
          this->hash_.set (r);
          continue;
        }
      }

      // documentFormat
      //
      if (n.name () == "documentFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< documentFormat_type > r (
          documentFormat_traits::create (i, f, this));

        if (!this->documentFormat_)
        {
          this->documentFormat_.set (r);
          continue;
        }
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      // dateCreated
      //
      if (n.name () == "dateCreated" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< dateCreated_type > r (
          dateCreated_traits::create (i, f, this));

        if (!this->dateCreated_)
        {
          this->dateCreated_.set (r);
          continue;
        }
      }

      // dateModified
      //
      if (n.name () == "dateModified" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< dateModified_type > r (
          dateModified_traits::create (i, f, this));

        if (!this->dateModified_)
        {
          this->dateModified_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatId_type > r (
          formatId_traits::create (i, f, this));

        this->formatId_.set (r);
        continue;
      }

      if (n.name () == "formatVersionId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatVersionId_type > r (
          formatVersionId_traits::create (i, f, this));

        this->formatVersionId_.set (r);
        continue;
      }

      if (n.name () == "formatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatName_type > r (
          formatName_traits::create (i, f, this));

        this->formatName_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }
    }
  }

  formatType* formatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class formatType (*this, f, c);
  }

  formatType::
  ~formatType ()
  {
  }

  // entityType
  //

  entityType::
  entityType ()
  : ::xml_schema::type (),
    contactDetails_ (::xml_schema::flags (), this),
    organisationDetails_ (::xml_schema::flags (), this),
    role_ (::xml_schema::flags (), this),
    entityId_ (::xml_schema::flags (), this)
  {
  }

  entityType::
  entityType (const entityType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    contactDetails_ (x.contactDetails_, f, this),
    organisationDetails_ (x.organisationDetails_, f, this),
    role_ (x.role_, f, this),
    entityId_ (x.entityId_, f, this)
  {
  }

  entityType::
  entityType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    contactDetails_ (f, this),
    organisationDetails_ (f, this),
    role_ (f, this),
    entityId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void entityType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // contactDetails
      //
      if (n.name () == "contactDetails" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< contactDetails_type > r (
          contactDetails_traits::create (i, f, this));

        this->contactDetails_.push_back (r);
        continue;
      }

      // organisationDetails
      //
      if (n.name () == "organisationDetails" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< organisationDetails_type > r (
          organisationDetails_traits::create (i, f, this));

        this->organisationDetails_.push_back (r);
        continue;
      }

      // role
      //
      if (n.name () == "role" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< role_type > r (
          role_traits::create (i, f, this));

        this->role_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "entityId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< entityId_type > r (
          entityId_traits::create (i, f, this));

        this->entityId_.set (r);
        continue;
      }
    }
  }

  entityType* entityType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class entityType (*this, f, c);
  }

  entityType::
  ~entityType ()
  {
  }

  // contactDetailsType
  //

  contactDetailsType::
  contactDetailsType ()
  : ::xml_schema::type (),
    name_ (::xml_schema::flags (), this),
    givenName_ (::xml_schema::flags (), this),
    familyName_ (::xml_schema::flags (), this),
    otherGivenName_ (::xml_schema::flags (), this),
    suffix_ (::xml_schema::flags (), this),
    salutation_ (::xml_schema::flags (), this),
    username_ (::xml_schema::flags (), this),
    occupation_ (::xml_schema::flags (), this),
    details_ (::xml_schema::flags (), this),
    stageName_ (::xml_schema::flags (), this),
    guest_ (::xml_schema::flags (), this),
    gender_ (::xml_schema::flags (), this),
    relatedInformationLink_ (::xml_schema::flags (), this),
    relatedContacts_ (::xml_schema::flags (), this),
    contactId_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  contactDetailsType::
  contactDetailsType (const contactDetailsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    givenName_ (x.givenName_, f, this),
    familyName_ (x.familyName_, f, this),
    otherGivenName_ (x.otherGivenName_, f, this),
    suffix_ (x.suffix_, f, this),
    salutation_ (x.salutation_, f, this),
    username_ (x.username_, f, this),
    occupation_ (x.occupation_, f, this),
    details_ (x.details_, f, this),
    stageName_ (x.stageName_, f, this),
    guest_ (x.guest_, f, this),
    gender_ (x.gender_, f, this),
    relatedInformationLink_ (x.relatedInformationLink_, f, this),
    relatedContacts_ (x.relatedContacts_, f, this),
    contactId_ (x.contactId_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  contactDetailsType::
  contactDetailsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    givenName_ (f, this),
    familyName_ (f, this),
    otherGivenName_ (f, this),
    suffix_ (f, this),
    salutation_ (f, this),
    username_ (f, this),
    occupation_ (f, this),
    details_ (f, this),
    stageName_ (f, this),
    guest_ (f, this),
    gender_ (f, this),
    relatedInformationLink_ (f, this),
    relatedContacts_ (f, this),
    contactId_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void contactDetailsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.push_back (r);
        continue;
      }

      // givenName
      //
      if (n.name () == "givenName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< givenName_type > r (
          givenName_traits::create (i, f, this));

        if (!this->givenName_)
        {
          this->givenName_.set (r);
          continue;
        }
      }

      // familyName
      //
      if (n.name () == "familyName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< familyName_type > r (
          familyName_traits::create (i, f, this));

        if (!this->familyName_)
        {
          this->familyName_.set (r);
          continue;
        }
      }

      // otherGivenName
      //
      if (n.name () == "otherGivenName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< otherGivenName_type > r (
          otherGivenName_traits::create (i, f, this));

        this->otherGivenName_.push_back (r);
        continue;
      }

      // suffix
      //
      if (n.name () == "suffix" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< suffix_type > r (
          suffix_traits::create (i, f, this));

        if (!this->suffix_)
        {
          this->suffix_.set (r);
          continue;
        }
      }

      // salutation
      //
      if (n.name () == "salutation" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< salutation_type > r (
          salutation_traits::create (i, f, this));

        if (!this->salutation_)
        {
          this->salutation_.set (r);
          continue;
        }
      }

      // username
      //
      if (n.name () == "username" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< username_type > r (
          username_traits::create (i, f, this));

        this->username_.push_back (r);
        continue;
      }

      // occupation
      //
      if (n.name () == "occupation" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< occupation_type > r (
          occupation_traits::create (i, f, this));

        if (!this->occupation_)
        {
          this->occupation_.set (r);
          continue;
        }
      }

      // details
      //
      if (n.name () == "details" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< details_type > r (
          details_traits::create (i, f, this));

        this->details_.push_back (r);
        continue;
      }

      // stageName
      //
      if (n.name () == "stageName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< stageName_type > r (
          stageName_traits::create (i, f, this));

        this->stageName_.push_back (r);
        continue;
      }

      // guest
      //
      if (n.name () == "guest" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->guest_)
        {
          this->guest_.set (guest_traits::create (i, f, this));
          continue;
        }
      }

      // gender
      //
      if (n.name () == "gender" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< gender_type > r (
          gender_traits::create (i, f, this));

        if (!this->gender_)
        {
          this->gender_.set (r);
          continue;
        }
      }

      // relatedInformationLink
      //
      if (n.name () == "relatedInformationLink" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< relatedInformationLink_type > r (
          relatedInformationLink_traits::create (i, f, this));

        this->relatedInformationLink_.push_back (r);
        continue;
      }

      // relatedContacts
      //
      if (n.name () == "relatedContacts" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< relatedContacts_type > r (
          relatedContacts_traits::create (i, f, this));

        this->relatedContacts_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "contactId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< contactId_type > r (
          contactId_traits::create (i, f, this));

        this->contactId_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  contactDetailsType* contactDetailsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class contactDetailsType (*this, f, c);
  }

  contactDetailsType::
  ~contactDetailsType ()
  {
  }

  // organisationDetailsType
  //

  organisationDetailsType::
  organisationDetailsType ()
  : ::xml_schema::type (),
    organisationName_ (::xml_schema::flags (), this),
    organisationCode_ (::xml_schema::flags (), this),
    organisationDepartment_ (::xml_schema::flags (), this),
    details_ (::xml_schema::flags (), this),
    relatedInformationLink_ (::xml_schema::flags (), this),
    contacts_ (::xml_schema::flags (), this),
    organisationId_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  organisationDetailsType::
  organisationDetailsType (const organisationDetailsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    organisationName_ (x.organisationName_, f, this),
    organisationCode_ (x.organisationCode_, f, this),
    organisationDepartment_ (x.organisationDepartment_, f, this),
    details_ (x.details_, f, this),
    relatedInformationLink_ (x.relatedInformationLink_, f, this),
    contacts_ (x.contacts_, f, this),
    organisationId_ (x.organisationId_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  organisationDetailsType::
  organisationDetailsType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    organisationName_ (f, this),
    organisationCode_ (f, this),
    organisationDepartment_ (f, this),
    details_ (f, this),
    relatedInformationLink_ (f, this),
    contacts_ (f, this),
    organisationId_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void organisationDetailsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // organisationName
      //
      if (n.name () == "organisationName" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< organisationName_type > r (
          organisationName_traits::create (i, f, this));

        this->organisationName_.push_back (r);
        continue;
      }

      // organisationCode
      //
      if (n.name () == "organisationCode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< organisationCode_type > r (
          organisationCode_traits::create (i, f, this));

        this->organisationCode_.push_back (r);
        continue;
      }

      // organisationDepartment
      //
      if (n.name () == "organisationDepartment" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< organisationDepartment_type > r (
          organisationDepartment_traits::create (i, f, this));

        if (!this->organisationDepartment_)
        {
          this->organisationDepartment_.set (r);
          continue;
        }
      }

      // details
      //
      if (n.name () == "details" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< details_type > r (
          details_traits::create (i, f, this));

        this->details_.push_back (r);
        continue;
      }

      // relatedInformationLink
      //
      if (n.name () == "relatedInformationLink" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< relatedInformationLink_type > r (
          relatedInformationLink_traits::create (i, f, this));

        this->relatedInformationLink_.push_back (r);
        continue;
      }

      // contacts
      //
      if (n.name () == "contacts" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< contacts_type > r (
          contacts_traits::create (i, f, this));

        this->contacts_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "organisationId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< organisationId_type > r (
          organisationId_traits::create (i, f, this));

        this->organisationId_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  organisationDetailsType* organisationDetailsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class organisationDetailsType (*this, f, c);
  }

  organisationDetailsType::
  ~organisationDetailsType ()
  {
  }

  // detailsType
  //

  detailsType::
  detailsType ()
  : ::xml_schema::type (),
    emailAddress_ (::xml_schema::flags (), this),
    webAddress_ (::xml_schema::flags (), this),
    address_ (::xml_schema::flags (), this),
    telephoneNumber_ (::xml_schema::flags (), this),
    mobileTelephoneNumber_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  detailsType::
  detailsType (const detailsType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    emailAddress_ (x.emailAddress_, f, this),
    webAddress_ (x.webAddress_, f, this),
    address_ (x.address_, f, this),
    telephoneNumber_ (x.telephoneNumber_, f, this),
    mobileTelephoneNumber_ (x.mobileTelephoneNumber_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  detailsType::
  detailsType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    emailAddress_ (f, this),
    webAddress_ (f, this),
    address_ (f, this),
    telephoneNumber_ (f, this),
    mobileTelephoneNumber_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void detailsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // emailAddress
      //
      if (n.name () == "emailAddress" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< emailAddress_type > r (
          emailAddress_traits::create (i, f, this));

        this->emailAddress_.push_back (r);
        continue;
      }

      // webAddress
      //
      if (n.name () == "webAddress" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< webAddress_type > r (
          webAddress_traits::create (i, f, this));

        if (!this->webAddress_)
        {
          this->webAddress_.set (r);
          continue;
        }
      }

      // address
      //
      if (n.name () == "address" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< address_type > r (
          address_traits::create (i, f, this));

        if (!this->address_)
        {
          this->address_.set (r);
          continue;
        }
      }

      // telephoneNumber
      //
      if (n.name () == "telephoneNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< telephoneNumber_type > r (
          telephoneNumber_traits::create (i, f, this));

        if (!this->telephoneNumber_)
        {
          this->telephoneNumber_.set (r);
          continue;
        }
      }

      // mobileTelephoneNumber
      //
      if (n.name () == "mobileTelephoneNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< mobileTelephoneNumber_type > r (
          mobileTelephoneNumber_traits::create (i, f, this));

        if (!this->mobileTelephoneNumber_)
        {
          this->mobileTelephoneNumber_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  detailsType* detailsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class detailsType (*this, f, c);
  }

  detailsType::
  ~detailsType ()
  {
  }

  // addressType
  //

  addressType::
  addressType ()
  : ::xml_schema::type (),
    addressLine_ (::xml_schema::flags (), this),
    addressTownCity_ (::xml_schema::flags (), this),
    addressCountyState_ (::xml_schema::flags (), this),
    addressDeliveryCode_ (::xml_schema::flags (), this),
    country_ (::xml_schema::flags (), this)
  {
  }

  addressType::
  addressType (const addressType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    addressLine_ (x.addressLine_, f, this),
    addressTownCity_ (x.addressTownCity_, f, this),
    addressCountyState_ (x.addressCountyState_, f, this),
    addressDeliveryCode_ (x.addressDeliveryCode_, f, this),
    country_ (x.country_, f, this)
  {
  }

  addressType::
  addressType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    addressLine_ (f, this),
    addressTownCity_ (f, this),
    addressCountyState_ (f, this),
    addressDeliveryCode_ (f, this),
    country_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void addressType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // addressLine
      //
      if (n.name () == "addressLine" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< addressLine_type > r (
          addressLine_traits::create (i, f, this));

        this->addressLine_.push_back (r);
        continue;
      }

      // addressTownCity
      //
      if (n.name () == "addressTownCity" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< addressTownCity_type > r (
          addressTownCity_traits::create (i, f, this));

        if (!this->addressTownCity_)
        {
          this->addressTownCity_.set (r);
          continue;
        }
      }

      // addressCountyState
      //
      if (n.name () == "addressCountyState" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< addressCountyState_type > r (
          addressCountyState_traits::create (i, f, this));

        if (!this->addressCountyState_)
        {
          this->addressCountyState_.set (r);
          continue;
        }
      }

      // addressDeliveryCode
      //
      if (n.name () == "addressDeliveryCode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< addressDeliveryCode_type > r (
          addressDeliveryCode_traits::create (i, f, this));

        if (!this->addressDeliveryCode_)
        {
          this->addressDeliveryCode_.set (r);
          continue;
        }
      }

      // country
      //
      if (n.name () == "country" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< country_type > r (
          country_traits::create (i, f, this));

        if (!this->country_)
        {
          this->country_.set (r);
          continue;
        }
      }

      break;
    }
  }

  addressType* addressType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class addressType (*this, f, c);
  }

  addressType::
  ~addressType ()
  {
  }

  // compoundNameType
  //

  compoundNameType::
  compoundNameType ()
  : ::xml_schema::string (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  compoundNameType::
  compoundNameType (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  compoundNameType::
  compoundNameType (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  compoundNameType::
  compoundNameType (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  compoundNameType::
  compoundNameType (const compoundNameType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this)
  {
  }

  compoundNameType::
  compoundNameType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void compoundNameType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }
    }
  }

  compoundNameType* compoundNameType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class compoundNameType (*this, f, c);
  }

  compoundNameType::
  ~compoundNameType ()
  {
  }

  // regionType
  //

  regionType::
  regionType ()
  : ::xml_schema::type (),
    country_ (::xml_schema::flags (), this),
    countryRegion_ (::xml_schema::flags (), this)
  {
  }

  regionType::
  regionType (const regionType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    country_ (x.country_, f, this),
    countryRegion_ (x.countryRegion_, f, this)
  {
  }

  regionType::
  regionType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    country_ (f, this),
    countryRegion_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void regionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // country
      //
      if (n.name () == "country" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< country_type > r (
          country_traits::create (i, f, this));

        if (!this->country_)
        {
          this->country_.set (r);
          continue;
        }
      }

      // countryRegion
      //
      if (n.name () == "countryRegion" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< countryRegion_type > r (
          countryRegion_traits::create (i, f, this));

        this->countryRegion_.push_back (r);
        continue;
      }

      break;
    }
  }

  regionType* regionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class regionType (*this, f, c);
  }

  regionType::
  ~regionType ()
  {
  }

  // editUnitNumberType
  //

  editUnitNumberType::
  editUnitNumberType (const ::xml_schema::long_& _xsd_long__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (_xsd_long__base),
    editRate_ (::xml_schema::flags (), this),
    factorNumerator_ (factorNumerator_default_value (), ::xml_schema::flags (), this),
    factorDenominator_ (factorDenominator_default_value (), ::xml_schema::flags (), this)
  {
  }

  editUnitNumberType::
  editUnitNumberType (const editUnitNumberType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c),
    editRate_ (x.editRate_, f, this),
    factorNumerator_ (x.factorNumerator_, f, this),
    factorDenominator_ (x.factorDenominator_, f, this)
  {
  }

  editUnitNumberType::
  editUnitNumberType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    editRate_ (f, this),
    factorNumerator_ (f, this),
    factorDenominator_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void editUnitNumberType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "editRate" && n.namespace_ ().empty ())
      {
        this->editRate_.set (editRate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "factorNumerator" && n.namespace_ ().empty ())
      {
        this->factorNumerator_.set (factorNumerator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "factorDenominator" && n.namespace_ ().empty ())
      {
        this->factorDenominator_.set (factorDenominator_traits::create (i, f, this));
        continue;
      }
    }

    if (!factorNumerator_.present ())
    {
      this->factorNumerator_.set (factorNumerator_default_value ());
    }

    if (!factorDenominator_.present ())
    {
      this->factorDenominator_.set (factorDenominator_default_value ());
    }
  }

  editUnitNumberType* editUnitNumberType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class editUnitNumberType (*this, f, c);
  }

  editUnitNumberType::
  ~editUnitNumberType ()
  {
  }

  // ratingType
  //

  ratingType::
  ratingType ()
  : ::xml_schema::type (),
    ratingValue_ (::xml_schema::flags (), this),
    ratingScaleMaxValue_ (::xml_schema::flags (), this),
    ratingScaleMinValue_ (::xml_schema::flags (), this),
    ratingProvider_ (::xml_schema::flags (), this),
    ratingRegion_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this),
    reason_ (::xml_schema::flags (), this),
    linkToLogo_ (::xml_schema::flags (), this),
    notRated_ (::xml_schema::flags (), this),
    adultContent_ (::xml_schema::flags (), this)
  {
  }

  ratingType::
  ratingType (const ratingType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ratingValue_ (x.ratingValue_, f, this),
    ratingScaleMaxValue_ (x.ratingScaleMaxValue_, f, this),
    ratingScaleMinValue_ (x.ratingScaleMinValue_, f, this),
    ratingProvider_ (x.ratingProvider_, f, this),
    ratingRegion_ (x.ratingRegion_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this),
    reason_ (x.reason_, f, this),
    linkToLogo_ (x.linkToLogo_, f, this),
    notRated_ (x.notRated_, f, this),
    adultContent_ (x.adultContent_, f, this)
  {
  }

  ratingType::
  ratingType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ratingValue_ (f, this),
    ratingScaleMaxValue_ (f, this),
    ratingScaleMinValue_ (f, this),
    ratingProvider_ (f, this),
    ratingRegion_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this),
    reason_ (f, this),
    linkToLogo_ (f, this),
    notRated_ (f, this),
    adultContent_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ratingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ratingValue
      //
      if (n.name () == "ratingValue" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< ratingValue_type > r (
          ratingValue_traits::create (i, f, this));

        this->ratingValue_.push_back (r);
        continue;
      }

      // ratingScaleMaxValue
      //
      if (n.name () == "ratingScaleMaxValue" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< ratingScaleMaxValue_type > r (
          ratingScaleMaxValue_traits::create (i, f, this));

        this->ratingScaleMaxValue_.push_back (r);
        continue;
      }

      // ratingScaleMinValue
      //
      if (n.name () == "ratingScaleMinValue" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< ratingScaleMinValue_type > r (
          ratingScaleMinValue_traits::create (i, f, this));

        this->ratingScaleMinValue_.push_back (r);
        continue;
      }

      // ratingProvider
      //
      if (n.name () == "ratingProvider" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< ratingProvider_type > r (
          ratingProvider_traits::create (i, f, this));

        if (!this->ratingProvider_)
        {
          this->ratingProvider_.set (r);
          continue;
        }
      }

      // ratingRegion
      //
      if (n.name () == "ratingRegion" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< ratingRegion_type > r (
          ratingRegion_traits::create (i, f, this));

        this->ratingRegion_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }

      if (n.name () == "reason" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< reason_type > r (
          reason_traits::create (i, f, this));

        this->reason_.set (r);
        continue;
      }

      if (n.name () == "linkToLogo" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< linkToLogo_type > r (
          linkToLogo_traits::create (i, f, this));

        this->linkToLogo_.set (r);
        continue;
      }

      if (n.name () == "notRated" && n.namespace_ ().empty ())
      {
        this->notRated_.set (notRated_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "adultContent" && n.namespace_ ().empty ())
      {
        this->adultContent_.set (adultContent_traits::create (i, f, this));
        continue;
      }
    }
  }

  ratingType* ratingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ratingType (*this, f, c);
  }

  ratingType::
  ~ratingType ()
  {
  }

  // lengthType
  //

  lengthType::
  lengthType (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base),
    unit_ (::xml_schema::flags (), this)
  {
  }

  lengthType::
  lengthType (const lengthType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c),
    unit_ (x.unit_, f, this)
  {
  }

  lengthType::
  lengthType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    unit_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void lengthType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }
    }
  }

  lengthType* lengthType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class lengthType (*this, f, c);
  }

  lengthType::
  ~lengthType ()
  {
  }

  // dimensionType
  //

  dimensionType::
  dimensionType (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base),
    unit_ (::xml_schema::flags (), this)
  {
  }

  dimensionType::
  dimensionType (const dimensionType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c),
    unit_ (x.unit_, f, this)
  {
  }

  dimensionType::
  dimensionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    unit_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void dimensionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }
    }
  }

  dimensionType* dimensionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dimensionType (*this, f, c);
  }

  dimensionType::
  ~dimensionType ()
  {
  }

  // imageFormatType
  //

  imageFormatType::
  imageFormatType ()
  : ::xml_schema::type (),
    regionDelimX_ (::xml_schema::flags (), this),
    regionDelimY_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    height_ (::xml_schema::flags (), this),
    orientation_ (::xml_schema::flags (), this),
    aspectRatio_ (::xml_schema::flags (), this),
    imageEncoding_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    comment_ (::xml_schema::flags (), this),
    imageFormatId_ (::xml_schema::flags (), this),
    imageFormatVersionId_ (::xml_schema::flags (), this),
    imageFormatName_ (::xml_schema::flags (), this),
    imageFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  imageFormatType::
  imageFormatType (const imageFormatType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    regionDelimX_ (x.regionDelimX_, f, this),
    regionDelimY_ (x.regionDelimY_, f, this),
    width_ (x.width_, f, this),
    height_ (x.height_, f, this),
    orientation_ (x.orientation_, f, this),
    aspectRatio_ (x.aspectRatio_, f, this),
    imageEncoding_ (x.imageEncoding_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    comment_ (x.comment_, f, this),
    imageFormatId_ (x.imageFormatId_, f, this),
    imageFormatVersionId_ (x.imageFormatVersionId_, f, this),
    imageFormatName_ (x.imageFormatName_, f, this),
    imageFormatDefinition_ (x.imageFormatDefinition_, f, this)
  {
  }

  imageFormatType::
  imageFormatType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    regionDelimX_ (f, this),
    regionDelimY_ (f, this),
    width_ (f, this),
    height_ (f, this),
    orientation_ (f, this),
    aspectRatio_ (f, this),
    imageEncoding_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    comment_ (f, this),
    imageFormatId_ (f, this),
    imageFormatVersionId_ (f, this),
    imageFormatName_ (f, this),
    imageFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void imageFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // regionDelimX
      //
      if (n.name () == "regionDelimX" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->regionDelimX_)
        {
          this->regionDelimX_.set (regionDelimX_traits::create (i, f, this));
          continue;
        }
      }

      // regionDelimY
      //
      if (n.name () == "regionDelimY" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->regionDelimY_)
        {
          this->regionDelimY_.set (regionDelimY_traits::create (i, f, this));
          continue;
        }
      }

      // width
      //
      if (n.name () == "width" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< width_type > r (
          width_traits::create (i, f, this));

        if (!this->width_)
        {
          this->width_.set (r);
          continue;
        }
      }

      // height
      //
      if (n.name () == "height" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< height_type > r (
          height_traits::create (i, f, this));

        if (!this->height_)
        {
          this->height_.set (r);
          continue;
        }
      }

      // orientation
      //
      if (n.name () == "orientation" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< orientation_type > r (
          orientation_traits::create (i, f, this));

        if (!this->orientation_)
        {
          this->orientation_.set (r);
          continue;
        }
      }

      // aspectRatio
      //
      if (n.name () == "aspectRatio" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< aspectRatio_type > r (
          aspectRatio_traits::create (i, f, this));

        if (!this->aspectRatio_)
        {
          this->aspectRatio_.set (r);
          continue;
        }
      }

      // imageEncoding
      //
      if (n.name () == "imageEncoding" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< imageEncoding_type > r (
          imageEncoding_traits::create (i, f, this));

        if (!this->imageEncoding_)
        {
          this->imageEncoding_.set (r);
          continue;
        }
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        this->comment_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "imageFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< imageFormatId_type > r (
          imageFormatId_traits::create (i, f, this));

        this->imageFormatId_.set (r);
        continue;
      }

      if (n.name () == "imageFormatVersionId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< imageFormatVersionId_type > r (
          imageFormatVersionId_traits::create (i, f, this));

        this->imageFormatVersionId_.set (r);
        continue;
      }

      if (n.name () == "imageFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< imageFormatName_type > r (
          imageFormatName_traits::create (i, f, this));

        this->imageFormatName_.set (r);
        continue;
      }

      if (n.name () == "imageFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< imageFormatDefinition_type > r (
          imageFormatDefinition_traits::create (i, f, this));

        this->imageFormatDefinition_.set (r);
        continue;
      }
    }
  }

  imageFormatType* imageFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class imageFormatType (*this, f, c);
  }

  imageFormatType::
  ~imageFormatType ()
  {
  }

  // videoFormatType
  //

  videoFormatType::
  videoFormatType ()
  : ::xml_schema::type (),
    regionDelimX_ (::xml_schema::flags (), this),
    regionDelimY_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    height_ (::xml_schema::flags (), this),
    lines_ (::xml_schema::flags (), this),
    frameRate_ (::xml_schema::flags (), this),
    aspectRatio_ (::xml_schema::flags (), this),
    videoEncoding_ (::xml_schema::flags (), this),
    codec_ (::xml_schema::flags (), this),
    bitRate_ (::xml_schema::flags (), this),
    bitRateMax_ (::xml_schema::flags (), this),
    bitRateMode_ (::xml_schema::flags (), this),
    scanningFormat_ (::xml_schema::flags (), this),
    scanningOrder_ (::xml_schema::flags (), this),
    noiseFilter_ (::xml_schema::flags (), this),
    videoTrack_ (::xml_schema::flags (), this),
    flag_3D_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    comment_ (::xml_schema::flags (), this),
    videoFormatId_ (::xml_schema::flags (), this),
    videoFormatVersionId_ (::xml_schema::flags (), this),
    videoFormatName_ (::xml_schema::flags (), this),
    videoFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  videoFormatType::
  videoFormatType (const videoFormatType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    regionDelimX_ (x.regionDelimX_, f, this),
    regionDelimY_ (x.regionDelimY_, f, this),
    width_ (x.width_, f, this),
    height_ (x.height_, f, this),
    lines_ (x.lines_, f, this),
    frameRate_ (x.frameRate_, f, this),
    aspectRatio_ (x.aspectRatio_, f, this),
    videoEncoding_ (x.videoEncoding_, f, this),
    codec_ (x.codec_, f, this),
    bitRate_ (x.bitRate_, f, this),
    bitRateMax_ (x.bitRateMax_, f, this),
    bitRateMode_ (x.bitRateMode_, f, this),
    scanningFormat_ (x.scanningFormat_, f, this),
    scanningOrder_ (x.scanningOrder_, f, this),
    noiseFilter_ (x.noiseFilter_, f, this),
    videoTrack_ (x.videoTrack_, f, this),
    flag_3D_ (x.flag_3D_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    comment_ (x.comment_, f, this),
    videoFormatId_ (x.videoFormatId_, f, this),
    videoFormatVersionId_ (x.videoFormatVersionId_, f, this),
    videoFormatName_ (x.videoFormatName_, f, this),
    videoFormatDefinition_ (x.videoFormatDefinition_, f, this)
  {
  }

  videoFormatType::
  videoFormatType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    regionDelimX_ (f, this),
    regionDelimY_ (f, this),
    width_ (f, this),
    height_ (f, this),
    lines_ (f, this),
    frameRate_ (f, this),
    aspectRatio_ (f, this),
    videoEncoding_ (f, this),
    codec_ (f, this),
    bitRate_ (f, this),
    bitRateMax_ (f, this),
    bitRateMode_ (f, this),
    scanningFormat_ (f, this),
    scanningOrder_ (f, this),
    noiseFilter_ (f, this),
    videoTrack_ (f, this),
    flag_3D_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    comment_ (f, this),
    videoFormatId_ (f, this),
    videoFormatVersionId_ (f, this),
    videoFormatName_ (f, this),
    videoFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void videoFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // regionDelimX
      //
      if (n.name () == "regionDelimX" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->regionDelimX_)
        {
          this->regionDelimX_.set (regionDelimX_traits::create (i, f, this));
          continue;
        }
      }

      // regionDelimY
      //
      if (n.name () == "regionDelimY" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->regionDelimY_)
        {
          this->regionDelimY_.set (regionDelimY_traits::create (i, f, this));
          continue;
        }
      }

      // width
      //
      if (n.name () == "width" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< width_type > r (
          width_traits::create (i, f, this));

        this->width_.push_back (r);
        continue;
      }

      // height
      //
      if (n.name () == "height" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< height_type > r (
          height_traits::create (i, f, this));

        this->height_.push_back (r);
        continue;
      }

      // lines
      //
      if (n.name () == "lines" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->lines_)
        {
          this->lines_.set (lines_traits::create (i, f, this));
          continue;
        }
      }

      // frameRate
      //
      if (n.name () == "frameRate" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< frameRate_type > r (
          frameRate_traits::create (i, f, this));

        if (!this->frameRate_)
        {
          this->frameRate_.set (r);
          continue;
        }
      }

      // aspectRatio
      //
      if (n.name () == "aspectRatio" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< aspectRatio_type > r (
          aspectRatio_traits::create (i, f, this));

        this->aspectRatio_.push_back (r);
        continue;
      }

      // videoEncoding
      //
      if (n.name () == "videoEncoding" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< videoEncoding_type > r (
          videoEncoding_traits::create (i, f, this));

        if (!this->videoEncoding_)
        {
          this->videoEncoding_.set (r);
          continue;
        }
      }

      // codec
      //
      if (n.name () == "codec" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< codec_type > r (
          codec_traits::create (i, f, this));

        if (!this->codec_)
        {
          this->codec_.set (r);
          continue;
        }
      }

      // bitRate
      //
      if (n.name () == "bitRate" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->bitRate_)
        {
          this->bitRate_.set (bitRate_traits::create (i, f, this));
          continue;
        }
      }

      // bitRateMax
      //
      if (n.name () == "bitRateMax" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->bitRateMax_)
        {
          this->bitRateMax_.set (bitRateMax_traits::create (i, f, this));
          continue;
        }
      }

      // bitRateMode
      //
      if (n.name () == "bitRateMode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< bitRateMode_type > r (
          bitRateMode_traits::create (i, f, this));

        if (!this->bitRateMode_)
        {
          this->bitRateMode_.set (r);
          continue;
        }
      }

      // scanningFormat
      //
      if (n.name () == "scanningFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< scanningFormat_type > r (
          scanningFormat_traits::create (i, f, this));

        if (!this->scanningFormat_)
        {
          this->scanningFormat_.set (r);
          continue;
        }
      }

      // scanningOrder
      //
      if (n.name () == "scanningOrder" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< scanningOrder_type > r (
          scanningOrder_traits::create (i, f, this));

        if (!this->scanningOrder_)
        {
          this->scanningOrder_.set (r);
          continue;
        }
      }

      // noiseFilter
      //
      if (n.name () == "noiseFilter" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->noiseFilter_)
        {
          this->noiseFilter_.set (noiseFilter_traits::create (i, f, this));
          continue;
        }
      }

      // videoTrack
      //
      if (n.name () == "videoTrack" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< videoTrack_type > r (
          videoTrack_traits::create (i, f, this));

        this->videoTrack_.push_back (r);
        continue;
      }

      // flag_3D
      //
      if (n.name () == "flag_3D" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->flag_3D_)
        {
          this->flag_3D_.set (flag_3D_traits::create (i, f, this));
          continue;
        }
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        this->comment_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "videoFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< videoFormatId_type > r (
          videoFormatId_traits::create (i, f, this));

        this->videoFormatId_.set (r);
        continue;
      }

      if (n.name () == "videoFormatVersionId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< videoFormatVersionId_type > r (
          videoFormatVersionId_traits::create (i, f, this));

        this->videoFormatVersionId_.set (r);
        continue;
      }

      if (n.name () == "videoFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< videoFormatName_type > r (
          videoFormatName_traits::create (i, f, this));

        this->videoFormatName_.set (r);
        continue;
      }

      if (n.name () == "videoFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< videoFormatDefinition_type > r (
          videoFormatDefinition_traits::create (i, f, this));

        this->videoFormatDefinition_.set (r);
        continue;
      }
    }
  }

  videoFormatType* videoFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class videoFormatType (*this, f, c);
  }

  videoFormatType::
  ~videoFormatType ()
  {
  }

  // audioFormatType
  //

  audioFormatType::
  audioFormatType ()
  : ::xml_schema::type (),
    audioEncoding_ (::xml_schema::flags (), this),
    codec_ (::xml_schema::flags (), this),
    audioTrackConfiguration_ (::xml_schema::flags (), this),
    samplingRate_ (::xml_schema::flags (), this),
    sampleSize_ (::xml_schema::flags (), this),
    sampleType_ (::xml_schema::flags (), this),
    bitRate_ (::xml_schema::flags (), this),
    bitRateMax_ (::xml_schema::flags (), this),
    bitRateMode_ (::xml_schema::flags (), this),
    audioTrack_ (::xml_schema::flags (), this),
    channels_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    comment_ (::xml_schema::flags (), this),
    audioFormatId_ (::xml_schema::flags (), this),
    audioFormatVersionId_ (::xml_schema::flags (), this),
    audioFormatName_ (::xml_schema::flags (), this),
    audioFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  audioFormatType::
  audioFormatType (const audioFormatType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    audioEncoding_ (x.audioEncoding_, f, this),
    codec_ (x.codec_, f, this),
    audioTrackConfiguration_ (x.audioTrackConfiguration_, f, this),
    samplingRate_ (x.samplingRate_, f, this),
    sampleSize_ (x.sampleSize_, f, this),
    sampleType_ (x.sampleType_, f, this),
    bitRate_ (x.bitRate_, f, this),
    bitRateMax_ (x.bitRateMax_, f, this),
    bitRateMode_ (x.bitRateMode_, f, this),
    audioTrack_ (x.audioTrack_, f, this),
    channels_ (x.channels_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    comment_ (x.comment_, f, this),
    audioFormatId_ (x.audioFormatId_, f, this),
    audioFormatVersionId_ (x.audioFormatVersionId_, f, this),
    audioFormatName_ (x.audioFormatName_, f, this),
    audioFormatDefinition_ (x.audioFormatDefinition_, f, this)
  {
  }

  audioFormatType::
  audioFormatType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    audioEncoding_ (f, this),
    codec_ (f, this),
    audioTrackConfiguration_ (f, this),
    samplingRate_ (f, this),
    sampleSize_ (f, this),
    sampleType_ (f, this),
    bitRate_ (f, this),
    bitRateMax_ (f, this),
    bitRateMode_ (f, this),
    audioTrack_ (f, this),
    channels_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    comment_ (f, this),
    audioFormatId_ (f, this),
    audioFormatVersionId_ (f, this),
    audioFormatName_ (f, this),
    audioFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void audioFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // audioEncoding
      //
      if (n.name () == "audioEncoding" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< audioEncoding_type > r (
          audioEncoding_traits::create (i, f, this));

        if (!this->audioEncoding_)
        {
          this->audioEncoding_.set (r);
          continue;
        }
      }

      // codec
      //
      if (n.name () == "codec" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< codec_type > r (
          codec_traits::create (i, f, this));

        if (!this->codec_)
        {
          this->codec_.set (r);
          continue;
        }
      }

      // audioTrackConfiguration
      //
      if (n.name () == "audioTrackConfiguration" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< audioTrackConfiguration_type > r (
          audioTrackConfiguration_traits::create (i, f, this));

        if (!this->audioTrackConfiguration_)
        {
          this->audioTrackConfiguration_.set (r);
          continue;
        }
      }

      // samplingRate
      //
      if (n.name () == "samplingRate" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->samplingRate_)
        {
          this->samplingRate_.set (samplingRate_traits::create (i, f, this));
          continue;
        }
      }

      // sampleSize
      //
      if (n.name () == "sampleSize" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->sampleSize_)
        {
          this->sampleSize_.set (sampleSize_traits::create (i, f, this));
          continue;
        }
      }

      // sampleType
      //
      if (n.name () == "sampleType" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< sampleType_type > r (
          sampleType_traits::create (i, f, this));

        if (!this->sampleType_)
        {
          this->sampleType_.set (r);
          continue;
        }
      }

      // bitRate
      //
      if (n.name () == "bitRate" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->bitRate_)
        {
          this->bitRate_.set (bitRate_traits::create (i, f, this));
          continue;
        }
      }

      // bitRateMax
      //
      if (n.name () == "bitRateMax" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->bitRateMax_)
        {
          this->bitRateMax_.set (bitRateMax_traits::create (i, f, this));
          continue;
        }
      }

      // bitRateMode
      //
      if (n.name () == "bitRateMode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< bitRateMode_type > r (
          bitRateMode_traits::create (i, f, this));

        if (!this->bitRateMode_)
        {
          this->bitRateMode_.set (r);
          continue;
        }
      }

      // audioTrack
      //
      if (n.name () == "audioTrack" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< audioTrack_type > r (
          audioTrack_traits::create (i, f, this));

        this->audioTrack_.push_back (r);
        continue;
      }

      // channels
      //
      if (n.name () == "channels" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->channels_)
        {
          this->channels_.set (channels_traits::create (i, f, this));
          continue;
        }
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        this->comment_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "audioFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< audioFormatId_type > r (
          audioFormatId_traits::create (i, f, this));

        this->audioFormatId_.set (r);
        continue;
      }

      if (n.name () == "audioFormatVersionId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< audioFormatVersionId_type > r (
          audioFormatVersionId_traits::create (i, f, this));

        this->audioFormatVersionId_.set (r);
        continue;
      }

      if (n.name () == "audioFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< audioFormatName_type > r (
          audioFormatName_traits::create (i, f, this));

        this->audioFormatName_.set (r);
        continue;
      }

      if (n.name () == "audioFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< audioFormatDefinition_type > r (
          audioFormatDefinition_traits::create (i, f, this));

        this->audioFormatDefinition_.set (r);
        continue;
      }
    }
  }

  audioFormatType* audioFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class audioFormatType (*this, f, c);
  }

  audioFormatType::
  ~audioFormatType ()
  {
  }

  // dataFormatType
  //

  dataFormatType::
  dataFormatType ()
  : ::xml_schema::type (),
    captioningFormat_ (::xml_schema::flags (), this),
    subtitlingFormat_ (::xml_schema::flags (), this),
    ancillaryDataFormat_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    comment_ (::xml_schema::flags (), this),
    dataFormatId_ (::xml_schema::flags (), this),
    dataFormatVersionId_ (::xml_schema::flags (), this),
    dataFormatName_ (::xml_schema::flags (), this),
    dataFormatDefinition_ (::xml_schema::flags (), this),
    dataTrackId_ (::xml_schema::flags (), this),
    dataTrackName_ (::xml_schema::flags (), this),
    dataTrackLanguage_ (::xml_schema::flags (), this)
  {
  }

  dataFormatType::
  dataFormatType (const dataFormatType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    captioningFormat_ (x.captioningFormat_, f, this),
    subtitlingFormat_ (x.subtitlingFormat_, f, this),
    ancillaryDataFormat_ (x.ancillaryDataFormat_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    comment_ (x.comment_, f, this),
    dataFormatId_ (x.dataFormatId_, f, this),
    dataFormatVersionId_ (x.dataFormatVersionId_, f, this),
    dataFormatName_ (x.dataFormatName_, f, this),
    dataFormatDefinition_ (x.dataFormatDefinition_, f, this),
    dataTrackId_ (x.dataTrackId_, f, this),
    dataTrackName_ (x.dataTrackName_, f, this),
    dataTrackLanguage_ (x.dataTrackLanguage_, f, this)
  {
  }

  dataFormatType::
  dataFormatType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    captioningFormat_ (f, this),
    subtitlingFormat_ (f, this),
    ancillaryDataFormat_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    comment_ (f, this),
    dataFormatId_ (f, this),
    dataFormatVersionId_ (f, this),
    dataFormatName_ (f, this),
    dataFormatDefinition_ (f, this),
    dataTrackId_ (f, this),
    dataTrackName_ (f, this),
    dataTrackLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void dataFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // captioningFormat
      //
      if (n.name () == "captioningFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< captioningFormat_type > r (
          captioningFormat_traits::create (i, f, this));

        this->captioningFormat_.push_back (r);
        continue;
      }

      // subtitlingFormat
      //
      if (n.name () == "subtitlingFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< subtitlingFormat_type > r (
          subtitlingFormat_traits::create (i, f, this));

        this->subtitlingFormat_.push_back (r);
        continue;
      }

      // ancillaryDataFormat
      //
      if (n.name () == "ancillaryDataFormat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< ancillaryDataFormat_type > r (
          ancillaryDataFormat_traits::create (i, f, this));

        this->ancillaryDataFormat_.push_back (r);
        continue;
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        this->comment_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dataFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataFormatId_type > r (
          dataFormatId_traits::create (i, f, this));

        this->dataFormatId_.set (r);
        continue;
      }

      if (n.name () == "dataFormatVersionId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataFormatVersionId_type > r (
          dataFormatVersionId_traits::create (i, f, this));

        this->dataFormatVersionId_.set (r);
        continue;
      }

      if (n.name () == "dataFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataFormatName_type > r (
          dataFormatName_traits::create (i, f, this));

        this->dataFormatName_.set (r);
        continue;
      }

      if (n.name () == "dataFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataFormatDefinition_type > r (
          dataFormatDefinition_traits::create (i, f, this));

        this->dataFormatDefinition_.set (r);
        continue;
      }

      if (n.name () == "dataTrackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataTrackId_type > r (
          dataTrackId_traits::create (i, f, this));

        this->dataTrackId_.set (r);
        continue;
      }

      if (n.name () == "dataTrackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataTrackName_type > r (
          dataTrackName_traits::create (i, f, this));

        this->dataTrackName_.set (r);
        continue;
      }

      if (n.name () == "dataTrackLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataTrackLanguage_type > r (
          dataTrackLanguage_traits::create (i, f, this));

        this->dataTrackLanguage_.set (r);
        continue;
      }
    }
  }

  dataFormatType* dataFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dataFormatType (*this, f, c);
  }

  dataFormatType::
  ~dataFormatType ()
  {
  }

  // documentFormatType
  //

  documentFormatType::
  documentFormatType ()
  : ::xml_schema::type (),
    wordCount_ (::xml_schema::flags (), this),
    regionDelimX_ (::xml_schema::flags (), this),
    regionDelimY_ (::xml_schema::flags (), this),
    width_ (::xml_schema::flags (), this),
    height_ (::xml_schema::flags (), this),
    technicalAttributeString_ (::xml_schema::flags (), this),
    technicalAttributeByte_ (::xml_schema::flags (), this),
    technicalAttributeShort_ (::xml_schema::flags (), this),
    technicalAttributeInteger_ (::xml_schema::flags (), this),
    technicalAttributeLong_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedByte_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedShort_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedInteger_ (::xml_schema::flags (), this),
    technicalAttributeUnsignedLong_ (::xml_schema::flags (), this),
    technicalAttributeBoolean_ (::xml_schema::flags (), this),
    technicalAttributeFloat_ (::xml_schema::flags (), this),
    technicalAttributeRational_ (::xml_schema::flags (), this),
    technicalAttributeUri_ (::xml_schema::flags (), this),
    comment_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    documentFormatId_ (::xml_schema::flags (), this),
    documentFormatVersionId_ (::xml_schema::flags (), this),
    documentFormatName_ (::xml_schema::flags (), this),
    documentFormatDefinition_ (::xml_schema::flags (), this)
  {
  }

  documentFormatType::
  documentFormatType (const documentFormatType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    wordCount_ (x.wordCount_, f, this),
    regionDelimX_ (x.regionDelimX_, f, this),
    regionDelimY_ (x.regionDelimY_, f, this),
    width_ (x.width_, f, this),
    height_ (x.height_, f, this),
    technicalAttributeString_ (x.technicalAttributeString_, f, this),
    technicalAttributeByte_ (x.technicalAttributeByte_, f, this),
    technicalAttributeShort_ (x.technicalAttributeShort_, f, this),
    technicalAttributeInteger_ (x.technicalAttributeInteger_, f, this),
    technicalAttributeLong_ (x.technicalAttributeLong_, f, this),
    technicalAttributeUnsignedByte_ (x.technicalAttributeUnsignedByte_, f, this),
    technicalAttributeUnsignedShort_ (x.technicalAttributeUnsignedShort_, f, this),
    technicalAttributeUnsignedInteger_ (x.technicalAttributeUnsignedInteger_, f, this),
    technicalAttributeUnsignedLong_ (x.technicalAttributeUnsignedLong_, f, this),
    technicalAttributeBoolean_ (x.technicalAttributeBoolean_, f, this),
    technicalAttributeFloat_ (x.technicalAttributeFloat_, f, this),
    technicalAttributeRational_ (x.technicalAttributeRational_, f, this),
    technicalAttributeUri_ (x.technicalAttributeUri_, f, this),
    comment_ (x.comment_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    documentFormatId_ (x.documentFormatId_, f, this),
    documentFormatVersionId_ (x.documentFormatVersionId_, f, this),
    documentFormatName_ (x.documentFormatName_, f, this),
    documentFormatDefinition_ (x.documentFormatDefinition_, f, this)
  {
  }

  documentFormatType::
  documentFormatType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    wordCount_ (f, this),
    regionDelimX_ (f, this),
    regionDelimY_ (f, this),
    width_ (f, this),
    height_ (f, this),
    technicalAttributeString_ (f, this),
    technicalAttributeByte_ (f, this),
    technicalAttributeShort_ (f, this),
    technicalAttributeInteger_ (f, this),
    technicalAttributeLong_ (f, this),
    technicalAttributeUnsignedByte_ (f, this),
    technicalAttributeUnsignedShort_ (f, this),
    technicalAttributeUnsignedInteger_ (f, this),
    technicalAttributeUnsignedLong_ (f, this),
    technicalAttributeBoolean_ (f, this),
    technicalAttributeFloat_ (f, this),
    technicalAttributeRational_ (f, this),
    technicalAttributeUri_ (f, this),
    comment_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    documentFormatId_ (f, this),
    documentFormatVersionId_ (f, this),
    documentFormatName_ (f, this),
    documentFormatDefinition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void documentFormatType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // wordCount
      //
      if (n.name () == "wordCount" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->wordCount_)
        {
          this->wordCount_.set (wordCount_traits::create (i, f, this));
          continue;
        }
      }

      // regionDelimX
      //
      if (n.name () == "regionDelimX" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->regionDelimX_)
        {
          this->regionDelimX_.set (regionDelimX_traits::create (i, f, this));
          continue;
        }
      }

      // regionDelimY
      //
      if (n.name () == "regionDelimY" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->regionDelimY_)
        {
          this->regionDelimY_.set (regionDelimY_traits::create (i, f, this));
          continue;
        }
      }

      // width
      //
      if (n.name () == "width" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< width_type > r (
          width_traits::create (i, f, this));

        if (!this->width_)
        {
          this->width_.set (r);
          continue;
        }
      }

      // height
      //
      if (n.name () == "height" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< height_type > r (
          height_traits::create (i, f, this));

        if (!this->height_)
        {
          this->height_.set (r);
          continue;
        }
      }

      // technicalAttributeString
      //
      if (n.name () == "technicalAttributeString" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeString_type > r (
          technicalAttributeString_traits::create (i, f, this));

        this->technicalAttributeString_.push_back (r);
        continue;
      }

      // technicalAttributeByte
      //
      if (n.name () == "technicalAttributeByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeByte_type > r (
          technicalAttributeByte_traits::create (i, f, this));

        this->technicalAttributeByte_.push_back (r);
        continue;
      }

      // technicalAttributeShort
      //
      if (n.name () == "technicalAttributeShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeShort_type > r (
          technicalAttributeShort_traits::create (i, f, this));

        this->technicalAttributeShort_.push_back (r);
        continue;
      }

      // technicalAttributeInteger
      //
      if (n.name () == "technicalAttributeInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeInteger_type > r (
          technicalAttributeInteger_traits::create (i, f, this));

        this->technicalAttributeInteger_.push_back (r);
        continue;
      }

      // technicalAttributeLong
      //
      if (n.name () == "technicalAttributeLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeLong_type > r (
          technicalAttributeLong_traits::create (i, f, this));

        this->technicalAttributeLong_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedByte
      //
      if (n.name () == "technicalAttributeUnsignedByte" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedByte_type > r (
          technicalAttributeUnsignedByte_traits::create (i, f, this));

        this->technicalAttributeUnsignedByte_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedShort
      //
      if (n.name () == "technicalAttributeUnsignedShort" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedShort_type > r (
          technicalAttributeUnsignedShort_traits::create (i, f, this));

        this->technicalAttributeUnsignedShort_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedInteger
      //
      if (n.name () == "technicalAttributeUnsignedInteger" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedInteger_type > r (
          technicalAttributeUnsignedInteger_traits::create (i, f, this));

        this->technicalAttributeUnsignedInteger_.push_back (r);
        continue;
      }

      // technicalAttributeUnsignedLong
      //
      if (n.name () == "technicalAttributeUnsignedLong" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUnsignedLong_type > r (
          technicalAttributeUnsignedLong_traits::create (i, f, this));

        this->technicalAttributeUnsignedLong_.push_back (r);
        continue;
      }

      // technicalAttributeBoolean
      //
      if (n.name () == "technicalAttributeBoolean" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeBoolean_type > r (
          technicalAttributeBoolean_traits::create (i, f, this));

        this->technicalAttributeBoolean_.push_back (r);
        continue;
      }

      // technicalAttributeFloat
      //
      if (n.name () == "technicalAttributeFloat" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeFloat_type > r (
          technicalAttributeFloat_traits::create (i, f, this));

        this->technicalAttributeFloat_.push_back (r);
        continue;
      }

      // technicalAttributeRational
      //
      if (n.name () == "technicalAttributeRational" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeRational_type > r (
          technicalAttributeRational_traits::create (i, f, this));

        this->technicalAttributeRational_.push_back (r);
        continue;
      }

      // technicalAttributeUri
      //
      if (n.name () == "technicalAttributeUri" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< technicalAttributeUri_type > r (
          technicalAttributeUri_traits::create (i, f, this));

        this->technicalAttributeUri_.push_back (r);
        continue;
      }

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        this->comment_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "documentFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentFormatId_type > r (
          documentFormatId_traits::create (i, f, this));

        this->documentFormatId_.set (r);
        continue;
      }

      if (n.name () == "documentFormatVersionId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentFormatVersionId_type > r (
          documentFormatVersionId_traits::create (i, f, this));

        this->documentFormatVersionId_.set (r);
        continue;
      }

      if (n.name () == "documentFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentFormatName_type > r (
          documentFormatName_traits::create (i, f, this));

        this->documentFormatName_.set (r);
        continue;
      }

      if (n.name () == "documentFormatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< documentFormatDefinition_type > r (
          documentFormatDefinition_traits::create (i, f, this));

        this->documentFormatDefinition_.set (r);
        continue;
      }
    }
  }

  documentFormatType* documentFormatType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class documentFormatType (*this, f, c);
  }

  documentFormatType::
  ~documentFormatType ()
  {
  }

  // codecType
  //

  codecType::
  codecType ()
  : ::xml_schema::type (),
    codecIdentifier_ (::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this),
    vendor_ (::xml_schema::flags (), this),
    version_ (::xml_schema::flags (), this),
    family_ (::xml_schema::flags (), this)
  {
  }

  codecType::
  codecType (const codecType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    codecIdentifier_ (x.codecIdentifier_, f, this),
    name_ (x.name_, f, this),
    vendor_ (x.vendor_, f, this),
    version_ (x.version_, f, this),
    family_ (x.family_, f, this)
  {
  }

  codecType::
  codecType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    codecIdentifier_ (f, this),
    name_ (f, this),
    vendor_ (f, this),
    version_ (f, this),
    family_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void codecType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // codecIdentifier
      //
      if (n.name () == "codecIdentifier" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< codecIdentifier_type > r (
          codecIdentifier_traits::create (i, f, this));

        if (!this->codecIdentifier_)
        {
          this->codecIdentifier_.set (r);
          continue;
        }
      }

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (r);
          continue;
        }
      }

      // vendor
      //
      if (n.name () == "vendor" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< vendor_type > r (
          vendor_traits::create (i, f, this));

        if (!this->vendor_)
        {
          this->vendor_.set (r);
          continue;
        }
      }

      // version
      //
      if (n.name () == "version" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        if (!this->version_)
        {
          this->version_.set (r);
          continue;
        }
      }

      // family
      //
      if (n.name () == "family" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< family_type > r (
          family_traits::create (i, f, this));

        if (!this->family_)
        {
          this->family_.set (r);
          continue;
        }
      }

      break;
    }
  }

  codecType* codecType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class codecType (*this, f, c);
  }

  codecType::
  ~codecType ()
  {
  }

  // timeType
  //

  timeType::
  timeType ()
  : ::xml_schema::type (),
    timecode_ (::xml_schema::flags (), this),
    normalPlayTime_ (::xml_schema::flags (), this),
    editUnitNumber_ (::xml_schema::flags (), this),
    time_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  timeType::
  timeType (const timeType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    timecode_ (x.timecode_, f, this),
    normalPlayTime_ (x.normalPlayTime_, f, this),
    editUnitNumber_ (x.editUnitNumber_, f, this),
    time_ (x.time_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  timeType::
  timeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    timecode_ (f, this),
    normalPlayTime_ (f, this),
    editUnitNumber_ (f, this),
    time_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void timeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timecode
      //
      if (n.name () == "timecode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< timecode_type > r (
          timecode_traits::create (i, f, this));

        if (!this->timecode_)
        {
          this->timecode_.set (r);
          continue;
        }
      }

      // normalPlayTime
      //
      if (n.name () == "normalPlayTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< normalPlayTime_type > r (
          normalPlayTime_traits::create (i, f, this));

        if (!this->normalPlayTime_)
        {
          this->normalPlayTime_.set (r);
          continue;
        }
      }

      // editUnitNumber
      //
      if (n.name () == "editUnitNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< editUnitNumber_type > r (
          editUnitNumber_traits::create (i, f, this));

        if (!this->editUnitNumber_)
        {
          this->editUnitNumber_.set (r);
          continue;
        }
      }

      // time
      //
      if (n.name () == "time" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< time_type > r (
          time_traits::create (i, f, this));

        if (!this->time_)
        {
          this->time_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  timeType* timeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class timeType (*this, f, c);
  }

  timeType::
  ~timeType ()
  {
  }

  // durationType
  //

  durationType::
  durationType ()
  : ::xml_schema::type (),
    timecode_ (::xml_schema::flags (), this),
    normalPlayTime_ (::xml_schema::flags (), this),
    editUnitNumber_ (::xml_schema::flags (), this),
    duration_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  durationType::
  durationType (const durationType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    timecode_ (x.timecode_, f, this),
    normalPlayTime_ (x.normalPlayTime_, f, this),
    editUnitNumber_ (x.editUnitNumber_, f, this),
    duration_ (x.duration_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  durationType::
  durationType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    timecode_ (f, this),
    normalPlayTime_ (f, this),
    editUnitNumber_ (f, this),
    duration_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void durationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timecode
      //
      if (n.name () == "timecode" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< timecode_type > r (
          timecode_traits::create (i, f, this));

        if (!this->timecode_)
        {
          this->timecode_.set (r);
          continue;
        }
      }

      // normalPlayTime
      //
      if (n.name () == "normalPlayTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< normalPlayTime_type > r (
          normalPlayTime_traits::create (i, f, this));

        if (!this->normalPlayTime_)
        {
          this->normalPlayTime_.set (r);
          continue;
        }
      }

      // editUnitNumber
      //
      if (n.name () == "editUnitNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< editUnitNumber_type > r (
          editUnitNumber_traits::create (i, f, this));

        if (!this->editUnitNumber_)
        {
          this->editUnitNumber_.set (r);
          continue;
        }
      }

      // duration
      //
      if (n.name () == "duration" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        if (!this->duration_)
        {
          this->duration_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  durationType* durationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class durationType (*this, f, c);
  }

  durationType::
  ~durationType ()
  {
  }

  // hashType
  //

  hashType::
  hashType (const hashValue_type& hashValue,
            const hashFunction_type& hashFunction)
  : ::xml_schema::type (),
    hashValue_ (hashValue, ::xml_schema::flags (), this),
    hashFunction_ (hashFunction, ::xml_schema::flags (), this)
  {
  }

  hashType::
  hashType (const hashValue_type& hashValue,
            ::std::auto_ptr< hashFunction_type >& hashFunction)
  : ::xml_schema::type (),
    hashValue_ (hashValue, ::xml_schema::flags (), this),
    hashFunction_ (hashFunction, ::xml_schema::flags (), this)
  {
  }

  hashType::
  hashType (const hashType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    hashValue_ (x.hashValue_, f, this),
    hashFunction_ (x.hashFunction_, f, this)
  {
  }

  hashType::
  hashType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    hashValue_ (f, this),
    hashFunction_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void hashType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // hashValue
      //
      if (n.name () == "hashValue" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< hashValue_type > r (
          hashValue_traits::create (i, f, this));

        if (!hashValue_.present ())
        {
          this->hashValue_.set (r);
          continue;
        }
      }

      // hashFunction
      //
      if (n.name () == "hashFunction" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< hashFunction_type > r (
          hashFunction_traits::create (i, f, this));

        if (!hashFunction_.present ())
        {
          this->hashFunction_.set (r);
          continue;
        }
      }

      break;
    }

    if (!hashValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "hashValue",
        "urn:ebu:metadata-schema:ebuCore_2012");
    }

    if (!hashFunction_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "hashFunction",
        "urn:ebu:metadata-schema:ebuCore_2012");
    }
  }

  hashType* hashType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hashType (*this, f, c);
  }

  hashType::
  ~hashType ()
  {
  }

  // String
  //

  String::
  String ()
  : ::xml_schema::string (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  String::
  String (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  String::
  String (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  String::
  String (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  String::
  String (const String& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this)
  {
  }

  String::
  String (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void String::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }
    }
  }

  String* String::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class String (*this, f, c);
  }

  String::
  ~String ()
  {
  }

  // Boolean
  //

  Boolean::
  Boolean (const ::xml_schema::boolean& _xsd_boolean_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (_xsd_boolean_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  Boolean::
  Boolean (const Boolean& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  Boolean::
  Boolean (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Boolean::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  Boolean* Boolean::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Boolean (*this, f, c);
  }

  Boolean::
  ~Boolean ()
  {
  }

  // Float
  //

  Float::
  Float (const ::xml_schema::double_& _xsd_double__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  Float::
  Float (const Float& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  Float::
  Float (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Float::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  Float* Float::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Float (*this, f, c);
  }

  Float::
  ~Float ()
  {
  }

  // Int8
  //

  Int8::
  Int8 (const ::xml_schema::byte& _xsd_byte_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type > (_xsd_byte_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  Int8::
  Int8 (const Int8& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  Int8::
  Int8 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Int8::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  Int8* Int8::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int8 (*this, f, c);
  }

  Int8::
  ~Int8 ()
  {
  }

  // Int16
  //

  Int16::
  Int16 (const ::xml_schema::short_& _xsd_short__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type > (_xsd_short__base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  Int16::
  Int16 (const Int16& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  Int16::
  Int16 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Int16::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  Int16* Int16::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int16 (*this, f, c);
  }

  Int16::
  ~Int16 ()
  {
  }

  // Int32
  //

  Int32::
  Int32 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  Int32::
  Int32 (const Int32& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  Int32::
  Int32 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Int32::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  Int32* Int32::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int32 (*this, f, c);
  }

  Int32::
  ~Int32 ()
  {
  }

  // Int64
  //

  Int64::
  Int64 (const ::xml_schema::long_& _xsd_long__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (_xsd_long__base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  Int64::
  Int64 (const Int64& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  Int64::
  Int64 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Int64::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  Int64* Int64::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Int64 (*this, f, c);
  }

  Int64::
  ~Int64 ()
  {
  }

  // UInt8
  //

  UInt8::
  UInt8 (const ::xml_schema::unsigned_byte& _xsd_unsigned_byte_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (_xsd_unsigned_byte_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  UInt8::
  UInt8 (const UInt8& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  UInt8::
  UInt8 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void UInt8::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  UInt8* UInt8::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UInt8 (*this, f, c);
  }

  UInt8::
  ~UInt8 ()
  {
  }

  // UInt16
  //

  UInt16::
  UInt16 (const ::xml_schema::unsigned_short& _xsd_unsigned_short_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (_xsd_unsigned_short_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  UInt16::
  UInt16 (const UInt16& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  UInt16::
  UInt16 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void UInt16::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  UInt16* UInt16::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UInt16 (*this, f, c);
  }

  UInt16::
  ~UInt16 ()
  {
  }

  // UInt32
  //

  UInt32::
  UInt32 (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  UInt32::
  UInt32 (const UInt32& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  UInt32::
  UInt32 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void UInt32::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  UInt32* UInt32::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UInt32 (*this, f, c);
  }

  UInt32::
  ~UInt32 ()
  {
  }

  // UInt64
  //

  UInt64::
  UInt64 (const ::xml_schema::unsigned_long& _xsd_unsigned_long_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type > (_xsd_unsigned_long_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  UInt64::
  UInt64 (const UInt64& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type > (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  UInt64::
  UInt64 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void UInt64::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  UInt64* UInt64::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UInt64 (*this, f, c);
  }

  UInt64::
  ~UInt64 ()
  {
  }

  // rationalType
  //

  rationalType::
  rationalType (const ::xml_schema::long_& _xsd_long__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (_xsd_long__base),
    factorNumerator_ (factorNumerator_default_value (), ::xml_schema::flags (), this),
    factorDenominator_ (factorDenominator_default_value (), ::xml_schema::flags (), this)
  {
  }

  rationalType::
  rationalType (const rationalType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (x, f, c),
    factorNumerator_ (x.factorNumerator_, f, this),
    factorDenominator_ (x.factorDenominator_, f, this)
  {
  }

  rationalType::
  rationalType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    factorNumerator_ (f, this),
    factorDenominator_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void rationalType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "factorNumerator" && n.namespace_ ().empty ())
      {
        this->factorNumerator_.set (factorNumerator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "factorDenominator" && n.namespace_ ().empty ())
      {
        this->factorDenominator_.set (factorDenominator_traits::create (i, f, this));
        continue;
      }
    }

    if (!factorNumerator_.present ())
    {
      this->factorNumerator_.set (factorNumerator_default_value ());
    }

    if (!factorDenominator_.present ())
    {
      this->factorDenominator_.set (factorDenominator_default_value ());
    }
  }

  rationalType* rationalType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class rationalType (*this, f, c);
  }

  rationalType::
  ~rationalType ()
  {
  }

  // aspectRatioType
  //

  aspectRatioType::
  aspectRatioType (const factorNumerator_type& factorNumerator,
                   const factorDenominator_type& factorDenominator)
  : ::xml_schema::type (),
    factorNumerator_ (factorNumerator, ::xml_schema::flags (), this),
    factorDenominator_ (factorDenominator, ::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  aspectRatioType::
  aspectRatioType (const aspectRatioType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    factorNumerator_ (x.factorNumerator_, f, this),
    factorDenominator_ (x.factorDenominator_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  aspectRatioType::
  aspectRatioType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    factorNumerator_ (f, this),
    factorDenominator_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void aspectRatioType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // factorNumerator
      //
      if (n.name () == "factorNumerator" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!factorNumerator_.present ())
        {
          this->factorNumerator_.set (factorNumerator_traits::create (i, f, this));
          continue;
        }
      }

      // factorDenominator
      //
      if (n.name () == "factorDenominator" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!factorDenominator_.present ())
        {
          this->factorDenominator_.set (factorDenominator_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!factorNumerator_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "factorNumerator",
        "urn:ebu:metadata-schema:ebuCore_2012");
    }

    if (!factorDenominator_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "factorDenominator",
        "urn:ebu:metadata-schema:ebuCore_2012");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  aspectRatioType* aspectRatioType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class aspectRatioType (*this, f, c);
  }

  aspectRatioType::
  ~aspectRatioType ()
  {
  }

  // technicalAttributeRationalType
  //

  technicalAttributeRationalType::
  technicalAttributeRationalType (const ::xml_schema::long_& _xsd_long__base)
  : ::ebuCore_2012::rationalType (_xsd_long__base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  technicalAttributeRationalType::
  technicalAttributeRationalType (const technicalAttributeRationalType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::ebuCore_2012::rationalType (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  technicalAttributeRationalType::
  technicalAttributeRationalType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::ebuCore_2012::rationalType (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void technicalAttributeRationalType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::ebuCore_2012::rationalType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  technicalAttributeRationalType* technicalAttributeRationalType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class technicalAttributeRationalType (*this, f, c);
  }

  technicalAttributeRationalType::
  ~technicalAttributeRationalType ()
  {
  }

  // technicalAttributeUriType
  //

  technicalAttributeUriType::
  technicalAttributeUriType (const ::xml_schema::uri& _xsd_uri_base)
  : ::xml_schema::uri (_xsd_uri_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  technicalAttributeUriType::
  technicalAttributeUriType (const technicalAttributeUriType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::uri (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  technicalAttributeUriType::
  technicalAttributeUriType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::uri (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void technicalAttributeUriType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  technicalAttributeUriType* technicalAttributeUriType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class technicalAttributeUriType (*this, f, c);
  }

  technicalAttributeUriType::
  ~technicalAttributeUriType ()
  {
  }

  // versionType
  //

  versionType::
  versionType ()
  : ::dc::elementType (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  versionType::
  versionType (const char* _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  versionType::
  versionType (const ::std::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  versionType::
  versionType (const ::xml_schema::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  versionType::
  versionType (const versionType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::dc::elementType (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  versionType::
  versionType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::dc::elementType (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void versionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dc::elementType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  versionType* versionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class versionType (*this, f, c);
  }

  versionType::
  ~versionType ()
  {
  }

  // hasTrackPart
  //

  hasTrackPart::
  hasTrackPart (const trackPartTitle_type& trackPartTitle)
  : ::ebuCore_2012::relationType (),
    trackPartTitle_ (trackPartTitle, ::xml_schema::flags (), this),
    destinationId_ (::xml_schema::flags (), this),
    destinationStart_ (::xml_schema::flags (), this),
    destinationEnd_ (::xml_schema::flags (), this),
    sourceId_ (::xml_schema::flags (), this),
    sourceStart_ (::xml_schema::flags (), this),
    sourceEnd_ (::xml_schema::flags (), this)
  {
  }

  hasTrackPart::
  hasTrackPart (::std::auto_ptr< trackPartTitle_type >& trackPartTitle)
  : ::ebuCore_2012::relationType (),
    trackPartTitle_ (trackPartTitle, ::xml_schema::flags (), this),
    destinationId_ (::xml_schema::flags (), this),
    destinationStart_ (::xml_schema::flags (), this),
    destinationEnd_ (::xml_schema::flags (), this),
    sourceId_ (::xml_schema::flags (), this),
    sourceStart_ (::xml_schema::flags (), this),
    sourceEnd_ (::xml_schema::flags (), this)
  {
  }

  hasTrackPart::
  hasTrackPart (const hasTrackPart& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::ebuCore_2012::relationType (x, f, c),
    trackPartTitle_ (x.trackPartTitle_, f, this),
    destinationId_ (x.destinationId_, f, this),
    destinationStart_ (x.destinationStart_, f, this),
    destinationEnd_ (x.destinationEnd_, f, this),
    sourceId_ (x.sourceId_, f, this),
    sourceStart_ (x.sourceStart_, f, this),
    sourceEnd_ (x.sourceEnd_, f, this)
  {
  }

  hasTrackPart::
  hasTrackPart (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::ebuCore_2012::relationType (e, f | ::xml_schema::flags::base, c),
    trackPartTitle_ (f, this),
    destinationId_ (f, this),
    destinationStart_ (f, this),
    destinationEnd_ (f, this),
    sourceId_ (f, this),
    sourceStart_ (f, this),
    sourceEnd_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void hasTrackPart::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::ebuCore_2012::relationType::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // trackPartTitle
      //
      if (n.name () == "trackPartTitle" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< trackPartTitle_type > r (
          trackPartTitle_traits::create (i, f, this));

        if (!trackPartTitle_.present ())
        {
          this->trackPartTitle_.set (r);
          continue;
        }
      }

      // destinationId
      //
      if (n.name () == "destinationId" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< destinationId_type > r (
          destinationId_traits::create (i, f, this));

        if (!this->destinationId_)
        {
          this->destinationId_.set (r);
          continue;
        }
      }

      // destinationStart
      //
      if (n.name () == "destinationStart" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< destinationStart_type > r (
          destinationStart_traits::create (i, f, this));

        if (!this->destinationStart_)
        {
          this->destinationStart_.set (r);
          continue;
        }
      }

      // destinationEnd
      //
      if (n.name () == "destinationEnd" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< destinationEnd_type > r (
          destinationEnd_traits::create (i, f, this));

        if (!this->destinationEnd_)
        {
          this->destinationEnd_.set (r);
          continue;
        }
      }

      // sourceId
      //
      if (n.name () == "sourceId" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< sourceId_type > r (
          sourceId_traits::create (i, f, this));

        if (!this->sourceId_)
        {
          this->sourceId_.set (r);
          continue;
        }
      }

      // sourceStart
      //
      if (n.name () == "sourceStart" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< sourceStart_type > r (
          sourceStart_traits::create (i, f, this));

        if (!this->sourceStart_)
        {
          this->sourceStart_.set (r);
          continue;
        }
      }

      // sourceEnd
      //
      if (n.name () == "sourceEnd" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< sourceEnd_type > r (
          sourceEnd_traits::create (i, f, this));

        if (!this->sourceEnd_)
        {
          this->sourceEnd_.set (r);
          continue;
        }
      }

      break;
    }

    if (!trackPartTitle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "trackPartTitle",
        "urn:ebu:metadata-schema:ebuCore_2012");
    }
  }

  hasTrackPart* hasTrackPart::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hasTrackPart (*this, f, c);
  }

  hasTrackPart::
  ~hasTrackPart ()
  {
  }

  // genre
  //

  genre::
  genre ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  genre::
  genre (const genre& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  genre::
  genre (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void genre::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  genre* genre::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class genre (*this, f, c);
  }

  genre::
  ~genre ()
  {
  }

  // objectType
  //

  objectType::
  objectType ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  objectType::
  objectType (const objectType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  objectType::
  objectType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void objectType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  objectType* objectType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class objectType (*this, f, c);
  }

  objectType::
  ~objectType ()
  {
  }

  // targetAudience
  //

  targetAudience::
  targetAudience ()
  : ::xml_schema::type (),
    targetRegion_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    reason_ (::xml_schema::flags (), this),
    linkToLogo_ (::xml_schema::flags (), this),
    notRated_ (::xml_schema::flags (), this),
    adultContent_ (::xml_schema::flags (), this)
  {
  }

  targetAudience::
  targetAudience (const targetAudience& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    targetRegion_ (x.targetRegion_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    reason_ (x.reason_, f, this),
    linkToLogo_ (x.linkToLogo_, f, this),
    notRated_ (x.notRated_, f, this),
    adultContent_ (x.adultContent_, f, this)
  {
  }

  targetAudience::
  targetAudience (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    targetRegion_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    reason_ (f, this),
    linkToLogo_ (f, this),
    notRated_ (f, this),
    adultContent_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void targetAudience::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // targetRegion
      //
      if (n.name () == "targetRegion" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< targetRegion_type > r (
          targetRegion_traits::create (i, f, this));

        this->targetRegion_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "reason" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< reason_type > r (
          reason_traits::create (i, f, this));

        this->reason_.set (r);
        continue;
      }

      if (n.name () == "linkToLogo" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< linkToLogo_type > r (
          linkToLogo_traits::create (i, f, this));

        this->linkToLogo_.set (r);
        continue;
      }

      if (n.name () == "notRated" && n.namespace_ ().empty ())
      {
        this->notRated_.set (notRated_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "adultContent" && n.namespace_ ().empty ())
      {
        this->adultContent_.set (adultContent_traits::create (i, f, this));
        continue;
      }
    }
  }

  targetAudience* targetAudience::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class targetAudience (*this, f, c);
  }

  targetAudience::
  ~targetAudience ()
  {
  }

  // temporal
  //

  temporal::
  temporal ()
  : ::xml_schema::type (),
    PeriodOfTime_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    note_ (::xml_schema::flags (), this),
    periodId_ (::xml_schema::flags (), this)
  {
  }

  temporal::
  temporal (const temporal& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    PeriodOfTime_ (x.PeriodOfTime_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    note_ (x.note_, f, this),
    periodId_ (x.periodId_, f, this)
  {
  }

  temporal::
  temporal (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    PeriodOfTime_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    note_ (f, this),
    periodId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void temporal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PeriodOfTime
      //
      if (n.name () == "PeriodOfTime" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< PeriodOfTime_type > r (
          PeriodOfTime_traits::create (i, f, this));

        this->PeriodOfTime_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.set (r);
        continue;
      }

      if (n.name () == "periodId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< periodId_type > r (
          periodId_traits::create (i, f, this));

        this->periodId_.set (r);
        continue;
      }
    }
  }

  temporal* temporal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class temporal (*this, f, c);
  }

  temporal::
  ~temporal ()
  {
  }

  // spatial
  //

  spatial::
  spatial ()
  : ::xml_schema::type (),
    location_ (::xml_schema::flags (), this)
  {
  }

  spatial::
  spatial (const spatial& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    location_ (x.location_, f, this)
  {
  }

  spatial::
  spatial (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    location_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void spatial::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // location
      //
      if (n.name () == "location" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< location_type > r (
          location_traits::create (i, f, this));

        this->location_.push_back (r);
        continue;
      }

      break;
    }
  }

  spatial* spatial::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class spatial (*this, f, c);
  }

  spatial::
  ~spatial ()
  {
  }

  // coordinates
  //

  coordinates::
  coordinates (const posy_type& posy,
               const posx_type& posx)
  : ::xml_schema::type (),
    posy_ (posy, ::xml_schema::flags (), this),
    posx_ (posx, ::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  coordinates::
  coordinates (const coordinates& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    posy_ (x.posy_, f, this),
    posx_ (x.posx_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this)
  {
  }

  coordinates::
  coordinates (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    posy_ (f, this),
    posx_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void coordinates::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // posy
      //
      if (n.name () == "posy" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!posy_.present ())
        {
          this->posy_.set (posy_traits::create (i, f, this));
          continue;
        }
      }

      // posx
      //
      if (n.name () == "posx" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!posx_.present ())
        {
          this->posx_.set (posx_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!posy_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "posy",
        "urn:ebu:metadata-schema:ebuCore_2012");
    }

    if (!posx_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "posx",
        "urn:ebu:metadata-schema:ebuCore_2012");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }
    }
  }

  coordinates* coordinates::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class coordinates (*this, f, c);
  }

  coordinates::
  ~coordinates ()
  {
  }

  // created
  //

  created::
  created ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this)
  {
  }

  created::
  created (const created& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this)
  {
  }

  created::
  created (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void created::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }
    }
  }

  created* created::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class created (*this, f, c);
  }

  created::
  ~created ()
  {
  }

  // issued
  //

  issued::
  issued ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this)
  {
  }

  issued::
  issued (const issued& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this)
  {
  }

  issued::
  issued (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void issued::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }
    }
  }

  issued* issued::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class issued (*this, f, c);
  }

  issued::
  ~issued ()
  {
  }

  // modified
  //

  modified::
  modified ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this)
  {
  }

  modified::
  modified (const modified& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this)
  {
  }

  modified::
  modified (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void modified::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }
    }
  }

  modified* modified::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class modified (*this, f, c);
  }

  modified::
  ~modified ()
  {
  }

  // digitised
  //

  digitised::
  digitised ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this)
  {
  }

  digitised::
  digitised (const digitised& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this)
  {
  }

  digitised::
  digitised (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void digitised::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }
    }
  }

  digitised* digitised::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class digitised (*this, f, c);
  }

  digitised::
  ~digitised ()
  {
  }

  // released
  //

  released::
  released ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this)
  {
  }

  released::
  released (const released& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this)
  {
  }

  released::
  released (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void released::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }
    }
  }

  released* released::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class released (*this, f, c);
  }

  released::
  ~released ()
  {
  }

  // copyrighted
  //

  copyrighted::
  copyrighted ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this)
  {
  }

  copyrighted::
  copyrighted (const copyrighted& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this)
  {
  }

  copyrighted::
  copyrighted (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void copyrighted::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }
    }
  }

  copyrighted* copyrighted::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class copyrighted (*this, f, c);
  }

  copyrighted::
  ~copyrighted ()
  {
  }

  // alternative
  //

  alternative::
  alternative ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  alternative::
  alternative (const alternative& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  alternative::
  alternative (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void alternative::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  alternative* alternative::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class alternative (*this, f, c);
  }

  alternative::
  ~alternative ()
  {
  }

  // medium
  //

  medium::
  medium ()
  : ::xml_schema::type (),
    mediumId_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  medium::
  medium (const medium& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    mediumId_ (x.mediumId_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  medium::
  medium (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    mediumId_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void medium::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mediumId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< mediumId_type > r (
          mediumId_traits::create (i, f, this));

        this->mediumId_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  medium* medium::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class medium (*this, f, c);
  }

  medium::
  ~medium ()
  {
  }

  // containerFormat
  //

  containerFormat::
  containerFormat ()
  : ::xml_schema::type (),
    comment_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  containerFormat::
  containerFormat (const containerFormat& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    comment_ (x.comment_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this)
  {
  }

  containerFormat::
  containerFormat (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    comment_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void containerFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        this->comment_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }
    }
  }

  containerFormat* containerFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class containerFormat (*this, f, c);
  }

  containerFormat::
  ~containerFormat ()
  {
  }

  // signingFormat
  //

  signingFormat::
  signingFormat ()
  : ::xml_schema::type (),
    signingFormatId_ (::xml_schema::flags (), this),
    signingFormatVersionId_ (::xml_schema::flags (), this),
    signingFormatName_ (::xml_schema::flags (), this),
    trackId_ (::xml_schema::flags (), this),
    trackName_ (::xml_schema::flags (), this),
    signingSourceUri_ (::xml_schema::flags (), this),
    language_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  signingFormat::
  signingFormat (const signingFormat& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    signingFormatId_ (x.signingFormatId_, f, this),
    signingFormatVersionId_ (x.signingFormatVersionId_, f, this),
    signingFormatName_ (x.signingFormatName_, f, this),
    trackId_ (x.trackId_, f, this),
    trackName_ (x.trackName_, f, this),
    signingSourceUri_ (x.signingSourceUri_, f, this),
    language_ (x.language_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this)
  {
  }

  signingFormat::
  signingFormat (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    signingFormatId_ (f, this),
    signingFormatVersionId_ (f, this),
    signingFormatName_ (f, this),
    trackId_ (f, this),
    trackName_ (f, this),
    signingSourceUri_ (f, this),
    language_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void signingFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "signingFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signingFormatId_type > r (
          signingFormatId_traits::create (i, f, this));

        this->signingFormatId_.set (r);
        continue;
      }

      if (n.name () == "signingFormatVersionId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signingFormatVersionId_type > r (
          signingFormatVersionId_traits::create (i, f, this));

        this->signingFormatVersionId_.set (r);
        continue;
      }

      if (n.name () == "signingFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signingFormatName_type > r (
          signingFormatName_traits::create (i, f, this));

        this->signingFormatName_.set (r);
        continue;
      }

      if (n.name () == "trackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackId_type > r (
          trackId_traits::create (i, f, this));

        this->trackId_.set (r);
        continue;
      }

      if (n.name () == "trackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackName_type > r (
          trackName_traits::create (i, f, this));

        this->trackName_.set (r);
        continue;
      }

      if (n.name () == "signingSourceUri" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signingSourceUri_type > r (
          signingSourceUri_traits::create (i, f, this));

        this->signingSourceUri_.set (r);
        continue;
      }

      if (n.name () == "language" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< language_type > r (
          language_traits::create (i, f, this));

        this->language_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }
    }
  }

  signingFormat* signingFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class signingFormat (*this, f, c);
  }

  signingFormat::
  ~signingFormat ()
  {
  }

  // dateCreated
  //

  dateCreated::
  dateCreated ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this)
  {
  }

  dateCreated::
  dateCreated (const dateCreated& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this)
  {
  }

  dateCreated::
  dateCreated (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void dateCreated::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }
    }
  }

  dateCreated* dateCreated::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dateCreated (*this, f, c);
  }

  dateCreated::
  ~dateCreated ()
  {
  }

  // dateModified
  //

  dateModified::
  dateModified ()
  : ::xml_schema::type (),
    startYear_ (::xml_schema::flags (), this),
    startDate_ (::xml_schema::flags (), this),
    startTime_ (::xml_schema::flags (), this),
    endYear_ (::xml_schema::flags (), this),
    endDate_ (::xml_schema::flags (), this),
    endTime_ (::xml_schema::flags (), this)
  {
  }

  dateModified::
  dateModified (const dateModified& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    startYear_ (x.startYear_, f, this),
    startDate_ (x.startDate_, f, this),
    startTime_ (x.startTime_, f, this),
    endYear_ (x.endYear_, f, this),
    endDate_ (x.endDate_, f, this),
    endTime_ (x.endTime_, f, this)
  {
  }

  dateModified::
  dateModified (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    startYear_ (f, this),
    startDate_ (f, this),
    startTime_ (f, this),
    endYear_ (f, this),
    endDate_ (f, this),
    endTime_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void dateModified::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "startYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startYear_type > r (
          startYear_traits::create (i, f, this));

        this->startYear_.set (r);
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startDate_type > r (
          startDate_traits::create (i, f, this));

        this->startDate_.set (r);
        continue;
      }

      if (n.name () == "startTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startTime_type > r (
          startTime_traits::create (i, f, this));

        this->startTime_.set (r);
        continue;
      }

      if (n.name () == "endYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endYear_type > r (
          endYear_traits::create (i, f, this));

        this->endYear_.set (r);
        continue;
      }

      if (n.name () == "endDate" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endDate_type > r (
          endDate_traits::create (i, f, this));

        this->endDate_.set (r);
        continue;
      }

      if (n.name () == "endTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< endTime_type > r (
          endTime_traits::create (i, f, this));

        this->endTime_.set (r);
        continue;
      }
    }
  }

  dateModified* dateModified::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dateModified (*this, f, c);
  }

  dateModified::
  ~dateModified ()
  {
  }

  // role
  //

  role::
  role ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    costCentre_ (::xml_schema::flags (), this)
  {
  }

  role::
  role (const role& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    costCentre_ (x.costCentre_, f, this)
  {
  }

  role::
  role (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    costCentre_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void role::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "costCentre" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< costCentre_type > r (
          costCentre_traits::create (i, f, this));

        this->costCentre_.set (r);
        continue;
      }
    }
  }

  role* role::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class role (*this, f, c);
  }

  role::
  ~role ()
  {
  }

  // relatedInformationLink
  //

  relatedInformationLink::
  relatedInformationLink (const ::xml_schema::uri& _xsd_uri_base)
  : ::xml_schema::uri (_xsd_uri_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  relatedInformationLink::
  relatedInformationLink (const relatedInformationLink& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::uri (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  relatedInformationLink::
  relatedInformationLink (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::uri (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void relatedInformationLink::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  relatedInformationLink* relatedInformationLink::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class relatedInformationLink (*this, f, c);
  }

  relatedInformationLink::
  ~relatedInformationLink ()
  {
  }

  // organisationDepartment
  //

  organisationDepartment::
  organisationDepartment ()
  : ::dc::elementType (),
    departmentId_ (::xml_schema::flags (), this)
  {
  }

  organisationDepartment::
  organisationDepartment (const char* _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    departmentId_ (::xml_schema::flags (), this)
  {
  }

  organisationDepartment::
  organisationDepartment (const ::std::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    departmentId_ (::xml_schema::flags (), this)
  {
  }

  organisationDepartment::
  organisationDepartment (const ::xml_schema::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    departmentId_ (::xml_schema::flags (), this)
  {
  }

  organisationDepartment::
  organisationDepartment (const organisationDepartment& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::dc::elementType (x, f, c),
    departmentId_ (x.departmentId_, f, this)
  {
  }

  organisationDepartment::
  organisationDepartment (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::dc::elementType (e, f | ::xml_schema::flags::base, c),
    departmentId_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void organisationDepartment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dc::elementType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "departmentId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< departmentId_type > r (
          departmentId_traits::create (i, f, this));

        this->departmentId_.set (r);
        continue;
      }
    }
  }

  organisationDepartment* organisationDepartment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class organisationDepartment (*this, f, c);
  }

  organisationDepartment::
  ~organisationDepartment ()
  {
  }

  // relatedInformationLink1
  //

  relatedInformationLink1::
  relatedInformationLink1 (const ::xml_schema::uri& _xsd_uri_base)
  : ::xml_schema::uri (_xsd_uri_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  relatedInformationLink1::
  relatedInformationLink1 (const relatedInformationLink1& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::uri (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  relatedInformationLink1::
  relatedInformationLink1 (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::uri (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void relatedInformationLink1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  relatedInformationLink1* relatedInformationLink1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class relatedInformationLink1 (*this, f, c);
  }

  relatedInformationLink1::
  ~relatedInformationLink1 ()
  {
  }

  // country
  //

  country::
  country ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  country::
  country (const country& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  country::
  country (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void country::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  country* country::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class country (*this, f, c);
  }

  country::
  ~country ()
  {
  }

  // country1
  //

  country1::
  country1 ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  country1::
  country1 (const country1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  country1::
  country1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void country1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  country1* country1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class country1 (*this, f, c);
  }

  country1::
  ~country1 ()
  {
  }

  // countryRegion
  //

  countryRegion::
  countryRegion ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  countryRegion::
  countryRegion (const countryRegion& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  countryRegion::
  countryRegion (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void countryRegion::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  countryRegion* countryRegion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class countryRegion (*this, f, c);
  }

  countryRegion::
  ~countryRegion ()
  {
  }

  // orientation
  //

  orientation::
  orientation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_orientation_convert ();
  }

  orientation::
  orientation (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_orientation_convert ();
  }

  orientation::
  orientation (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_orientation_convert ();
  }

  orientation* orientation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class orientation (*this, f, c);
  }

  orientation::value orientation::
  _xsd_orientation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_orientation_literals_);
    const value* i (::std::lower_bound (
                      _xsd_orientation_indexes_,
                      _xsd_orientation_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_orientation_indexes_ + 2 || _xsd_orientation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const orientation::
  _xsd_orientation_literals_[2] =
  {
    "landscape",
    "portrait"
  };

  const orientation::value orientation::
  _xsd_orientation_indexes_[2] =
  {
    ::ebuCore_2012::orientation::landscape,
    ::ebuCore_2012::orientation::portrait
  };

  // imageEncoding
  //

  imageEncoding::
  imageEncoding ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  imageEncoding::
  imageEncoding (const imageEncoding& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  imageEncoding::
  imageEncoding (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void imageEncoding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  imageEncoding* imageEncoding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class imageEncoding (*this, f, c);
  }

  imageEncoding::
  ~imageEncoding ()
  {
  }

  // comment
  //

  comment::
  comment ()
  : ::dc::elementType (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment::
  comment (const char* _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment::
  comment (const ::std::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment::
  comment (const ::xml_schema::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment::
  comment (const comment& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::dc::elementType (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  comment::
  comment (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::dc::elementType (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void comment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dc::elementType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  comment* comment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class comment (*this, f, c);
  }

  comment::
  ~comment ()
  {
  }

  // width
  //

  width::
  width (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::ebuCore_2012::dimensionType (_xsd_non_negative_integer_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  width::
  width (const width& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::ebuCore_2012::dimensionType (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  width::
  width (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::ebuCore_2012::dimensionType (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void width::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::ebuCore_2012::dimensionType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  width* width::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class width (*this, f, c);
  }

  width::
  ~width ()
  {
  }

  // height
  //

  height::
  height (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::ebuCore_2012::dimensionType (_xsd_non_negative_integer_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  height::
  height (const height& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::ebuCore_2012::dimensionType (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  height::
  height (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::ebuCore_2012::dimensionType (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void height::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::ebuCore_2012::dimensionType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  height* height::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class height (*this, f, c);
  }

  height::
  ~height ()
  {
  }

  // videoEncoding
  //

  videoEncoding::
  videoEncoding ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  videoEncoding::
  videoEncoding (const videoEncoding& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  videoEncoding::
  videoEncoding (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void videoEncoding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  videoEncoding* videoEncoding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class videoEncoding (*this, f, c);
  }

  videoEncoding::
  ~videoEncoding ()
  {
  }

  // bitRateMode
  //

  bitRateMode::
  bitRateMode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_bitRateMode_convert ();
  }

  bitRateMode::
  bitRateMode (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_bitRateMode_convert ();
  }

  bitRateMode::
  bitRateMode (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_bitRateMode_convert ();
  }

  bitRateMode* bitRateMode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bitRateMode (*this, f, c);
  }

  bitRateMode::value bitRateMode::
  _xsd_bitRateMode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bitRateMode_literals_);
    const value* i (::std::lower_bound (
                      _xsd_bitRateMode_indexes_,
                      _xsd_bitRateMode_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_bitRateMode_indexes_ + 3 || _xsd_bitRateMode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const bitRateMode::
  _xsd_bitRateMode_literals_[3] =
  {
    "none",
    "constant",
    "variable"
  };

  const bitRateMode::value bitRateMode::
  _xsd_bitRateMode_indexes_[3] =
  {
    ::ebuCore_2012::bitRateMode::constant,
    ::ebuCore_2012::bitRateMode::none,
    ::ebuCore_2012::bitRateMode::variable
  };

  // scanningFormat
  //

  scanningFormat::
  scanningFormat (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_scanningFormat_convert ();
  }

  scanningFormat::
  scanningFormat (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_scanningFormat_convert ();
  }

  scanningFormat::
  scanningFormat (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_scanningFormat_convert ();
  }

  scanningFormat* scanningFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class scanningFormat (*this, f, c);
  }

  scanningFormat::value scanningFormat::
  _xsd_scanningFormat_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_scanningFormat_literals_);
    const value* i (::std::lower_bound (
                      _xsd_scanningFormat_indexes_,
                      _xsd_scanningFormat_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_scanningFormat_indexes_ + 3 || _xsd_scanningFormat_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const scanningFormat::
  _xsd_scanningFormat_literals_[3] =
  {
    "none",
    "interlaced",
    "progressive"
  };

  const scanningFormat::value scanningFormat::
  _xsd_scanningFormat_indexes_[3] =
  {
    ::ebuCore_2012::scanningFormat::interlaced,
    ::ebuCore_2012::scanningFormat::none,
    ::ebuCore_2012::scanningFormat::progressive
  };

  // scanningOrder
  //

  scanningOrder::
  scanningOrder (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_scanningOrder_convert ();
  }

  scanningOrder::
  scanningOrder (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_scanningOrder_convert ();
  }

  scanningOrder::
  scanningOrder (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_scanningOrder_convert ();
  }

  scanningOrder* scanningOrder::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class scanningOrder (*this, f, c);
  }

  scanningOrder::value scanningOrder::
  _xsd_scanningOrder_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_scanningOrder_literals_);
    const value* i (::std::lower_bound (
                      _xsd_scanningOrder_indexes_,
                      _xsd_scanningOrder_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_scanningOrder_indexes_ + 3 || _xsd_scanningOrder_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const scanningOrder::
  _xsd_scanningOrder_literals_[3] =
  {
    "none",
    "top",
    "bottom"
  };

  const scanningOrder::value scanningOrder::
  _xsd_scanningOrder_indexes_[3] =
  {
    ::ebuCore_2012::scanningOrder::bottom,
    ::ebuCore_2012::scanningOrder::none,
    ::ebuCore_2012::scanningOrder::top
  };

  // videoTrack
  //

  videoTrack::
  videoTrack ()
  : ::xml_schema::type (),
    trackId_ (::xml_schema::flags (), this),
    trackName_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  videoTrack::
  videoTrack (const videoTrack& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    trackId_ (x.trackId_, f, this),
    trackName_ (x.trackName_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  videoTrack::
  videoTrack (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    trackId_ (f, this),
    trackName_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void videoTrack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "trackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackId_type > r (
          trackId_traits::create (i, f, this));

        this->trackId_.set (r);
        continue;
      }

      if (n.name () == "trackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackName_type > r (
          trackName_traits::create (i, f, this));

        this->trackName_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  videoTrack* videoTrack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class videoTrack (*this, f, c);
  }

  videoTrack::
  ~videoTrack ()
  {
  }

  // comment1
  //

  comment1::
  comment1 ()
  : ::dc::elementType (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment1::
  comment1 (const char* _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment1::
  comment1 (const ::std::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment1::
  comment1 (const ::xml_schema::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment1::
  comment1 (const comment1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::dc::elementType (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  comment1::
  comment1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::dc::elementType (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void comment1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dc::elementType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  comment1* comment1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class comment1 (*this, f, c);
  }

  comment1::
  ~comment1 ()
  {
  }

  // audioEncoding
  //

  audioEncoding::
  audioEncoding ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  audioEncoding::
  audioEncoding (const audioEncoding& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  audioEncoding::
  audioEncoding (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void audioEncoding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  audioEncoding* audioEncoding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class audioEncoding (*this, f, c);
  }

  audioEncoding::
  ~audioEncoding ()
  {
  }

  // audioTrackConfiguration
  //

  audioTrackConfiguration::
  audioTrackConfiguration ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  audioTrackConfiguration::
  audioTrackConfiguration (const audioTrackConfiguration& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  audioTrackConfiguration::
  audioTrackConfiguration (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void audioTrackConfiguration::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  audioTrackConfiguration* audioTrackConfiguration::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class audioTrackConfiguration (*this, f, c);
  }

  audioTrackConfiguration::
  ~audioTrackConfiguration ()
  {
  }

  // sampleType
  //

  sampleType::
  sampleType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_sampleType_convert ();
  }

  sampleType::
  sampleType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_sampleType_convert ();
  }

  sampleType::
  sampleType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_sampleType_convert ();
  }

  sampleType* sampleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sampleType (*this, f, c);
  }

  sampleType::value sampleType::
  _xsd_sampleType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_sampleType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_sampleType_indexes_,
                      _xsd_sampleType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_sampleType_indexes_ + 2 || _xsd_sampleType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const sampleType::
  _xsd_sampleType_literals_[2] =
  {
    "float",
    "integer"
  };

  const sampleType::value sampleType::
  _xsd_sampleType_indexes_[2] =
  {
    ::ebuCore_2012::sampleType::float_,
    ::ebuCore_2012::sampleType::integer
  };

  // bitRateMode1
  //

  bitRateMode1::
  bitRateMode1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_bitRateMode1_convert ();
  }

  bitRateMode1::
  bitRateMode1 (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_bitRateMode1_convert ();
  }

  bitRateMode1::
  bitRateMode1 (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_bitRateMode1_convert ();
  }

  bitRateMode1* bitRateMode1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bitRateMode1 (*this, f, c);
  }

  bitRateMode1::value bitRateMode1::
  _xsd_bitRateMode1_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bitRateMode1_literals_);
    const value* i (::std::lower_bound (
                      _xsd_bitRateMode1_indexes_,
                      _xsd_bitRateMode1_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_bitRateMode1_indexes_ + 3 || _xsd_bitRateMode1_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const bitRateMode1::
  _xsd_bitRateMode1_literals_[3] =
  {
    "none",
    "constant",
    "variable"
  };

  const bitRateMode1::value bitRateMode1::
  _xsd_bitRateMode1_indexes_[3] =
  {
    ::ebuCore_2012::bitRateMode1::constant,
    ::ebuCore_2012::bitRateMode1::none,
    ::ebuCore_2012::bitRateMode1::variable
  };

  // audioTrack
  //

  audioTrack::
  audioTrack ()
  : ::xml_schema::type (),
    trackLanguage_ (::xml_schema::flags (), this),
    trackId_ (::xml_schema::flags (), this),
    trackName_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  audioTrack::
  audioTrack (const audioTrack& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    trackLanguage_ (x.trackLanguage_, f, this),
    trackId_ (x.trackId_, f, this),
    trackName_ (x.trackName_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  audioTrack::
  audioTrack (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    trackLanguage_ (f, this),
    trackId_ (f, this),
    trackName_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void audioTrack::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "trackLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackLanguage_type > r (
          trackLanguage_traits::create (i, f, this));

        this->trackLanguage_.set (r);
        continue;
      }

      if (n.name () == "trackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackId_type > r (
          trackId_traits::create (i, f, this));

        this->trackId_.set (r);
        continue;
      }

      if (n.name () == "trackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackName_type > r (
          trackName_traits::create (i, f, this));

        this->trackName_.set (r);
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  audioTrack* audioTrack::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class audioTrack (*this, f, c);
  }

  audioTrack::
  ~audioTrack ()
  {
  }

  // comment2
  //

  comment2::
  comment2 ()
  : ::dc::elementType (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment2::
  comment2 (const char* _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment2::
  comment2 (const ::std::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment2::
  comment2 (const ::xml_schema::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment2::
  comment2 (const comment2& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::dc::elementType (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  comment2::
  comment2 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::dc::elementType (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void comment2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dc::elementType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  comment2* comment2::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class comment2 (*this, f, c);
  }

  comment2::
  ~comment2 ()
  {
  }

  // captioningFormat
  //

  captioningFormat::
  captioningFormat ()
  : ::xml_schema::type (),
    captioningFormatId_ (::xml_schema::flags (), this),
    captioningFormatName_ (::xml_schema::flags (), this),
    trackId_ (::xml_schema::flags (), this),
    trackName_ (::xml_schema::flags (), this),
    captioningSourceUri_ (::xml_schema::flags (), this),
    language_ (::xml_schema::flags (), this),
    closed_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  captioningFormat::
  captioningFormat (const captioningFormat& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    captioningFormatId_ (x.captioningFormatId_, f, this),
    captioningFormatName_ (x.captioningFormatName_, f, this),
    trackId_ (x.trackId_, f, this),
    trackName_ (x.trackName_, f, this),
    captioningSourceUri_ (x.captioningSourceUri_, f, this),
    language_ (x.language_, f, this),
    closed_ (x.closed_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this)
  {
  }

  captioningFormat::
  captioningFormat (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    captioningFormatId_ (f, this),
    captioningFormatName_ (f, this),
    trackId_ (f, this),
    trackName_ (f, this),
    captioningSourceUri_ (f, this),
    language_ (f, this),
    closed_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void captioningFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "captioningFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< captioningFormatId_type > r (
          captioningFormatId_traits::create (i, f, this));

        this->captioningFormatId_.set (r);
        continue;
      }

      if (n.name () == "captioningFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< captioningFormatName_type > r (
          captioningFormatName_traits::create (i, f, this));

        this->captioningFormatName_.set (r);
        continue;
      }

      if (n.name () == "trackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackId_type > r (
          trackId_traits::create (i, f, this));

        this->trackId_.set (r);
        continue;
      }

      if (n.name () == "trackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackName_type > r (
          trackName_traits::create (i, f, this));

        this->trackName_.set (r);
        continue;
      }

      if (n.name () == "captioningSourceUri" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< captioningSourceUri_type > r (
          captioningSourceUri_traits::create (i, f, this));

        this->captioningSourceUri_.set (r);
        continue;
      }

      if (n.name () == "language" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< language_type > r (
          language_traits::create (i, f, this));

        this->language_.set (r);
        continue;
      }

      if (n.name () == "closed" && n.namespace_ ().empty ())
      {
        this->closed_.set (closed_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }
    }
  }

  captioningFormat* captioningFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class captioningFormat (*this, f, c);
  }

  captioningFormat::
  ~captioningFormat ()
  {
  }

  // subtitlingFormat
  //

  subtitlingFormat::
  subtitlingFormat ()
  : ::xml_schema::type (),
    subtitlingFormatId_ (::xml_schema::flags (), this),
    subtitlingFormatName_ (::xml_schema::flags (), this),
    trackId_ (::xml_schema::flags (), this),
    trackName_ (::xml_schema::flags (), this),
    subtitlingSourceUri_ (::xml_schema::flags (), this),
    language_ (::xml_schema::flags (), this),
    closed_ (::xml_schema::flags (), this),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  subtitlingFormat::
  subtitlingFormat (const subtitlingFormat& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    subtitlingFormatId_ (x.subtitlingFormatId_, f, this),
    subtitlingFormatName_ (x.subtitlingFormatName_, f, this),
    trackId_ (x.trackId_, f, this),
    trackName_ (x.trackName_, f, this),
    subtitlingSourceUri_ (x.subtitlingSourceUri_, f, this),
    language_ (x.language_, f, this),
    closed_ (x.closed_, f, this),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this)
  {
  }

  subtitlingFormat::
  subtitlingFormat (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    subtitlingFormatId_ (f, this),
    subtitlingFormatName_ (f, this),
    trackId_ (f, this),
    trackName_ (f, this),
    subtitlingSourceUri_ (f, this),
    language_ (f, this),
    closed_ (f, this),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void subtitlingFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "subtitlingFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< subtitlingFormatId_type > r (
          subtitlingFormatId_traits::create (i, f, this));

        this->subtitlingFormatId_.set (r);
        continue;
      }

      if (n.name () == "subtitlingFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< subtitlingFormatName_type > r (
          subtitlingFormatName_traits::create (i, f, this));

        this->subtitlingFormatName_.set (r);
        continue;
      }

      if (n.name () == "trackId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackId_type > r (
          trackId_traits::create (i, f, this));

        this->trackId_.set (r);
        continue;
      }

      if (n.name () == "trackName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trackName_type > r (
          trackName_traits::create (i, f, this));

        this->trackName_.set (r);
        continue;
      }

      if (n.name () == "subtitlingSourceUri" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< subtitlingSourceUri_type > r (
          subtitlingSourceUri_traits::create (i, f, this));

        this->subtitlingSourceUri_.set (r);
        continue;
      }

      if (n.name () == "language" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< language_type > r (
          language_traits::create (i, f, this));

        this->language_.set (r);
        continue;
      }

      if (n.name () == "closed" && n.namespace_ ().empty ())
      {
        this->closed_.set (closed_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }
    }
  }

  subtitlingFormat* subtitlingFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subtitlingFormat (*this, f, c);
  }

  subtitlingFormat::
  ~subtitlingFormat ()
  {
  }

  // ancillaryDataFormat
  //

  ancillaryDataFormat::
  ancillaryDataFormat ()
  : ::xml_schema::type (),
    DID_ (::xml_schema::flags (), this),
    SDID_ (::xml_schema::flags (), this),
    lineNumber_ (::xml_schema::flags (), this),
    wrappingType_ (::xml_schema::flags (), this),
    ancillaryDataFormatId_ (::xml_schema::flags (), this),
    ancillaryDataFormatName_ (::xml_schema::flags (), this)
  {
  }

  ancillaryDataFormat::
  ancillaryDataFormat (const ancillaryDataFormat& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DID_ (x.DID_, f, this),
    SDID_ (x.SDID_, f, this),
    lineNumber_ (x.lineNumber_, f, this),
    wrappingType_ (x.wrappingType_, f, this),
    ancillaryDataFormatId_ (x.ancillaryDataFormatId_, f, this),
    ancillaryDataFormatName_ (x.ancillaryDataFormatName_, f, this)
  {
  }

  ancillaryDataFormat::
  ancillaryDataFormat (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DID_ (f, this),
    SDID_ (f, this),
    lineNumber_ (f, this),
    wrappingType_ (f, this),
    ancillaryDataFormatId_ (f, this),
    ancillaryDataFormatName_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ancillaryDataFormat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DID
      //
      if (n.name () == "DID" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->DID_)
        {
          this->DID_.set (DID_traits::create (i, f, this));
          continue;
        }
      }

      // SDID
      //
      if (n.name () == "SDID" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->SDID_)
        {
          this->SDID_.set (SDID_traits::create (i, f, this));
          continue;
        }
      }

      // lineNumber
      //
      if (n.name () == "lineNumber" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        this->lineNumber_.push_back (lineNumber_traits::create (i, f, this));
        continue;
      }

      // wrappingType
      //
      if (n.name () == "wrappingType" && n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
      {
        if (!this->wrappingType_)
        {
          this->wrappingType_.set (wrappingType_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ancillaryDataFormatId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ancillaryDataFormatId_type > r (
          ancillaryDataFormatId_traits::create (i, f, this));

        this->ancillaryDataFormatId_.set (r);
        continue;
      }

      if (n.name () == "ancillaryDataFormatName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ancillaryDataFormatName_type > r (
          ancillaryDataFormatName_traits::create (i, f, this));

        this->ancillaryDataFormatName_.set (r);
        continue;
      }
    }
  }

  ancillaryDataFormat* ancillaryDataFormat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ancillaryDataFormat (*this, f, c);
  }

  ancillaryDataFormat::
  ~ancillaryDataFormat ()
  {
  }

  // comment3
  //

  comment3::
  comment3 ()
  : ::dc::elementType (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment3::
  comment3 (const char* _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment3::
  comment3 (const ::std::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment3::
  comment3 (const ::xml_schema::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment3::
  comment3 (const comment3& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::dc::elementType (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  comment3::
  comment3 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::dc::elementType (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void comment3::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dc::elementType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  comment3* comment3::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class comment3 (*this, f, c);
  }

  comment3::
  ~comment3 ()
  {
  }

  // comment4
  //

  comment4::
  comment4 ()
  : ::dc::elementType (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment4::
  comment4 (const char* _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment4::
  comment4 (const ::std::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment4::
  comment4 (const ::xml_schema::string& _xsd_string_base)
  : ::dc::elementType (_xsd_string_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  comment4::
  comment4 (const comment4& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::dc::elementType (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  comment4::
  comment4 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::dc::elementType (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void comment4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dc::elementType::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  comment4* comment4::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class comment4 (*this, f, c);
  }

  comment4::
  ~comment4 ()
  {
  }

  // timecode
  //

  timecode::
  timecode ()
  : ::xml_schema::string ()
  {
  }

  timecode::
  timecode (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode::
  timecode (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode::
  timecode (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode::
  timecode (const timecode& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  timecode::
  timecode (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  timecode::
  timecode (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  timecode::
  timecode (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  timecode* timecode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class timecode (*this, f, c);
  }

  timecode::
  ~timecode ()
  {
  }

  // time
  //

  time::
  time ()
  : ::xml_schema::string (),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  time::
  time (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  time::
  time (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  time::
  time (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  time::
  time (const time& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this)
  {
  }

  time::
  time (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void time::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }
    }
  }

  time* time::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class time (*this, f, c);
  }

  time::
  ~time ()
  {
  }

  // timecode1
  //

  timecode1::
  timecode1 ()
  : ::xml_schema::string ()
  {
  }

  timecode1::
  timecode1 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode1::
  timecode1 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode1::
  timecode1 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  timecode1::
  timecode1 (const timecode1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  timecode1::
  timecode1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  timecode1::
  timecode1 (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  timecode1::
  timecode1 (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  timecode1* timecode1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class timecode1 (*this, f, c);
  }

  timecode1::
  ~timecode1 ()
  {
  }

  // duration
  //

  duration::
  duration ()
  : ::xml_schema::string (),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  duration::
  duration (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  duration::
  duration (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  duration::
  duration (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    formatLabel_ (::xml_schema::flags (), this),
    formatDefinition_ (::xml_schema::flags (), this),
    formatLink_ (::xml_schema::flags (), this),
    formatLanguage_ (::xml_schema::flags (), this)
  {
  }

  duration::
  duration (const duration& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    formatLabel_ (x.formatLabel_, f, this),
    formatDefinition_ (x.formatDefinition_, f, this),
    formatLink_ (x.formatLink_, f, this),
    formatLanguage_ (x.formatLanguage_, f, this)
  {
  }

  duration::
  duration (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    formatLabel_ (f, this),
    formatDefinition_ (f, this),
    formatLink_ (f, this),
    formatLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void duration::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "formatLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLabel_type > r (
          formatLabel_traits::create (i, f, this));

        this->formatLabel_.set (r);
        continue;
      }

      if (n.name () == "formatDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatDefinition_type > r (
          formatDefinition_traits::create (i, f, this));

        this->formatDefinition_.set (r);
        continue;
      }

      if (n.name () == "formatLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLink_type > r (
          formatLink_traits::create (i, f, this));

        this->formatLink_.set (r);
        continue;
      }

      if (n.name () == "formatLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< formatLanguage_type > r (
          formatLanguage_traits::create (i, f, this));

        this->formatLanguage_.set (r);
        continue;
      }
    }
  }

  duration* duration::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class duration (*this, f, c);
  }

  duration::
  ~duration ()
  {
  }

  // hashFunction
  //

  hashFunction::
  hashFunction ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  hashFunction::
  hashFunction (const hashFunction& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  hashFunction::
  hashFunction (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void hashFunction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  hashFunction* hashFunction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hashFunction (*this, f, c);
  }

  hashFunction::
  ~hashFunction ()
  {
  }

  // mimeType
  //

  mimeType::
  mimeType ()
  : ::xml_schema::type (),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  mimeType::
  mimeType (const mimeType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  mimeType::
  mimeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void mimeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  mimeType* mimeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mimeType (*this, f, c);
  }

  mimeType::
  ~mimeType ()
  {
  }

  // locator
  //

  locator::
  locator (const ::xml_schema::uri& _xsd_uri_base)
  : ::xml_schema::uri (_xsd_uri_base),
    typeLabel_ (::xml_schema::flags (), this),
    typeDefinition_ (::xml_schema::flags (), this),
    typeLink_ (::xml_schema::flags (), this),
    typeLanguage_ (::xml_schema::flags (), this)
  {
  }

  locator::
  locator (const locator& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::uri (x, f, c),
    typeLabel_ (x.typeLabel_, f, this),
    typeDefinition_ (x.typeDefinition_, f, this),
    typeLink_ (x.typeLink_, f, this),
    typeLanguage_ (x.typeLanguage_, f, this)
  {
  }

  locator::
  locator (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::uri (e, f | ::xml_schema::flags::base, c),
    typeLabel_ (f, this),
    typeDefinition_ (f, this),
    typeLink_ (f, this),
    typeLanguage_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void locator::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "typeLabel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLabel_type > r (
          typeLabel_traits::create (i, f, this));

        this->typeLabel_.set (r);
        continue;
      }

      if (n.name () == "typeDefinition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeDefinition_type > r (
          typeDefinition_traits::create (i, f, this));

        this->typeDefinition_.set (r);
        continue;
      }

      if (n.name () == "typeLink" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLink_type > r (
          typeLink_traits::create (i, f, this));

        this->typeLink_.set (r);
        continue;
      }

      if (n.name () == "typeLanguage" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< typeLanguage_type > r (
          typeLanguage_traits::create (i, f, this));

        this->typeLanguage_.set (r);
        continue;
      }
    }
  }

  locator* locator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class locator (*this, f, c);
  }

  locator::
  ~locator ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ebuCore_2012
{
  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType > r (
      ::ebuCore_2012::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType > r (
      ::ebuCore_2012::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType > r (
      ::ebuCore_2012::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ebuCore_2012::ebuCoreMain (isrc, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ebuCore_2012::ebuCoreMain (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ebuCore_2012::ebuCoreMain (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ebuCore_2012::ebuCoreMain (isrc, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ebuCore_2012::ebuCoreMain (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ebuCore_2012::ebuCoreMain (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType > r (
      ::ebuCore_2012::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType > r (
      ::ebuCore_2012::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType > r (
      ::ebuCore_2012::ebuCoreMain (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType > r (
        ::ebuCore_2012::ebuCoreMain (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ebuCoreMain" &&
        n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
    {
      ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType > r (
        ::xsd::cxx::tree::traits< ::ebuCore_2012::ebuCoreMainType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ebuCoreMain",
      "urn:ebu:metadata-schema:ebuCore_2012");
  }

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ebuCoreMain" &&
        n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
    {
      ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType > r (
        ::xsd::cxx::tree::traits< ::ebuCore_2012::ebuCoreMainType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ebuCoreMain",
      "urn:ebu:metadata-schema:ebuCore_2012");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace ebuCore_2012
{
  void
  ebuCoreMain (::std::ostream& o,
               const ::ebuCore_2012::ebuCoreMainType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2012::ebuCoreMain (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ebuCoreMain (::std::ostream& o,
               const ::ebuCore_2012::ebuCoreMainType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2012::ebuCoreMain (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ebuCoreMain (::std::ostream& o,
               const ::ebuCore_2012::ebuCoreMainType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2012::ebuCoreMain (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& t,
               const ::ebuCore_2012::ebuCoreMainType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2012::ebuCoreMain (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& t,
               const ::ebuCore_2012::ebuCoreMainType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2012::ebuCoreMain (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& t,
               const ::ebuCore_2012::ebuCoreMainType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ebuCore_2012::ebuCoreMain (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ebuCoreMain (::xercesc::DOMDocument& d,
               const ::ebuCore_2012::ebuCoreMainType& s,
               ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ebuCoreMain" &&
        n.namespace_ () == "urn:ebu:metadata-schema:ebuCore_2012")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ebuCoreMain",
        "urn:ebu:metadata-schema:ebuCore_2012");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  ebuCoreMain (const ::ebuCore_2012::ebuCoreMainType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "ebuCoreMain",
        "urn:ebu:metadata-schema:ebuCore_2012",
        m, f));

    ::ebuCore_2012::ebuCoreMain (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const ebuCoreMainType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // coreMetadata
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coreMetadata",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << i.coreMetadata ();
    }

    // metadataProvider
    //
    if (i.metadataProvider ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "metadataProvider",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.metadataProvider ();
    }

    // schema
    //
    if (i.schema ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "schema",
          e));

      a << *i.schema ();
    }

    // version
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "version",
          e));

      a << i.version ();
    }

    // dateLastModified
    //
    if (i.dateLastModified ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dateLastModified",
          e));

      a << *i.dateLastModified ();
    }

    // documentId
    //
    if (i.documentId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentId",
          e));

      a << *i.documentId ();
    }

    // documentLocation
    //
    if (i.documentLocation ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentLocation",
          e));

      a << *i.documentLocation ();
    }

    // lang
    //
    if (i.lang ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "lang",
          "http://www.w3.org/XML/1998/namespace",
          e));

      a << *i.lang ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const coreMetadataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // title
    //
    for (coreMetadataType::title_const_iterator
         b (i.title ().begin ()), n (i.title ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "title",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // alternativeTitle
    //
    for (coreMetadataType::alternativeTitle_const_iterator
         b (i.alternativeTitle ().begin ()), n (i.alternativeTitle ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alternativeTitle",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // creator
    //
    for (coreMetadataType::creator_const_iterator
         b (i.creator ().begin ()), n (i.creator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "creator",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // subject
    //
    for (coreMetadataType::subject_const_iterator
         b (i.subject ().begin ()), n (i.subject ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subject",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // description
    //
    for (coreMetadataType::description_const_iterator
         b (i.description ().begin ()), n (i.description ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // publisher
    //
    for (coreMetadataType::publisher_const_iterator
         b (i.publisher ().begin ()), n (i.publisher ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publisher",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // contributor
    //
    for (coreMetadataType::contributor_const_iterator
         b (i.contributor ().begin ()), n (i.contributor ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contributor",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // date
    //
    for (coreMetadataType::date_const_iterator
         b (i.date ().begin ()), n (i.date ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "date",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // type
    //
    for (coreMetadataType::type_const_iterator
         b (i.type ().begin ()), n (i.type ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // format
    //
    for (coreMetadataType::format_const_iterator
         b (i.format ().begin ()), n (i.format ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "format",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // identifier
    //
    for (coreMetadataType::identifier_const_iterator
         b (i.identifier ().begin ()), n (i.identifier ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "identifier",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // source
    //
    for (coreMetadataType::source_const_iterator
         b (i.source ().begin ()), n (i.source ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "source",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // language
    //
    for (coreMetadataType::language_const_iterator
         b (i.language ().begin ()), n (i.language ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "language",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // relation
    //
    for (coreMetadataType::relation_const_iterator
         b (i.relation ().begin ()), n (i.relation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relation",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // isVersionOf
    //
    for (coreMetadataType::isVersionOf_const_iterator
         b (i.isVersionOf ().begin ()), n (i.isVersionOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isVersionOf",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // hasVersion
    //
    for (coreMetadataType::hasVersion_const_iterator
         b (i.hasVersion ().begin ()), n (i.hasVersion ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hasVersion",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // isReplacedBy
    //
    for (coreMetadataType::isReplacedBy_const_iterator
         b (i.isReplacedBy ().begin ()), n (i.isReplacedBy ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isReplacedBy",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // replaces
    //
    for (coreMetadataType::replaces_const_iterator
         b (i.replaces ().begin ()), n (i.replaces ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "replaces",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // isRequiredBy
    //
    for (coreMetadataType::isRequiredBy_const_iterator
         b (i.isRequiredBy ().begin ()), n (i.isRequiredBy ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isRequiredBy",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // requires
    //
    for (coreMetadataType::requires_const_iterator
         b (i.requires ().begin ()), n (i.requires ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "requires",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // isPartOf
    //
    for (coreMetadataType::isPartOf_const_iterator
         b (i.isPartOf ().begin ()), n (i.isPartOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isPartOf",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // hasPart
    //
    for (coreMetadataType::hasPart_const_iterator
         b (i.hasPart ().begin ()), n (i.hasPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hasPart",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // hasTrackPart
    //
    for (coreMetadataType::hasTrackPart_const_iterator
         b (i.hasTrackPart ().begin ()), n (i.hasTrackPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hasTrackPart",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // isReferencedBy
    //
    for (coreMetadataType::isReferencedBy_const_iterator
         b (i.isReferencedBy ().begin ()), n (i.isReferencedBy ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isReferencedBy",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // references
    //
    for (coreMetadataType::references_const_iterator
         b (i.references ().begin ()), n (i.references ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "references",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // isFormatOf
    //
    for (coreMetadataType::isFormatOf_const_iterator
         b (i.isFormatOf ().begin ()), n (i.isFormatOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isFormatOf",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // hasFormat
    //
    for (coreMetadataType::hasFormat_const_iterator
         b (i.hasFormat ().begin ()), n (i.hasFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hasFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // isEpisodeOf
    //
    for (coreMetadataType::isEpisodeOf_const_iterator
         b (i.isEpisodeOf ().begin ()), n (i.isEpisodeOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isEpisodeOf",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // isMemberOf
    //
    for (coreMetadataType::isMemberOf_const_iterator
         b (i.isMemberOf ().begin ()), n (i.isMemberOf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "isMemberOf",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // hasMember
    //
    for (coreMetadataType::hasMember_const_iterator
         b (i.hasMember ().begin ()), n (i.hasMember ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hasMember",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // coverage
    //
    for (coreMetadataType::coverage_const_iterator
         b (i.coverage ().begin ()), n (i.coverage ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coverage",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // rights
    //
    for (coreMetadataType::rights_const_iterator
         b (i.rights ().begin ()), n (i.rights ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rights",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // version
    //
    for (coreMetadataType::version_const_iterator
         b (i.version ().begin ()), n (i.version ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "version",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // publicationHistory
    //
    if (i.publicationHistory ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationHistory",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.publicationHistory ();
    }

    // rating
    //
    for (coreMetadataType::rating_const_iterator
         b (i.rating ().begin ()), n (i.rating ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rating",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // part
    //
    for (coreMetadataType::part_const_iterator
         b (i.part ().begin ()), n (i.part ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "part",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const partType& i)
  {
    e << static_cast< const ::ebuCore_2012::coreMetadataType& > (i);

    // partStartTime
    //
    if (i.partStartTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "partStartTime",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.partStartTime ();
    }

    // partDuration
    //
    if (i.partDuration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "partDuration",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.partDuration ();
    }

    // partId
    //
    if (i.partId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "partId",
          e));

      a << *i.partId ();
    }

    // partName
    //
    if (i.partName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "partName",
          e));

      a << *i.partName ();
    }

    // partDefinition
    //
    if (i.partDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "partDefinition",
          e));

      a << *i.partDefinition ();
    }

    // partNumber
    //
    if (i.partNumber ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "partNumber",
          e));

      a << *i.partNumber ();
    }

    // partTotalNumber
    //
    if (i.partTotalNumber ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "partTotalNumber",
          e));

      a << *i.partTotalNumber ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const titleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // title
    //
    for (titleType::title_const_iterator
         b (i.title ().begin ()), n (i.title ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "title",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // attributiondate
    //
    if (i.attributiondate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "attributiondate",
          e));

      a << *i.attributiondate ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const alternativeTitleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // title
    //
    for (alternativeTitleType::title_const_iterator
         b (i.title ().begin ()), n (i.title ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "title",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // statusLabel
    //
    if (i.statusLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "statusLabel",
          e));

      a << *i.statusLabel ();
    }

    // statusDefinition
    //
    if (i.statusDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "statusDefinition",
          e));

      a << *i.statusDefinition ();
    }

    // statusLink
    //
    if (i.statusLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "statusLink",
          e));

      a << *i.statusLink ();
    }

    // statusLanguage
    //
    if (i.statusLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "statusLanguage",
          e));

      a << *i.statusLanguage ();
    }

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const identifierType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // identifier
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "identifier",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << i.identifier ();
    }

    // attributor
    //
    if (i.attributor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "attributor",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.attributor ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const subjectType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // subject
    //
    for (subjectType::subject_const_iterator
         b (i.subject ().begin ()), n (i.subject ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subject",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // subjectCode
    //
    if (i.subjectCode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subjectCode",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.subjectCode ();
    }

    // subjectDefinition
    //
    for (subjectType::subjectDefinition_const_iterator
         b (i.subjectDefinition ().begin ()), n (i.subjectDefinition ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subjectDefinition",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // attributor
    //
    if (i.attributor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "attributor",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.attributor ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const typeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    for (typeType::type_const_iterator
         b (i.type ().begin ()), n (i.type ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // genre
    //
    for (typeType::genre_const_iterator
         b (i.genre ().begin ()), n (i.genre ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "genre",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // objectType
    //
    for (typeType::objectType_const_iterator
         b (i.objectType ().begin ()), n (i.objectType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "objectType",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // targetAudience
    //
    for (typeType::targetAudience_const_iterator
         b (i.targetAudience ().begin ()), n (i.targetAudience ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "targetAudience",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const descriptionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // description
    //
    for (descriptionType::description_const_iterator
         b (i.description ().begin ()), n (i.description ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const coverageType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // coverage
    //
    if (i.coverage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coverage",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *i.coverage ();
    }

    // temporal
    //
    if (i.temporal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "temporal",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.temporal ();
    }

    // spatial
    //
    if (i.spatial ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spatial",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.spatial ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const locationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.name ();
    }

    // coordinates
    //
    if (i.coordinates ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coordinates",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.coordinates ();
    }

    // code
    //
    if (i.code ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "code",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.code ();
    }

    // region
    //
    if (i.region ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "region",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.region ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }

    // locationId
    //
    if (i.locationId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "locationId",
          e));

      a << *i.locationId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const periodOfTimeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // periodName
    //
    if (i.periodName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "periodName",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.periodName ();
    }

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const rightsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // rights
    //
    for (rightsType::rights_const_iterator
         b (i.rights ().begin ()), n (i.rights ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rights",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // rightsLink
    //
    if (i.rightsLink ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightsLink",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.rightsLink ();
    }

    // rightsHolder
    //
    for (rightsType::rightsHolder_const_iterator
         b (i.rightsHolder ().begin ()), n (i.rightsHolder ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightsHolder",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // exploitationIssues
    //
    for (rightsType::exploitationIssues_const_iterator
         b (i.exploitationIssues ().begin ()), n (i.exploitationIssues ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "exploitationIssues",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // copyrightStatement
    //
    for (rightsType::copyrightStatement_const_iterator
         b (i.copyrightStatement ().begin ()), n (i.copyrightStatement ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "copyrightStatement",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // coverage
    //
    if (i.coverage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "coverage",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.coverage ();
    }

    // rightsClearanceFlag
    //
    if (i.rightsClearanceFlag ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightsClearanceFlag",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.rightsClearanceFlag ();
    }

    // disclaimer
    //
    for (rightsType::disclaimer_const_iterator
         b (i.disclaimer ().begin ()), n (i.disclaimer ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "disclaimer",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // rightsAttributedId
    //
    for (rightsType::rightsAttributedId_const_iterator
         b (i.rightsAttributedId ().begin ()), n (i.rightsAttributedId ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightsAttributedId",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // contactDetails
    //
    for (rightsType::contactDetails_const_iterator
         b (i.contactDetails ().begin ()), n (i.contactDetails ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contactDetails",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }

    // formatIDRefs
    //
    if (i.formatIDRefs ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatIDRefs",
          e));

      a << *i.formatIDRefs ();
    }

    // rightsID
    //
    if (i.rightsID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rightsID",
          e));

      a << *i.rightsID ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const relationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // relation
    //
    if (i.relation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relation",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *i.relation ();
    }

    // relationIdentifier
    //
    if (i.relationIdentifier ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relationIdentifier",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.relationIdentifier ();
    }

    // relationLink
    //
    if (i.relationLink ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relationLink",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.relationLink ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // runningOrderNumber
    //
    if (i.runningOrderNumber ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "runningOrderNumber",
          e));

      a << *i.runningOrderNumber ();
    }

    // totalNumberOfGroupMembers
    //
    if (i.totalNumberOfGroupMembers ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "totalNumberOfGroupMembers",
          e));

      a << *i.totalNumberOfGroupMembers ();
    }

    // orderedGroupFlag
    //
    if (i.orderedGroupFlag ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "orderedGroupFlag",
          e));

      a << *i.orderedGroupFlag ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const languageType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // language
    //
    if (i.language ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "language",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *i.language ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dateType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // date
    //
    for (dateType::date_const_iterator
         b (i.date ().begin ()), n (i.date ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "date",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *b;
    }

    // created
    //
    if (i.created ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "created",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.created ();
    }

    // issued
    //
    if (i.issued ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "issued",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.issued ();
    }

    // modified
    //
    if (i.modified ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "modified",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.modified ();
    }

    // digitised
    //
    if (i.digitised ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "digitised",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.digitised ();
    }

    // released
    //
    if (i.released ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "released",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.released ();
    }

    // copyrighted
    //
    if (i.copyrighted ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "copyrighted",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.copyrighted ();
    }

    // alternative
    //
    for (dateType::alternative_const_iterator
         b (i.alternative ().begin ()), n (i.alternative ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alternative",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const publicationHistoryType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // publicationEvent
    //
    for (publicationHistoryType::publicationEvent_const_iterator
         b (i.publicationEvent ().begin ()), n (i.publicationEvent ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationEvent",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const publicationEventType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // publicationDate
    //
    if (i.publicationDate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationDate",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.publicationDate ();
    }

    // publicationTime
    //
    if (i.publicationTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationTime",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.publicationTime ();
    }

    // publicationService
    //
    if (i.publicationService ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationService",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.publicationService ();
    }

    // publicationMedium
    //
    if (i.publicationMedium ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationMedium",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.publicationMedium ();
    }

    // publicationChannel
    //
    if (i.publicationChannel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationChannel",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.publicationChannel ();
    }

    // publicationRegion
    //
    for (publicationEventType::publicationRegion_const_iterator
         b (i.publicationRegion ().begin ()), n (i.publicationRegion ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationRegion",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // firstShowing
    //
    if (i.firstShowing ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "firstShowing",
          e));

      a << *i.firstShowing ();
    }

    // live
    //
    if (i.live ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "live",
          e));

      a << *i.live ();
    }

    // free
    //
    if (i.free ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "free",
          e));

      a << *i.free ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }

    // formatIdRef
    //
    if (i.formatIdRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatIdRef",
          e));

      a << *i.formatIdRef ();
    }

    // rightsIDRefs
    //
    if (i.rightsIDRefs ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "rightsIDRefs",
          e));

      a << *i.rightsIDRefs ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const publicationServiceType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // publicationServiceName
    //
    if (i.publicationServiceName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationServiceName",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.publicationServiceName ();
    }

    // publicationSource
    //
    if (i.publicationSource ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "publicationSource",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.publicationSource ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const publicationMediumType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const publicationChannelType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const formatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // format
    //
    if (i.format ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "format",
          "http://purl.org/dc/elements/1.1/",
          e));

      s << *i.format ();
    }

    // medium
    //
    for (formatType::medium_const_iterator
         b (i.medium ().begin ()), n (i.medium ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "medium",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // imageFormat
    //
    for (formatType::imageFormat_const_iterator
         b (i.imageFormat ().begin ()), n (i.imageFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "imageFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // videoFormat
    //
    for (formatType::videoFormat_const_iterator
         b (i.videoFormat ().begin ()), n (i.videoFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "videoFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // audioFormat
    //
    for (formatType::audioFormat_const_iterator
         b (i.audioFormat ().begin ()), n (i.audioFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "audioFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // containerFormat
    //
    for (formatType::containerFormat_const_iterator
         b (i.containerFormat ().begin ()), n (i.containerFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "containerFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // dataFormat
    //
    for (formatType::dataFormat_const_iterator
         b (i.dataFormat ().begin ()), n (i.dataFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // signingFormat
    //
    for (formatType::signingFormat_const_iterator
         b (i.signingFormat ().begin ()), n (i.signingFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "signingFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // start
    //
    if (i.start ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "start",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.start ();
    }

    // end
    //
    if (i.end ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "end",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.end ();
    }

    // duration
    //
    if (i.duration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "duration",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.duration ();
    }

    // fileSize
    //
    if (i.fileSize ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fileSize",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.fileSize ();
    }

    // fileName
    //
    if (i.fileName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fileName",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.fileName ();
    }

    // mimeType
    //
    for (formatType::mimeType_const_iterator
         b (i.mimeType ().begin ()), n (i.mimeType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mimeType",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // locator
    //
    for (formatType::locator_const_iterator
         b (i.locator ().begin ()), n (i.locator ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "locator",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // hash
    //
    if (i.hash ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hash",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.hash ();
    }

    // documentFormat
    //
    if (i.documentFormat ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "documentFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.documentFormat ();
    }

    // technicalAttributeString
    //
    for (formatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (formatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (formatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (formatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (formatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (formatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (formatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (formatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (formatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (formatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (formatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (formatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (formatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // dateCreated
    //
    if (i.dateCreated ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dateCreated",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.dateCreated ();
    }

    // dateModified
    //
    if (i.dateModified ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dateModified",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.dateModified ();
    }

    // formatId
    //
    if (i.formatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatId",
          e));

      a << *i.formatId ();
    }

    // formatVersionId
    //
    if (i.formatVersionId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatVersionId",
          e));

      a << *i.formatVersionId ();
    }

    // formatName
    //
    if (i.formatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatName",
          e));

      a << *i.formatName ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const entityType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // contactDetails
    //
    for (entityType::contactDetails_const_iterator
         b (i.contactDetails ().begin ()), n (i.contactDetails ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contactDetails",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // organisationDetails
    //
    for (entityType::organisationDetails_const_iterator
         b (i.organisationDetails ().begin ()), n (i.organisationDetails ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "organisationDetails",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // role
    //
    for (entityType::role_const_iterator
         b (i.role ().begin ()), n (i.role ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "role",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // entityId
    //
    if (i.entityId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "entityId",
          e));

      a << *i.entityId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const contactDetailsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    for (contactDetailsType::name_const_iterator
         b (i.name ().begin ()), n (i.name ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // givenName
    //
    if (i.givenName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "givenName",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.givenName ();
    }

    // familyName
    //
    if (i.familyName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "familyName",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.familyName ();
    }

    // otherGivenName
    //
    for (contactDetailsType::otherGivenName_const_iterator
         b (i.otherGivenName ().begin ()), n (i.otherGivenName ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "otherGivenName",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // suffix
    //
    if (i.suffix ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "suffix",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.suffix ();
    }

    // salutation
    //
    if (i.salutation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "salutation",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.salutation ();
    }

    // username
    //
    for (contactDetailsType::username_const_iterator
         b (i.username ().begin ()), n (i.username ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "username",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // occupation
    //
    if (i.occupation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "occupation",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.occupation ();
    }

    // details
    //
    for (contactDetailsType::details_const_iterator
         b (i.details ().begin ()), n (i.details ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "details",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // stageName
    //
    for (contactDetailsType::stageName_const_iterator
         b (i.stageName ().begin ()), n (i.stageName ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stageName",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // guest
    //
    if (i.guest ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "guest",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.guest ();
    }

    // gender
    //
    if (i.gender ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gender",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.gender ();
    }

    // relatedInformationLink
    //
    for (contactDetailsType::relatedInformationLink_const_iterator
         b (i.relatedInformationLink ().begin ()), n (i.relatedInformationLink ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relatedInformationLink",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // relatedContacts
    //
    for (contactDetailsType::relatedContacts_const_iterator
         b (i.relatedContacts ().begin ()), n (i.relatedContacts ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relatedContacts",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // contactId
    //
    if (i.contactId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "contactId",
          e));

      a << *i.contactId ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const organisationDetailsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // organisationName
    //
    for (organisationDetailsType::organisationName_const_iterator
         b (i.organisationName ().begin ()), n (i.organisationName ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "organisationName",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // organisationCode
    //
    for (organisationDetailsType::organisationCode_const_iterator
         b (i.organisationCode ().begin ()), n (i.organisationCode ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "organisationCode",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // organisationDepartment
    //
    if (i.organisationDepartment ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "organisationDepartment",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.organisationDepartment ();
    }

    // details
    //
    for (organisationDetailsType::details_const_iterator
         b (i.details ().begin ()), n (i.details ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "details",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // relatedInformationLink
    //
    for (organisationDetailsType::relatedInformationLink_const_iterator
         b (i.relatedInformationLink ().begin ()), n (i.relatedInformationLink ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relatedInformationLink",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // contacts
    //
    for (organisationDetailsType::contacts_const_iterator
         b (i.contacts ().begin ()), n (i.contacts ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contacts",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // organisationId
    //
    if (i.organisationId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "organisationId",
          e));

      a << *i.organisationId ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const detailsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // emailAddress
    //
    for (detailsType::emailAddress_const_iterator
         b (i.emailAddress ().begin ()), n (i.emailAddress ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "emailAddress",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // webAddress
    //
    if (i.webAddress ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "webAddress",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.webAddress ();
    }

    // address
    //
    if (i.address ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "address",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.address ();
    }

    // telephoneNumber
    //
    if (i.telephoneNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "telephoneNumber",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.telephoneNumber ();
    }

    // mobileTelephoneNumber
    //
    if (i.mobileTelephoneNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mobileTelephoneNumber",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.mobileTelephoneNumber ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const addressType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // addressLine
    //
    for (addressType::addressLine_const_iterator
         b (i.addressLine ().begin ()), n (i.addressLine ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "addressLine",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // addressTownCity
    //
    if (i.addressTownCity ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "addressTownCity",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.addressTownCity ();
    }

    // addressCountyState
    //
    if (i.addressCountyState ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "addressCountyState",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.addressCountyState ();
    }

    // addressDeliveryCode
    //
    if (i.addressDeliveryCode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "addressDeliveryCode",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.addressDeliveryCode ();
    }

    // country
    //
    if (i.country ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "country",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.country ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const compoundNameType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const regionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // country
    //
    if (i.country ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "country",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.country ();
    }

    // countryRegion
    //
    for (regionType::countryRegion_const_iterator
         b (i.countryRegion ().begin ()), n (i.countryRegion ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "countryRegion",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const editUnitNumberType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >& > (i);

    // editRate
    //
    if (i.editRate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "editRate",
          e));

      a << *i.editRate ();
    }

    // factorNumerator
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factorNumerator",
          e));

      a << i.factorNumerator ();
    }

    // factorDenominator
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factorDenominator",
          e));

      a << i.factorDenominator ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ratingType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ratingValue
    //
    for (ratingType::ratingValue_const_iterator
         b (i.ratingValue ().begin ()), n (i.ratingValue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingValue",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // ratingScaleMaxValue
    //
    for (ratingType::ratingScaleMaxValue_const_iterator
         b (i.ratingScaleMaxValue ().begin ()), n (i.ratingScaleMaxValue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingScaleMaxValue",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // ratingScaleMinValue
    //
    for (ratingType::ratingScaleMinValue_const_iterator
         b (i.ratingScaleMinValue ().begin ()), n (i.ratingScaleMinValue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingScaleMinValue",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // ratingProvider
    //
    if (i.ratingProvider ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingProvider",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.ratingProvider ();
    }

    // ratingRegion
    //
    for (ratingType::ratingRegion_const_iterator
         b (i.ratingRegion ().begin ()), n (i.ratingRegion ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingRegion",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }

    // reason
    //
    if (i.reason ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "reason",
          e));

      a << *i.reason ();
    }

    // linkToLogo
    //
    if (i.linkToLogo ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "linkToLogo",
          e));

      a << *i.linkToLogo ();
    }

    // notRated
    //
    if (i.notRated ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "notRated",
          e));

      a << *i.notRated ();
    }

    // adultContent
    //
    if (i.adultContent ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "adultContent",
          e));

      a << *i.adultContent ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const lengthType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);

    // unit
    //
    if (i.unit ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << *i.unit ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dimensionType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);

    // unit
    //
    if (i.unit ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "unit",
          e));

      a << *i.unit ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const imageFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // regionDelimX
    //
    if (i.regionDelimX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimX",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.regionDelimX ();
    }

    // regionDelimY
    //
    if (i.regionDelimY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimY",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.regionDelimY ();
    }

    // width
    //
    if (i.width ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.width ();
    }

    // height
    //
    if (i.height ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "height",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.height ();
    }

    // orientation
    //
    if (i.orientation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "orientation",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.orientation ();
    }

    // aspectRatio
    //
    if (i.aspectRatio ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aspectRatio",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.aspectRatio ();
    }

    // imageEncoding
    //
    if (i.imageEncoding ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "imageEncoding",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.imageEncoding ();
    }

    // technicalAttributeString
    //
    for (imageFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (imageFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (imageFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (imageFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (imageFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (imageFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (imageFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (imageFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (imageFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (imageFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (imageFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (imageFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (imageFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // comment
    //
    for (imageFormatType::comment_const_iterator
         b (i.comment ().begin ()), n (i.comment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "comment",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // imageFormatId
    //
    if (i.imageFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "imageFormatId",
          e));

      a << *i.imageFormatId ();
    }

    // imageFormatVersionId
    //
    if (i.imageFormatVersionId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "imageFormatVersionId",
          e));

      a << *i.imageFormatVersionId ();
    }

    // imageFormatName
    //
    if (i.imageFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "imageFormatName",
          e));

      a << *i.imageFormatName ();
    }

    // imageFormatDefinition
    //
    if (i.imageFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "imageFormatDefinition",
          e));

      a << *i.imageFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const videoFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // regionDelimX
    //
    if (i.regionDelimX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimX",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.regionDelimX ();
    }

    // regionDelimY
    //
    if (i.regionDelimY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimY",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.regionDelimY ();
    }

    // width
    //
    for (videoFormatType::width_const_iterator
         b (i.width ().begin ()), n (i.width ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // height
    //
    for (videoFormatType::height_const_iterator
         b (i.height ().begin ()), n (i.height ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "height",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // lines
    //
    if (i.lines ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lines",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.lines ();
    }

    // frameRate
    //
    if (i.frameRate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "frameRate",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.frameRate ();
    }

    // aspectRatio
    //
    for (videoFormatType::aspectRatio_const_iterator
         b (i.aspectRatio ().begin ()), n (i.aspectRatio ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aspectRatio",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // videoEncoding
    //
    if (i.videoEncoding ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "videoEncoding",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.videoEncoding ();
    }

    // codec
    //
    if (i.codec ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "codec",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.codec ();
    }

    // bitRate
    //
    if (i.bitRate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bitRate",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.bitRate ();
    }

    // bitRateMax
    //
    if (i.bitRateMax ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bitRateMax",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.bitRateMax ();
    }

    // bitRateMode
    //
    if (i.bitRateMode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bitRateMode",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.bitRateMode ();
    }

    // scanningFormat
    //
    if (i.scanningFormat ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scanningFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.scanningFormat ();
    }

    // scanningOrder
    //
    if (i.scanningOrder ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scanningOrder",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.scanningOrder ();
    }

    // noiseFilter
    //
    if (i.noiseFilter ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "noiseFilter",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.noiseFilter ();
    }

    // videoTrack
    //
    for (videoFormatType::videoTrack_const_iterator
         b (i.videoTrack ().begin ()), n (i.videoTrack ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "videoTrack",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // flag_3D
    //
    if (i.flag_3D ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flag_3D",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.flag_3D ();
    }

    // technicalAttributeString
    //
    for (videoFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (videoFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (videoFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (videoFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (videoFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (videoFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (videoFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (videoFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (videoFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (videoFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (videoFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (videoFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (videoFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // comment
    //
    for (videoFormatType::comment_const_iterator
         b (i.comment ().begin ()), n (i.comment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "comment",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // videoFormatId
    //
    if (i.videoFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "videoFormatId",
          e));

      a << *i.videoFormatId ();
    }

    // videoFormatVersionId
    //
    if (i.videoFormatVersionId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "videoFormatVersionId",
          e));

      a << *i.videoFormatVersionId ();
    }

    // videoFormatName
    //
    if (i.videoFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "videoFormatName",
          e));

      a << *i.videoFormatName ();
    }

    // videoFormatDefinition
    //
    if (i.videoFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "videoFormatDefinition",
          e));

      a << *i.videoFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const audioFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // audioEncoding
    //
    if (i.audioEncoding ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "audioEncoding",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.audioEncoding ();
    }

    // codec
    //
    if (i.codec ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "codec",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.codec ();
    }

    // audioTrackConfiguration
    //
    if (i.audioTrackConfiguration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "audioTrackConfiguration",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.audioTrackConfiguration ();
    }

    // samplingRate
    //
    if (i.samplingRate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "samplingRate",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.samplingRate ();
    }

    // sampleSize
    //
    if (i.sampleSize ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sampleSize",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.sampleSize ();
    }

    // sampleType
    //
    if (i.sampleType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sampleType",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.sampleType ();
    }

    // bitRate
    //
    if (i.bitRate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bitRate",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.bitRate ();
    }

    // bitRateMax
    //
    if (i.bitRateMax ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bitRateMax",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.bitRateMax ();
    }

    // bitRateMode
    //
    if (i.bitRateMode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bitRateMode",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.bitRateMode ();
    }

    // audioTrack
    //
    for (audioFormatType::audioTrack_const_iterator
         b (i.audioTrack ().begin ()), n (i.audioTrack ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "audioTrack",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // channels
    //
    if (i.channels ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channels",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.channels ();
    }

    // technicalAttributeString
    //
    for (audioFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (audioFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (audioFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (audioFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (audioFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (audioFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (audioFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (audioFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (audioFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (audioFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (audioFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (audioFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (audioFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // comment
    //
    for (audioFormatType::comment_const_iterator
         b (i.comment ().begin ()), n (i.comment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "comment",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // audioFormatId
    //
    if (i.audioFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "audioFormatId",
          e));

      a << *i.audioFormatId ();
    }

    // audioFormatVersionId
    //
    if (i.audioFormatVersionId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "audioFormatVersionId",
          e));

      a << *i.audioFormatVersionId ();
    }

    // audioFormatName
    //
    if (i.audioFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "audioFormatName",
          e));

      a << *i.audioFormatName ();
    }

    // audioFormatDefinition
    //
    if (i.audioFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "audioFormatDefinition",
          e));

      a << *i.audioFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dataFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // captioningFormat
    //
    for (dataFormatType::captioningFormat_const_iterator
         b (i.captioningFormat ().begin ()), n (i.captioningFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "captioningFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // subtitlingFormat
    //
    for (dataFormatType::subtitlingFormat_const_iterator
         b (i.subtitlingFormat ().begin ()), n (i.subtitlingFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subtitlingFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // ancillaryDataFormat
    //
    for (dataFormatType::ancillaryDataFormat_const_iterator
         b (i.ancillaryDataFormat ().begin ()), n (i.ancillaryDataFormat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ancillaryDataFormat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeString
    //
    for (dataFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (dataFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (dataFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (dataFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (dataFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (dataFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (dataFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (dataFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (dataFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (dataFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (dataFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (dataFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (dataFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // comment
    //
    for (dataFormatType::comment_const_iterator
         b (i.comment ().begin ()), n (i.comment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "comment",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // dataFormatId
    //
    if (i.dataFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataFormatId",
          e));

      a << *i.dataFormatId ();
    }

    // dataFormatVersionId
    //
    if (i.dataFormatVersionId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataFormatVersionId",
          e));

      a << *i.dataFormatVersionId ();
    }

    // dataFormatName
    //
    if (i.dataFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataFormatName",
          e));

      a << *i.dataFormatName ();
    }

    // dataFormatDefinition
    //
    if (i.dataFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataFormatDefinition",
          e));

      a << *i.dataFormatDefinition ();
    }

    // dataTrackId
    //
    if (i.dataTrackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataTrackId",
          e));

      a << *i.dataTrackId ();
    }

    // dataTrackName
    //
    if (i.dataTrackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataTrackName",
          e));

      a << *i.dataTrackName ();
    }

    // dataTrackLanguage
    //
    if (i.dataTrackLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dataTrackLanguage",
          e));

      a << *i.dataTrackLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const documentFormatType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // wordCount
    //
    if (i.wordCount ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "wordCount",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.wordCount ();
    }

    // regionDelimX
    //
    if (i.regionDelimX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimX",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.regionDelimX ();
    }

    // regionDelimY
    //
    if (i.regionDelimY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "regionDelimY",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.regionDelimY ();
    }

    // width
    //
    if (i.width ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.width ();
    }

    // height
    //
    if (i.height ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "height",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.height ();
    }

    // technicalAttributeString
    //
    for (documentFormatType::technicalAttributeString_const_iterator
         b (i.technicalAttributeString ().begin ()), n (i.technicalAttributeString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeString",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeByte
    //
    for (documentFormatType::technicalAttributeByte_const_iterator
         b (i.technicalAttributeByte ().begin ()), n (i.technicalAttributeByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeShort
    //
    for (documentFormatType::technicalAttributeShort_const_iterator
         b (i.technicalAttributeShort ().begin ()), n (i.technicalAttributeShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeInteger
    //
    for (documentFormatType::technicalAttributeInteger_const_iterator
         b (i.technicalAttributeInteger ().begin ()), n (i.technicalAttributeInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeLong
    //
    for (documentFormatType::technicalAttributeLong_const_iterator
         b (i.technicalAttributeLong ().begin ()), n (i.technicalAttributeLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedByte
    //
    for (documentFormatType::technicalAttributeUnsignedByte_const_iterator
         b (i.technicalAttributeUnsignedByte ().begin ()), n (i.technicalAttributeUnsignedByte ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedByte",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedShort
    //
    for (documentFormatType::technicalAttributeUnsignedShort_const_iterator
         b (i.technicalAttributeUnsignedShort ().begin ()), n (i.technicalAttributeUnsignedShort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedShort",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedInteger
    //
    for (documentFormatType::technicalAttributeUnsignedInteger_const_iterator
         b (i.technicalAttributeUnsignedInteger ().begin ()), n (i.technicalAttributeUnsignedInteger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedInteger",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUnsignedLong
    //
    for (documentFormatType::technicalAttributeUnsignedLong_const_iterator
         b (i.technicalAttributeUnsignedLong ().begin ()), n (i.technicalAttributeUnsignedLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUnsignedLong",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeBoolean
    //
    for (documentFormatType::technicalAttributeBoolean_const_iterator
         b (i.technicalAttributeBoolean ().begin ()), n (i.technicalAttributeBoolean ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeBoolean",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeFloat
    //
    for (documentFormatType::technicalAttributeFloat_const_iterator
         b (i.technicalAttributeFloat ().begin ()), n (i.technicalAttributeFloat ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeFloat",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeRational
    //
    for (documentFormatType::technicalAttributeRational_const_iterator
         b (i.technicalAttributeRational ().begin ()), n (i.technicalAttributeRational ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeRational",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // technicalAttributeUri
    //
    for (documentFormatType::technicalAttributeUri_const_iterator
         b (i.technicalAttributeUri ().begin ()), n (i.technicalAttributeUri ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "technicalAttributeUri",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // comment
    //
    for (documentFormatType::comment_const_iterator
         b (i.comment ().begin ()), n (i.comment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "comment",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // documentFormatId
    //
    if (i.documentFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentFormatId",
          e));

      a << *i.documentFormatId ();
    }

    // documentFormatVersionId
    //
    if (i.documentFormatVersionId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentFormatVersionId",
          e));

      a << *i.documentFormatVersionId ();
    }

    // documentFormatName
    //
    if (i.documentFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentFormatName",
          e));

      a << *i.documentFormatName ();
    }

    // documentFormatDefinition
    //
    if (i.documentFormatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "documentFormatDefinition",
          e));

      a << *i.documentFormatDefinition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const codecType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // codecIdentifier
    //
    if (i.codecIdentifier ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "codecIdentifier",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.codecIdentifier ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.name ();
    }

    // vendor
    //
    if (i.vendor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vendor",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.vendor ();
    }

    // version
    //
    if (i.version ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "version",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.version ();
    }

    // family
    //
    if (i.family ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "family",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.family ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const timeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // timecode
    //
    if (i.timecode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timecode",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.timecode ();
    }

    // normalPlayTime
    //
    if (i.normalPlayTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "normalPlayTime",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.normalPlayTime ();
    }

    // editUnitNumber
    //
    if (i.editUnitNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "editUnitNumber",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.editUnitNumber ();
    }

    // time
    //
    if (i.time ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "time",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.time ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const durationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // timecode
    //
    if (i.timecode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timecode",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.timecode ();
    }

    // normalPlayTime
    //
    if (i.normalPlayTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "normalPlayTime",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.normalPlayTime ();
    }

    // editUnitNumber
    //
    if (i.editUnitNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "editUnitNumber",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.editUnitNumber ();
    }

    // duration
    //
    if (i.duration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "duration",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.duration ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const hashType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // hashValue
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hashValue",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << i.hashValue ();
    }

    // hashFunction
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hashFunction",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << i.hashFunction ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const String& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Boolean& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Float& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Int8& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Int16& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Int32& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Int64& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UInt8& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UInt16& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UInt32& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UInt64& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type >& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const rationalType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >& > (i);

    // factorNumerator
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factorNumerator",
          e));

      a << i.factorNumerator ();
    }

    // factorDenominator
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factorDenominator",
          e));

      a << i.factorDenominator ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const aspectRatioType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // factorNumerator
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "factorNumerator",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << i.factorNumerator ();
    }

    // factorDenominator
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "factorDenominator",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << i.factorDenominator ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const technicalAttributeRationalType& i)
  {
    e << static_cast< const ::ebuCore_2012::rationalType& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const technicalAttributeUriType& i)
  {
    e << static_cast< const ::xml_schema::uri& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const versionType& i)
  {
    e << static_cast< const ::dc::elementType& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const hasTrackPart& i)
  {
    e << static_cast< const ::ebuCore_2012::relationType& > (i);

    // trackPartTitle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trackPartTitle",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << i.trackPartTitle ();
    }

    // destinationId
    //
    if (i.destinationId ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "destinationId",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.destinationId ();
    }

    // destinationStart
    //
    if (i.destinationStart ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "destinationStart",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.destinationStart ();
    }

    // destinationEnd
    //
    if (i.destinationEnd ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "destinationEnd",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.destinationEnd ();
    }

    // sourceId
    //
    if (i.sourceId ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sourceId",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.sourceId ();
    }

    // sourceStart
    //
    if (i.sourceStart ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sourceStart",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.sourceStart ();
    }

    // sourceEnd
    //
    if (i.sourceEnd ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sourceEnd",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.sourceEnd ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const genre& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const objectType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const targetAudience& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // targetRegion
    //
    for (targetAudience::targetRegion_const_iterator
         b (i.targetRegion ().begin ()), n (i.targetRegion ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "targetRegion",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // reason
    //
    if (i.reason ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "reason",
          e));

      a << *i.reason ();
    }

    // linkToLogo
    //
    if (i.linkToLogo ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "linkToLogo",
          e));

      a << *i.linkToLogo ();
    }

    // notRated
    //
    if (i.notRated ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "notRated",
          e));

      a << *i.notRated ();
    }

    // adultContent
    //
    if (i.adultContent ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "adultContent",
          e));

      a << *i.adultContent ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const temporal& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // PeriodOfTime
    //
    for (temporal::PeriodOfTime_const_iterator
         b (i.PeriodOfTime ().begin ()), n (i.PeriodOfTime ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PeriodOfTime",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // note
    //
    if (i.note ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "note",
          e));

      a << *i.note ();
    }

    // periodId
    //
    if (i.periodId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "periodId",
          e));

      a << *i.periodId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const spatial& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // location
    //
    for (spatial::location_const_iterator
         b (i.location ().begin ()), n (i.location ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "location",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const coordinates& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // posy
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "posy",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << i.posy ();
    }

    // posx
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "posx",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << i.posx ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const created& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const issued& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const modified& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const digitised& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const released& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const copyrighted& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const alternative& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const medium& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // mediumId
    //
    if (i.mediumId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mediumId",
          e));

      a << *i.mediumId ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const containerFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // comment
    //
    for (containerFormat::comment_const_iterator
         b (i.comment ().begin ()), n (i.comment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "comment",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const signingFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // signingFormatId
    //
    if (i.signingFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "signingFormatId",
          e));

      a << *i.signingFormatId ();
    }

    // signingFormatVersionId
    //
    if (i.signingFormatVersionId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "signingFormatVersionId",
          e));

      a << *i.signingFormatVersionId ();
    }

    // signingFormatName
    //
    if (i.signingFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "signingFormatName",
          e));

      a << *i.signingFormatName ();
    }

    // trackId
    //
    if (i.trackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackId",
          e));

      a << *i.trackId ();
    }

    // trackName
    //
    if (i.trackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackName",
          e));

      a << *i.trackName ();
    }

    // signingSourceUri
    //
    if (i.signingSourceUri ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "signingSourceUri",
          e));

      a << *i.signingSourceUri ();
    }

    // language
    //
    if (i.language ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "language",
          e));

      a << *i.language ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dateCreated& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dateModified& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // startYear
    //
    if (i.startYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startYear",
          e));

      a << *i.startYear ();
    }

    // startDate
    //
    if (i.startDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startDate",
          e));

      a << *i.startDate ();
    }

    // startTime
    //
    if (i.startTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startTime",
          e));

      a << *i.startTime ();
    }

    // endYear
    //
    if (i.endYear ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endYear",
          e));

      a << *i.endYear ();
    }

    // endDate
    //
    if (i.endDate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endDate",
          e));

      a << *i.endDate ();
    }

    // endTime
    //
    if (i.endTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "endTime",
          e));

      a << *i.endTime ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const role& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // costCentre
    //
    if (i.costCentre ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "costCentre",
          e));

      a << *i.costCentre ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const relatedInformationLink& i)
  {
    e << static_cast< const ::xml_schema::uri& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const organisationDepartment& i)
  {
    e << static_cast< const ::dc::elementType& > (i);

    // departmentId
    //
    if (i.departmentId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "departmentId",
          e));

      a << *i.departmentId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const relatedInformationLink1& i)
  {
    e << static_cast< const ::xml_schema::uri& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const country& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const country1& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const countryRegion& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const orientation& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const orientation& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const orientation& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const imageEncoding& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const comment& i)
  {
    e << static_cast< const ::dc::elementType& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const width& i)
  {
    e << static_cast< const ::ebuCore_2012::dimensionType& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const height& i)
  {
    e << static_cast< const ::ebuCore_2012::dimensionType& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const videoEncoding& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const bitRateMode& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const bitRateMode& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const bitRateMode& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const scanningFormat& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const scanningFormat& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const scanningFormat& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const scanningOrder& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const scanningOrder& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const scanningOrder& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const videoTrack& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // trackId
    //
    if (i.trackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackId",
          e));

      a << *i.trackId ();
    }

    // trackName
    //
    if (i.trackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackName",
          e));

      a << *i.trackName ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const comment1& i)
  {
    e << static_cast< const ::dc::elementType& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const audioEncoding& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const audioTrackConfiguration& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const sampleType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const sampleType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const sampleType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const bitRateMode1& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const bitRateMode1& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const bitRateMode1& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const audioTrack& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // trackLanguage
    //
    if (i.trackLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackLanguage",
          e));

      a << *i.trackLanguage ();
    }

    // trackId
    //
    if (i.trackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackId",
          e));

      a << *i.trackId ();
    }

    // trackName
    //
    if (i.trackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackName",
          e));

      a << *i.trackName ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const comment2& i)
  {
    e << static_cast< const ::dc::elementType& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const captioningFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // captioningFormatId
    //
    if (i.captioningFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "captioningFormatId",
          e));

      a << *i.captioningFormatId ();
    }

    // captioningFormatName
    //
    if (i.captioningFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "captioningFormatName",
          e));

      a << *i.captioningFormatName ();
    }

    // trackId
    //
    if (i.trackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackId",
          e));

      a << *i.trackId ();
    }

    // trackName
    //
    if (i.trackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackName",
          e));

      a << *i.trackName ();
    }

    // captioningSourceUri
    //
    if (i.captioningSourceUri ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "captioningSourceUri",
          e));

      a << *i.captioningSourceUri ();
    }

    // language
    //
    if (i.language ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "language",
          e));

      a << *i.language ();
    }

    // closed
    //
    if (i.closed ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "closed",
          e));

      a << *i.closed ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const subtitlingFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // subtitlingFormatId
    //
    if (i.subtitlingFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "subtitlingFormatId",
          e));

      a << *i.subtitlingFormatId ();
    }

    // subtitlingFormatName
    //
    if (i.subtitlingFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "subtitlingFormatName",
          e));

      a << *i.subtitlingFormatName ();
    }

    // trackId
    //
    if (i.trackId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackId",
          e));

      a << *i.trackId ();
    }

    // trackName
    //
    if (i.trackName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "trackName",
          e));

      a << *i.trackName ();
    }

    // subtitlingSourceUri
    //
    if (i.subtitlingSourceUri ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "subtitlingSourceUri",
          e));

      a << *i.subtitlingSourceUri ();
    }

    // language
    //
    if (i.language ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "language",
          e));

      a << *i.language ();
    }

    // closed
    //
    if (i.closed ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "closed",
          e));

      a << *i.closed ();
    }

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ancillaryDataFormat& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // DID
    //
    if (i.DID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DID",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.DID ();
    }

    // SDID
    //
    if (i.SDID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SDID",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.SDID ();
    }

    // lineNumber
    //
    for (ancillaryDataFormat::lineNumber_const_iterator
         b (i.lineNumber ().begin ()), n (i.lineNumber ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lineNumber",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *b;
    }

    // wrappingType
    //
    if (i.wrappingType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "wrappingType",
          "urn:ebu:metadata-schema:ebuCore_2012",
          e));

      s << *i.wrappingType ();
    }

    // ancillaryDataFormatId
    //
    if (i.ancillaryDataFormatId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ancillaryDataFormatId",
          e));

      a << *i.ancillaryDataFormatId ();
    }

    // ancillaryDataFormatName
    //
    if (i.ancillaryDataFormatName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ancillaryDataFormatName",
          e));

      a << *i.ancillaryDataFormatName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const comment3& i)
  {
    e << static_cast< const ::dc::elementType& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const comment4& i)
  {
    e << static_cast< const ::dc::elementType& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const timecode& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const timecode& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const timecode& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const time& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const timecode1& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const timecode1& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const timecode1& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const duration& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    // formatLabel
    //
    if (i.formatLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLabel",
          e));

      a << *i.formatLabel ();
    }

    // formatDefinition
    //
    if (i.formatDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatDefinition",
          e));

      a << *i.formatDefinition ();
    }

    // formatLink
    //
    if (i.formatLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLink",
          e));

      a << *i.formatLink ();
    }

    // formatLanguage
    //
    if (i.formatLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formatLanguage",
          e));

      a << *i.formatLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const hashFunction& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const mimeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const locator& i)
  {
    e << static_cast< const ::xml_schema::uri& > (i);

    // typeLabel
    //
    if (i.typeLabel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLabel",
          e));

      a << *i.typeLabel ();
    }

    // typeDefinition
    //
    if (i.typeDefinition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeDefinition",
          e));

      a << *i.typeDefinition ();
    }

    // typeLink
    //
    if (i.typeLink ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLink",
          e));

      a << *i.typeLink ();
    }

    // typeLanguage
    //
    if (i.typeLanguage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "typeLanguage",
          e));

      a << *i.typeLanguage ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

