// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef C__CODE_EBU_SDK_DOCUMENTATION_EBU_CORE_XSD_EBU_CORE_20110915_HXX
#define C__CODE_EBU_SDK_DOCUMENTATION_EBU_CORE_XSD_EBU_CORE_20110915_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace ebuCore_2011
{
  class ebuCoreMainType;
  class coreMetadataType;
  class titleType;
  class alternativeTitleType;
  class identifierType;
  class subjectType;
  class typeType;
  class descriptionType;
  class coverageType;
  class rightsType;
  class formatType;
  class relationType;
  class languageType;
  class dateType;
  class publicationHistoryType;
  class entityType;
  class contactDetailsType;
  class organisationDetailsType;
  class detailsType;
  class addressType;
  class editUnitNumberType;
  class ratingType;
  class lengthType;
  class imageFormatType;
  class videoFormatType;
  class audioFormatType;
  class dataFormatType;
  class documentFormatType;
  class timeType;
  class durationType;
  class String;
  class Boolean;
  class Float;
  class Int8;
  class Int16;
  class Int32;
  class Int64;
  class UInt8;
  class UInt16;
  class UInt32;
  class UInt64;
  class technicalAttributeRationalType;
  class technicalAttributeUriType;
  class hasTrackPart;
  class part;
  class genre;
  class objectType;
  class targetAudience;
  class temporal;
  class spatial;
  class medium;
  class mimeType;
  class containerFormat;
  class signingFormat;
  class locator;
  class dateCreated;
  class dateModified;
  class created;
  class issued;
  class modified;
  class digitised;
  class alternative;
  class firstPublicationChannel;
  class repeatChannel;
  class role;
  class organisationDepartment;
  class country;
  class orientation;
  class imageEncoding;
  class aspectRatio;
  class videoEncoding;
  class videoTrack;
  class audioEncoding;
  class audioTrackConfiguration;
  class audioTrack;
  class captioningFormat;
  class ancillaryDataFormat;
  class timecode;
  class time;
  class timecode1;
  class time1;
  class PeriodOfTime;
  class location;
  class coordinates;
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "xml.hxx"

#include "simpledc20021212.hxx"

namespace ebuCore_2011
{
  class ebuCoreMainType: public ::xml_schema::type
  {
    public:
    // coreMetadata
    // 
    typedef ::ebuCore_2011::coreMetadataType coreMetadata_type;
    typedef ::xsd::cxx::tree::traits< coreMetadata_type, char > coreMetadata_traits;

    const coreMetadata_type&
    coreMetadata () const;

    coreMetadata_type&
    coreMetadata ();

    void
    coreMetadata (const coreMetadata_type& x);

    void
    coreMetadata (::std::auto_ptr< coreMetadata_type > p);

    // metadataProvider
    // 
    typedef ::ebuCore_2011::entityType metadataProvider_type;
    typedef ::xsd::cxx::tree::optional< metadataProvider_type > metadataProvider_optional;
    typedef ::xsd::cxx::tree::traits< metadataProvider_type, char > metadataProvider_traits;

    const metadataProvider_optional&
    metadataProvider () const;

    metadataProvider_optional&
    metadataProvider ();

    void
    metadataProvider (const metadataProvider_type& x);

    void
    metadataProvider (const metadataProvider_optional& x);

    void
    metadataProvider (::std::auto_ptr< metadataProvider_type > p);

    // schema
    // 
    typedef ::xml_schema::simple_type schema_type;
    typedef ::xsd::cxx::tree::traits< schema_type, char > schema_traits;

    const schema_type&
    schema () const;

    schema_type&
    schema ();

    void
    schema (const schema_type& x);

    void
    schema (::std::auto_ptr< schema_type > p);

    static const schema_type&
    schema_default_value ();

    // version
    // 
    typedef ::xml_schema::simple_type version_type;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_type&
    version () const;

    version_type&
    version ();

    void
    version (const version_type& x);

    void
    version (::std::auto_ptr< version_type > p);

    static const version_type&
    version_default_value ();

    // dateLastModified
    // 
    typedef ::xml_schema::date dateLastModified_type;
    typedef ::xsd::cxx::tree::optional< dateLastModified_type > dateLastModified_optional;
    typedef ::xsd::cxx::tree::traits< dateLastModified_type, char > dateLastModified_traits;

    const dateLastModified_optional&
    dateLastModified () const;

    dateLastModified_optional&
    dateLastModified ();

    void
    dateLastModified (const dateLastModified_type& x);

    void
    dateLastModified (const dateLastModified_optional& x);

    void
    dateLastModified (::std::auto_ptr< dateLastModified_type > p);

    // documentId
    // 
    typedef ::xml_schema::nmtoken documentId_type;
    typedef ::xsd::cxx::tree::optional< documentId_type > documentId_optional;
    typedef ::xsd::cxx::tree::traits< documentId_type, char > documentId_traits;

    const documentId_optional&
    documentId () const;

    documentId_optional&
    documentId ();

    void
    documentId (const documentId_type& x);

    void
    documentId (const documentId_optional& x);

    void
    documentId (::std::auto_ptr< documentId_type > p);

    // lang
    // 
    typedef ::xml_schema::language lang_type;
    typedef ::xsd::cxx::tree::optional< lang_type > lang_optional;
    typedef ::xsd::cxx::tree::traits< lang_type, char > lang_traits;

    const lang_optional&
    lang () const;

    lang_optional&
    lang ();

    void
    lang (const lang_type& x);

    void
    lang (const lang_optional& x);

    void
    lang (::std::auto_ptr< lang_type > p);

    // Constructors.
    //
    ebuCoreMainType (const coreMetadata_type&);

    ebuCoreMainType (::std::auto_ptr< coreMetadata_type >&);

    ebuCoreMainType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    ebuCoreMainType (const ebuCoreMainType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual ebuCoreMainType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ebuCoreMainType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< coreMetadata_type > coreMetadata_;
    metadataProvider_optional metadataProvider_;
    ::xsd::cxx::tree::one< schema_type > schema_;
    static const schema_type schema_default_value_;
    ::xsd::cxx::tree::one< version_type > version_;
    static const version_type version_default_value_;
    dateLastModified_optional dateLastModified_;
    documentId_optional documentId_;
    lang_optional lang_;
  };

  class coreMetadataType: public ::xml_schema::type
  {
    public:
    // title
    // 
    typedef ::ebuCore_2011::titleType title_type;
    typedef ::xsd::cxx::tree::sequence< title_type > title_sequence;
    typedef title_sequence::iterator title_iterator;
    typedef title_sequence::const_iterator title_const_iterator;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_sequence&
    title () const;

    title_sequence&
    title ();

    void
    title (const title_sequence& s);

    // alternativeTitle
    // 
    typedef ::ebuCore_2011::alternativeTitleType alternativeTitle_type;
    typedef ::xsd::cxx::tree::sequence< alternativeTitle_type > alternativeTitle_sequence;
    typedef alternativeTitle_sequence::iterator alternativeTitle_iterator;
    typedef alternativeTitle_sequence::const_iterator alternativeTitle_const_iterator;
    typedef ::xsd::cxx::tree::traits< alternativeTitle_type, char > alternativeTitle_traits;

    const alternativeTitle_sequence&
    alternativeTitle () const;

    alternativeTitle_sequence&
    alternativeTitle ();

    void
    alternativeTitle (const alternativeTitle_sequence& s);

    // creator
    // 
    typedef ::ebuCore_2011::entityType creator_type;
    typedef ::xsd::cxx::tree::sequence< creator_type > creator_sequence;
    typedef creator_sequence::iterator creator_iterator;
    typedef creator_sequence::const_iterator creator_const_iterator;
    typedef ::xsd::cxx::tree::traits< creator_type, char > creator_traits;

    const creator_sequence&
    creator () const;

    creator_sequence&
    creator ();

    void
    creator (const creator_sequence& s);

    // subject
    // 
    typedef ::ebuCore_2011::subjectType subject_type;
    typedef ::xsd::cxx::tree::sequence< subject_type > subject_sequence;
    typedef subject_sequence::iterator subject_iterator;
    typedef subject_sequence::const_iterator subject_const_iterator;
    typedef ::xsd::cxx::tree::traits< subject_type, char > subject_traits;

    const subject_sequence&
    subject () const;

    subject_sequence&
    subject ();

    void
    subject (const subject_sequence& s);

    // description
    // 
    typedef ::ebuCore_2011::descriptionType description_type;
    typedef ::xsd::cxx::tree::sequence< description_type > description_sequence;
    typedef description_sequence::iterator description_iterator;
    typedef description_sequence::const_iterator description_const_iterator;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_sequence&
    description () const;

    description_sequence&
    description ();

    void
    description (const description_sequence& s);

    // publisher
    // 
    typedef ::ebuCore_2011::entityType publisher_type;
    typedef ::xsd::cxx::tree::sequence< publisher_type > publisher_sequence;
    typedef publisher_sequence::iterator publisher_iterator;
    typedef publisher_sequence::const_iterator publisher_const_iterator;
    typedef ::xsd::cxx::tree::traits< publisher_type, char > publisher_traits;

    const publisher_sequence&
    publisher () const;

    publisher_sequence&
    publisher ();

    void
    publisher (const publisher_sequence& s);

    // contributor
    // 
    typedef ::ebuCore_2011::entityType contributor_type;
    typedef ::xsd::cxx::tree::sequence< contributor_type > contributor_sequence;
    typedef contributor_sequence::iterator contributor_iterator;
    typedef contributor_sequence::const_iterator contributor_const_iterator;
    typedef ::xsd::cxx::tree::traits< contributor_type, char > contributor_traits;

    const contributor_sequence&
    contributor () const;

    contributor_sequence&
    contributor ();

    void
    contributor (const contributor_sequence& s);

    // date
    // 
    typedef ::ebuCore_2011::dateType date_type;
    typedef ::xsd::cxx::tree::sequence< date_type > date_sequence;
    typedef date_sequence::iterator date_iterator;
    typedef date_sequence::const_iterator date_const_iterator;
    typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

    const date_sequence&
    date () const;

    date_sequence&
    date ();

    void
    date (const date_sequence& s);

    // type
    // 
    typedef ::ebuCore_2011::typeType type_type;
    typedef ::xsd::cxx::tree::sequence< type_type > type_sequence;
    typedef type_sequence::iterator type_iterator;
    typedef type_sequence::const_iterator type_const_iterator;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_sequence&
    type () const;

    type_sequence&
    type ();

    void
    type (const type_sequence& s);

    // format
    // 
    typedef ::ebuCore_2011::formatType format_type;
    typedef ::xsd::cxx::tree::sequence< format_type > format_sequence;
    typedef format_sequence::iterator format_iterator;
    typedef format_sequence::const_iterator format_const_iterator;
    typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

    const format_sequence&
    format () const;

    format_sequence&
    format ();

    void
    format (const format_sequence& s);

    // identifier
    // 
    typedef ::ebuCore_2011::identifierType identifier_type;
    typedef ::xsd::cxx::tree::sequence< identifier_type > identifier_sequence;
    typedef identifier_sequence::iterator identifier_iterator;
    typedef identifier_sequence::const_iterator identifier_const_iterator;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_sequence&
    identifier () const;

    identifier_sequence&
    identifier ();

    void
    identifier (const identifier_sequence& s);

    // source
    // 
    typedef ::dc::elementType source_type;
    typedef ::xsd::cxx::tree::sequence< source_type > source_sequence;
    typedef source_sequence::iterator source_iterator;
    typedef source_sequence::const_iterator source_const_iterator;
    typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

    const source_sequence&
    source () const;

    source_sequence&
    source ();

    void
    source (const source_sequence& s);

    // language
    // 
    typedef ::ebuCore_2011::languageType language_type;
    typedef ::xsd::cxx::tree::sequence< language_type > language_sequence;
    typedef language_sequence::iterator language_iterator;
    typedef language_sequence::const_iterator language_const_iterator;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_sequence&
    language () const;

    language_sequence&
    language ();

    void
    language (const language_sequence& s);

    // relation
    // 
    typedef ::ebuCore_2011::relationType relation_type;
    typedef ::xsd::cxx::tree::sequence< relation_type > relation_sequence;
    typedef relation_sequence::iterator relation_iterator;
    typedef relation_sequence::const_iterator relation_const_iterator;
    typedef ::xsd::cxx::tree::traits< relation_type, char > relation_traits;

    const relation_sequence&
    relation () const;

    relation_sequence&
    relation ();

    void
    relation (const relation_sequence& s);

    // isVersionOf
    // 
    typedef ::ebuCore_2011::relationType isVersionOf_type;
    typedef ::xsd::cxx::tree::sequence< isVersionOf_type > isVersionOf_sequence;
    typedef isVersionOf_sequence::iterator isVersionOf_iterator;
    typedef isVersionOf_sequence::const_iterator isVersionOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isVersionOf_type, char > isVersionOf_traits;

    const isVersionOf_sequence&
    isVersionOf () const;

    isVersionOf_sequence&
    isVersionOf ();

    void
    isVersionOf (const isVersionOf_sequence& s);

    // hasVersion
    // 
    typedef ::ebuCore_2011::relationType hasVersion_type;
    typedef ::xsd::cxx::tree::sequence< hasVersion_type > hasVersion_sequence;
    typedef hasVersion_sequence::iterator hasVersion_iterator;
    typedef hasVersion_sequence::const_iterator hasVersion_const_iterator;
    typedef ::xsd::cxx::tree::traits< hasVersion_type, char > hasVersion_traits;

    const hasVersion_sequence&
    hasVersion () const;

    hasVersion_sequence&
    hasVersion ();

    void
    hasVersion (const hasVersion_sequence& s);

    // isReplacedBy
    // 
    typedef ::ebuCore_2011::relationType isReplacedBy_type;
    typedef ::xsd::cxx::tree::sequence< isReplacedBy_type > isReplacedBy_sequence;
    typedef isReplacedBy_sequence::iterator isReplacedBy_iterator;
    typedef isReplacedBy_sequence::const_iterator isReplacedBy_const_iterator;
    typedef ::xsd::cxx::tree::traits< isReplacedBy_type, char > isReplacedBy_traits;

    const isReplacedBy_sequence&
    isReplacedBy () const;

    isReplacedBy_sequence&
    isReplacedBy ();

    void
    isReplacedBy (const isReplacedBy_sequence& s);

    // replaces
    // 
    typedef ::ebuCore_2011::relationType replaces_type;
    typedef ::xsd::cxx::tree::sequence< replaces_type > replaces_sequence;
    typedef replaces_sequence::iterator replaces_iterator;
    typedef replaces_sequence::const_iterator replaces_const_iterator;
    typedef ::xsd::cxx::tree::traits< replaces_type, char > replaces_traits;

    const replaces_sequence&
    replaces () const;

    replaces_sequence&
    replaces ();

    void
    replaces (const replaces_sequence& s);

    // isRequiredBy
    // 
    typedef ::ebuCore_2011::relationType isRequiredBy_type;
    typedef ::xsd::cxx::tree::sequence< isRequiredBy_type > isRequiredBy_sequence;
    typedef isRequiredBy_sequence::iterator isRequiredBy_iterator;
    typedef isRequiredBy_sequence::const_iterator isRequiredBy_const_iterator;
    typedef ::xsd::cxx::tree::traits< isRequiredBy_type, char > isRequiredBy_traits;

    const isRequiredBy_sequence&
    isRequiredBy () const;

    isRequiredBy_sequence&
    isRequiredBy ();

    void
    isRequiredBy (const isRequiredBy_sequence& s);

    // requires
    // 
    typedef ::ebuCore_2011::relationType requires_type;
    typedef ::xsd::cxx::tree::sequence< requires_type > requires_sequence;
    typedef requires_sequence::iterator requires_iterator;
    typedef requires_sequence::const_iterator requires_const_iterator;
    typedef ::xsd::cxx::tree::traits< requires_type, char > requires_traits;

    const requires_sequence&
    requires () const;

    requires_sequence&
    requires ();

    void
    requires (const requires_sequence& s);

    // isPartOf
    // 
    typedef ::ebuCore_2011::relationType isPartOf_type;
    typedef ::xsd::cxx::tree::sequence< isPartOf_type > isPartOf_sequence;
    typedef isPartOf_sequence::iterator isPartOf_iterator;
    typedef isPartOf_sequence::const_iterator isPartOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isPartOf_type, char > isPartOf_traits;

    const isPartOf_sequence&
    isPartOf () const;

    isPartOf_sequence&
    isPartOf ();

    void
    isPartOf (const isPartOf_sequence& s);

    // hasPart
    // 
    typedef ::ebuCore_2011::relationType hasPart_type;
    typedef ::xsd::cxx::tree::sequence< hasPart_type > hasPart_sequence;
    typedef hasPart_sequence::iterator hasPart_iterator;
    typedef hasPart_sequence::const_iterator hasPart_const_iterator;
    typedef ::xsd::cxx::tree::traits< hasPart_type, char > hasPart_traits;

    const hasPart_sequence&
    hasPart () const;

    hasPart_sequence&
    hasPart ();

    void
    hasPart (const hasPart_sequence& s);

    // hasTrackPart
    // 
    typedef ::ebuCore_2011::hasTrackPart hasTrackPart_type;
    typedef ::xsd::cxx::tree::sequence< hasTrackPart_type > hasTrackPart_sequence;
    typedef hasTrackPart_sequence::iterator hasTrackPart_iterator;
    typedef hasTrackPart_sequence::const_iterator hasTrackPart_const_iterator;
    typedef ::xsd::cxx::tree::traits< hasTrackPart_type, char > hasTrackPart_traits;

    const hasTrackPart_sequence&
    hasTrackPart () const;

    hasTrackPart_sequence&
    hasTrackPart ();

    void
    hasTrackPart (const hasTrackPart_sequence& s);

    // isReferencedBy
    // 
    typedef ::ebuCore_2011::relationType isReferencedBy_type;
    typedef ::xsd::cxx::tree::sequence< isReferencedBy_type > isReferencedBy_sequence;
    typedef isReferencedBy_sequence::iterator isReferencedBy_iterator;
    typedef isReferencedBy_sequence::const_iterator isReferencedBy_const_iterator;
    typedef ::xsd::cxx::tree::traits< isReferencedBy_type, char > isReferencedBy_traits;

    const isReferencedBy_sequence&
    isReferencedBy () const;

    isReferencedBy_sequence&
    isReferencedBy ();

    void
    isReferencedBy (const isReferencedBy_sequence& s);

    // references
    // 
    typedef ::ebuCore_2011::relationType references_type;
    typedef ::xsd::cxx::tree::sequence< references_type > references_sequence;
    typedef references_sequence::iterator references_iterator;
    typedef references_sequence::const_iterator references_const_iterator;
    typedef ::xsd::cxx::tree::traits< references_type, char > references_traits;

    const references_sequence&
    references () const;

    references_sequence&
    references ();

    void
    references (const references_sequence& s);

    // isFormatOf
    // 
    typedef ::ebuCore_2011::relationType isFormatOf_type;
    typedef ::xsd::cxx::tree::sequence< isFormatOf_type > isFormatOf_sequence;
    typedef isFormatOf_sequence::iterator isFormatOf_iterator;
    typedef isFormatOf_sequence::const_iterator isFormatOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isFormatOf_type, char > isFormatOf_traits;

    const isFormatOf_sequence&
    isFormatOf () const;

    isFormatOf_sequence&
    isFormatOf ();

    void
    isFormatOf (const isFormatOf_sequence& s);

    // hasFormat
    // 
    typedef ::ebuCore_2011::relationType hasFormat_type;
    typedef ::xsd::cxx::tree::sequence< hasFormat_type > hasFormat_sequence;
    typedef hasFormat_sequence::iterator hasFormat_iterator;
    typedef hasFormat_sequence::const_iterator hasFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< hasFormat_type, char > hasFormat_traits;

    const hasFormat_sequence&
    hasFormat () const;

    hasFormat_sequence&
    hasFormat ();

    void
    hasFormat (const hasFormat_sequence& s);

    // isEpisodeOf
    // 
    typedef ::ebuCore_2011::relationType isEpisodeOf_type;
    typedef ::xsd::cxx::tree::sequence< isEpisodeOf_type > isEpisodeOf_sequence;
    typedef isEpisodeOf_sequence::iterator isEpisodeOf_iterator;
    typedef isEpisodeOf_sequence::const_iterator isEpisodeOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isEpisodeOf_type, char > isEpisodeOf_traits;

    const isEpisodeOf_sequence&
    isEpisodeOf () const;

    isEpisodeOf_sequence&
    isEpisodeOf ();

    void
    isEpisodeOf (const isEpisodeOf_sequence& s);

    // isMemberOf
    // 
    typedef ::ebuCore_2011::relationType isMemberOf_type;
    typedef ::xsd::cxx::tree::sequence< isMemberOf_type > isMemberOf_sequence;
    typedef isMemberOf_sequence::iterator isMemberOf_iterator;
    typedef isMemberOf_sequence::const_iterator isMemberOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isMemberOf_type, char > isMemberOf_traits;

    const isMemberOf_sequence&
    isMemberOf () const;

    isMemberOf_sequence&
    isMemberOf ();

    void
    isMemberOf (const isMemberOf_sequence& s);

    // coverage
    // 
    typedef ::ebuCore_2011::coverageType coverage_type;
    typedef ::xsd::cxx::tree::sequence< coverage_type > coverage_sequence;
    typedef coverage_sequence::iterator coverage_iterator;
    typedef coverage_sequence::const_iterator coverage_const_iterator;
    typedef ::xsd::cxx::tree::traits< coverage_type, char > coverage_traits;

    const coverage_sequence&
    coverage () const;

    coverage_sequence&
    coverage ();

    void
    coverage (const coverage_sequence& s);

    // rights
    // 
    typedef ::ebuCore_2011::rightsType rights_type;
    typedef ::xsd::cxx::tree::sequence< rights_type > rights_sequence;
    typedef rights_sequence::iterator rights_iterator;
    typedef rights_sequence::const_iterator rights_const_iterator;
    typedef ::xsd::cxx::tree::traits< rights_type, char > rights_traits;

    const rights_sequence&
    rights () const;

    rights_sequence&
    rights ();

    void
    rights (const rights_sequence& s);

    // version
    // 
    typedef ::dc::elementType version_type;
    typedef ::xsd::cxx::tree::optional< version_type > version_optional;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_optional&
    version () const;

    version_optional&
    version ();

    void
    version (const version_type& x);

    void
    version (const version_optional& x);

    void
    version (::std::auto_ptr< version_type > p);

    // publicationHistory
    // 
    typedef ::ebuCore_2011::publicationHistoryType publicationHistory_type;
    typedef ::xsd::cxx::tree::optional< publicationHistory_type > publicationHistory_optional;
    typedef ::xsd::cxx::tree::traits< publicationHistory_type, char > publicationHistory_traits;

    const publicationHistory_optional&
    publicationHistory () const;

    publicationHistory_optional&
    publicationHistory ();

    void
    publicationHistory (const publicationHistory_type& x);

    void
    publicationHistory (const publicationHistory_optional& x);

    void
    publicationHistory (::std::auto_ptr< publicationHistory_type > p);

    // rating
    // 
    typedef ::ebuCore_2011::ratingType rating_type;
    typedef ::xsd::cxx::tree::sequence< rating_type > rating_sequence;
    typedef rating_sequence::iterator rating_iterator;
    typedef rating_sequence::const_iterator rating_const_iterator;
    typedef ::xsd::cxx::tree::traits< rating_type, char > rating_traits;

    const rating_sequence&
    rating () const;

    rating_sequence&
    rating ();

    void
    rating (const rating_sequence& s);

    // part
    // 
    typedef ::ebuCore_2011::part part_type;
    typedef ::xsd::cxx::tree::sequence< part_type > part_sequence;
    typedef part_sequence::iterator part_iterator;
    typedef part_sequence::const_iterator part_const_iterator;
    typedef ::xsd::cxx::tree::traits< part_type, char > part_traits;

    const part_sequence&
    part () const;

    part_sequence&
    part ();

    void
    part (const part_sequence& s);

    // Constructors.
    //
    coreMetadataType ();

    coreMetadataType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    coreMetadataType (const coreMetadataType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual coreMetadataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~coreMetadataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    title_sequence title_;
    alternativeTitle_sequence alternativeTitle_;
    creator_sequence creator_;
    subject_sequence subject_;
    description_sequence description_;
    publisher_sequence publisher_;
    contributor_sequence contributor_;
    date_sequence date_;
    type_sequence type_;
    format_sequence format_;
    identifier_sequence identifier_;
    source_sequence source_;
    language_sequence language_;
    relation_sequence relation_;
    isVersionOf_sequence isVersionOf_;
    hasVersion_sequence hasVersion_;
    isReplacedBy_sequence isReplacedBy_;
    replaces_sequence replaces_;
    isRequiredBy_sequence isRequiredBy_;
    requires_sequence requires_;
    isPartOf_sequence isPartOf_;
    hasPart_sequence hasPart_;
    hasTrackPart_sequence hasTrackPart_;
    isReferencedBy_sequence isReferencedBy_;
    references_sequence references_;
    isFormatOf_sequence isFormatOf_;
    hasFormat_sequence hasFormat_;
    isEpisodeOf_sequence isEpisodeOf_;
    isMemberOf_sequence isMemberOf_;
    coverage_sequence coverage_;
    rights_sequence rights_;
    version_optional version_;
    publicationHistory_optional publicationHistory_;
    rating_sequence rating_;
    part_sequence part_;
  };

  class titleType: public ::xml_schema::type
  {
    public:
    // title
    // 
    typedef ::dc::elementType title_type;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_type&
    title () const;

    title_type&
    title ();

    void
    title (const title_type& x);

    void
    title (::std::auto_ptr< title_type > p);

    // attributiondate
    // 
    typedef ::xml_schema::date attributiondate_type;
    typedef ::xsd::cxx::tree::optional< attributiondate_type > attributiondate_optional;
    typedef ::xsd::cxx::tree::traits< attributiondate_type, char > attributiondate_traits;

    const attributiondate_optional&
    attributiondate () const;

    attributiondate_optional&
    attributiondate ();

    void
    attributiondate (const attributiondate_type& x);

    void
    attributiondate (const attributiondate_optional& x);

    void
    attributiondate (::std::auto_ptr< attributiondate_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    titleType (const title_type&);

    titleType (::std::auto_ptr< title_type >&);

    titleType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    titleType (const titleType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual titleType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~titleType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< title_type > title_;
    attributiondate_optional attributiondate_;
    note_optional note_;
  };

  class alternativeTitleType: public ::xml_schema::type
  {
    public:
    // title
    // 
    typedef ::dc::elementType title_type;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_type&
    title () const;

    title_type&
    title ();

    void
    title (const title_type& x);

    void
    title (::std::auto_ptr< title_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // statusLabel
    // 
    typedef ::xml_schema::string statusLabel_type;
    typedef ::xsd::cxx::tree::optional< statusLabel_type > statusLabel_optional;
    typedef ::xsd::cxx::tree::traits< statusLabel_type, char > statusLabel_traits;

    const statusLabel_optional&
    statusLabel () const;

    statusLabel_optional&
    statusLabel ();

    void
    statusLabel (const statusLabel_type& x);

    void
    statusLabel (const statusLabel_optional& x);

    void
    statusLabel (::std::auto_ptr< statusLabel_type > p);

    // statusDefinition
    // 
    typedef ::xml_schema::string statusDefinition_type;
    typedef ::xsd::cxx::tree::optional< statusDefinition_type > statusDefinition_optional;
    typedef ::xsd::cxx::tree::traits< statusDefinition_type, char > statusDefinition_traits;

    const statusDefinition_optional&
    statusDefinition () const;

    statusDefinition_optional&
    statusDefinition ();

    void
    statusDefinition (const statusDefinition_type& x);

    void
    statusDefinition (const statusDefinition_optional& x);

    void
    statusDefinition (::std::auto_ptr< statusDefinition_type > p);

    // statusLink
    // 
    typedef ::xml_schema::uri statusLink_type;
    typedef ::xsd::cxx::tree::optional< statusLink_type > statusLink_optional;
    typedef ::xsd::cxx::tree::traits< statusLink_type, char > statusLink_traits;

    const statusLink_optional&
    statusLink () const;

    statusLink_optional&
    statusLink ();

    void
    statusLink (const statusLink_type& x);

    void
    statusLink (const statusLink_optional& x);

    void
    statusLink (::std::auto_ptr< statusLink_type > p);

    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // period
    // 
    typedef ::xml_schema::string period_type;
    typedef ::xsd::cxx::tree::optional< period_type > period_optional;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_optional&
    period () const;

    period_optional&
    period ();

    void
    period (const period_type& x);

    void
    period (const period_optional& x);

    void
    period (::std::auto_ptr< period_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    alternativeTitleType (const title_type&);

    alternativeTitleType (::std::auto_ptr< title_type >&);

    alternativeTitleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    alternativeTitleType (const alternativeTitleType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual alternativeTitleType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~alternativeTitleType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< title_type > title_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    statusLabel_optional statusLabel_;
    statusDefinition_optional statusDefinition_;
    statusLink_optional statusLink_;
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    period_optional period_;
    note_optional note_;
  };

  class identifierType: public ::xml_schema::type
  {
    public:
    // identifier
    // 
    typedef ::dc::elementType identifier_type;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_type&
    identifier () const;

    identifier_type&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (::std::auto_ptr< identifier_type > p);

    // attributor
    // 
    typedef ::ebuCore_2011::entityType attributor_type;
    typedef ::xsd::cxx::tree::optional< attributor_type > attributor_optional;
    typedef ::xsd::cxx::tree::traits< attributor_type, char > attributor_traits;

    const attributor_optional&
    attributor () const;

    attributor_optional&
    attributor ();

    void
    attributor (const attributor_type& x);

    void
    attributor (const attributor_optional& x);

    void
    attributor (::std::auto_ptr< attributor_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    identifierType (const identifier_type&);

    identifierType (::std::auto_ptr< identifier_type >&);

    identifierType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    identifierType (const identifierType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual identifierType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~identifierType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< identifier_type > identifier_;
    attributor_optional attributor_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    note_optional note_;
  };

  class subjectType: public ::xml_schema::type
  {
    public:
    // subject
    // 
    typedef ::dc::elementType subject_type;
    typedef ::xsd::cxx::tree::traits< subject_type, char > subject_traits;

    const subject_type&
    subject () const;

    subject_type&
    subject ();

    void
    subject (const subject_type& x);

    void
    subject (::std::auto_ptr< subject_type > p);

    // subjectCode
    // 
    typedef ::xml_schema::uri subjectCode_type;
    typedef ::xsd::cxx::tree::optional< subjectCode_type > subjectCode_optional;
    typedef ::xsd::cxx::tree::traits< subjectCode_type, char > subjectCode_traits;

    const subjectCode_optional&
    subjectCode () const;

    subjectCode_optional&
    subjectCode ();

    void
    subjectCode (const subjectCode_type& x);

    void
    subjectCode (const subjectCode_optional& x);

    void
    subjectCode (::std::auto_ptr< subjectCode_type > p);

    // subjectDefinition
    // 
    typedef ::xml_schema::string subjectDefinition_type;
    typedef ::xsd::cxx::tree::optional< subjectDefinition_type > subjectDefinition_optional;
    typedef ::xsd::cxx::tree::traits< subjectDefinition_type, char > subjectDefinition_traits;

    const subjectDefinition_optional&
    subjectDefinition () const;

    subjectDefinition_optional&
    subjectDefinition ();

    void
    subjectDefinition (const subjectDefinition_type& x);

    void
    subjectDefinition (const subjectDefinition_optional& x);

    void
    subjectDefinition (::std::auto_ptr< subjectDefinition_type > p);

    // attributor
    // 
    typedef ::ebuCore_2011::entityType attributor_type;
    typedef ::xsd::cxx::tree::optional< attributor_type > attributor_optional;
    typedef ::xsd::cxx::tree::traits< attributor_type, char > attributor_traits;

    const attributor_optional&
    attributor () const;

    attributor_optional&
    attributor ();

    void
    attributor (const attributor_type& x);

    void
    attributor (const attributor_optional& x);

    void
    attributor (::std::auto_ptr< attributor_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    subjectType (const subject_type&);

    subjectType (::std::auto_ptr< subject_type >&);

    subjectType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    subjectType (const subjectType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual subjectType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~subjectType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< subject_type > subject_;
    subjectCode_optional subjectCode_;
    subjectDefinition_optional subjectDefinition_;
    attributor_optional attributor_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    note_optional note_;
  };

  class typeType: public ::xml_schema::type
  {
    public:
    // type
    // 
    typedef ::dc::elementType type_type;
    typedef ::xsd::cxx::tree::sequence< type_type > type_sequence;
    typedef type_sequence::iterator type_iterator;
    typedef type_sequence::const_iterator type_const_iterator;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_sequence&
    type () const;

    type_sequence&
    type ();

    void
    type (const type_sequence& s);

    // genre
    // 
    typedef ::ebuCore_2011::genre genre_type;
    typedef ::xsd::cxx::tree::sequence< genre_type > genre_sequence;
    typedef genre_sequence::iterator genre_iterator;
    typedef genre_sequence::const_iterator genre_const_iterator;
    typedef ::xsd::cxx::tree::traits< genre_type, char > genre_traits;

    const genre_sequence&
    genre () const;

    genre_sequence&
    genre ();

    void
    genre (const genre_sequence& s);

    // objectType
    // 
    typedef ::ebuCore_2011::objectType objectType_type;
    typedef ::xsd::cxx::tree::sequence< objectType_type > objectType_sequence;
    typedef objectType_sequence::iterator objectType_iterator;
    typedef objectType_sequence::const_iterator objectType_const_iterator;
    typedef ::xsd::cxx::tree::traits< objectType_type, char > objectType_traits;

    const objectType_sequence&
    objectType () const;

    objectType_sequence&
    objectType ();

    void
    objectType (const objectType_sequence& s);

    // targetAudience
    // 
    typedef ::ebuCore_2011::targetAudience targetAudience_type;
    typedef ::xsd::cxx::tree::sequence< targetAudience_type > targetAudience_sequence;
    typedef targetAudience_sequence::iterator targetAudience_iterator;
    typedef targetAudience_sequence::const_iterator targetAudience_const_iterator;
    typedef ::xsd::cxx::tree::traits< targetAudience_type, char > targetAudience_traits;

    const targetAudience_sequence&
    targetAudience () const;

    targetAudience_sequence&
    targetAudience ();

    void
    targetAudience (const targetAudience_sequence& s);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    typeType ();

    typeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    typeType (const typeType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual typeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~typeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    type_sequence type_;
    genre_sequence genre_;
    objectType_sequence objectType_;
    targetAudience_sequence targetAudience_;
    note_optional note_;
  };

  class descriptionType: public ::xml_schema::type
  {
    public:
    // description
    // 
    typedef ::dc::elementType description_type;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_type&
    description () const;

    description_type&
    description ();

    void
    description (const description_type& x);

    void
    description (::std::auto_ptr< description_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    descriptionType (const description_type&);

    descriptionType (::std::auto_ptr< description_type >&);

    descriptionType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    descriptionType (const descriptionType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual descriptionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~descriptionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< description_type > description_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    note_optional note_;
  };

  class coverageType: public ::xml_schema::type
  {
    public:
    // coverage
    // 
    typedef ::dc::elementType coverage_type;
    typedef ::xsd::cxx::tree::optional< coverage_type > coverage_optional;
    typedef ::xsd::cxx::tree::traits< coverage_type, char > coverage_traits;

    const coverage_optional&
    coverage () const;

    coverage_optional&
    coverage ();

    void
    coverage (const coverage_type& x);

    void
    coverage (const coverage_optional& x);

    void
    coverage (::std::auto_ptr< coverage_type > p);

    // temporal
    // 
    typedef ::ebuCore_2011::temporal temporal_type;
    typedef ::xsd::cxx::tree::optional< temporal_type > temporal_optional;
    typedef ::xsd::cxx::tree::traits< temporal_type, char > temporal_traits;

    const temporal_optional&
    temporal () const;

    temporal_optional&
    temporal ();

    void
    temporal (const temporal_type& x);

    void
    temporal (const temporal_optional& x);

    void
    temporal (::std::auto_ptr< temporal_type > p);

    // spatial
    // 
    typedef ::ebuCore_2011::spatial spatial_type;
    typedef ::xsd::cxx::tree::optional< spatial_type > spatial_optional;
    typedef ::xsd::cxx::tree::traits< spatial_type, char > spatial_traits;

    const spatial_optional&
    spatial () const;

    spatial_optional&
    spatial ();

    void
    spatial (const spatial_type& x);

    void
    spatial (const spatial_optional& x);

    void
    spatial (::std::auto_ptr< spatial_type > p);

    // Constructors.
    //
    coverageType ();

    coverageType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    coverageType (const coverageType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual coverageType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~coverageType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    coverage_optional coverage_;
    temporal_optional temporal_;
    spatial_optional spatial_;
  };

  class rightsType: public ::xml_schema::type
  {
    public:
    // rights
    // 
    typedef ::dc::elementType rights_type;
    typedef ::xsd::cxx::tree::optional< rights_type > rights_optional;
    typedef ::xsd::cxx::tree::traits< rights_type, char > rights_traits;

    const rights_optional&
    rights () const;

    rights_optional&
    rights ();

    void
    rights (const rights_type& x);

    void
    rights (const rights_optional& x);

    void
    rights (::std::auto_ptr< rights_type > p);

    // rightsLink
    // 
    typedef ::xml_schema::uri rightsLink_type;
    typedef ::xsd::cxx::tree::optional< rightsLink_type > rightsLink_optional;
    typedef ::xsd::cxx::tree::traits< rightsLink_type, char > rightsLink_traits;

    const rightsLink_optional&
    rightsLink () const;

    rightsLink_optional&
    rightsLink ();

    void
    rightsLink (const rightsLink_type& x);

    void
    rightsLink (const rightsLink_optional& x);

    void
    rightsLink (::std::auto_ptr< rightsLink_type > p);

    // rightsHolder
    // 
    typedef ::ebuCore_2011::entityType rightsHolder_type;
    typedef ::xsd::cxx::tree::optional< rightsHolder_type > rightsHolder_optional;
    typedef ::xsd::cxx::tree::traits< rightsHolder_type, char > rightsHolder_traits;

    const rightsHolder_optional&
    rightsHolder () const;

    rightsHolder_optional&
    rightsHolder ();

    void
    rightsHolder (const rightsHolder_type& x);

    void
    rightsHolder (const rightsHolder_optional& x);

    void
    rightsHolder (::std::auto_ptr< rightsHolder_type > p);

    // exploitationIssues
    // 
    typedef ::dc::elementType exploitationIssues_type;
    typedef ::xsd::cxx::tree::optional< exploitationIssues_type > exploitationIssues_optional;
    typedef ::xsd::cxx::tree::traits< exploitationIssues_type, char > exploitationIssues_traits;

    const exploitationIssues_optional&
    exploitationIssues () const;

    exploitationIssues_optional&
    exploitationIssues ();

    void
    exploitationIssues (const exploitationIssues_type& x);

    void
    exploitationIssues (const exploitationIssues_optional& x);

    void
    exploitationIssues (::std::auto_ptr< exploitationIssues_type > p);

    // coverage
    // 
    typedef ::ebuCore_2011::coverageType coverage_type;
    typedef ::xsd::cxx::tree::optional< coverage_type > coverage_optional;
    typedef ::xsd::cxx::tree::traits< coverage_type, char > coverage_traits;

    const coverage_optional&
    coverage () const;

    coverage_optional&
    coverage ();

    void
    coverage (const coverage_type& x);

    void
    coverage (const coverage_optional& x);

    void
    coverage (::std::auto_ptr< coverage_type > p);

    // rightsClearanceFlag
    // 
    typedef ::xml_schema::boolean rightsClearanceFlag_type;
    typedef ::xsd::cxx::tree::optional< rightsClearanceFlag_type > rightsClearanceFlag_optional;
    typedef ::xsd::cxx::tree::traits< rightsClearanceFlag_type, char > rightsClearanceFlag_traits;

    const rightsClearanceFlag_optional&
    rightsClearanceFlag () const;

    rightsClearanceFlag_optional&
    rightsClearanceFlag ();

    void
    rightsClearanceFlag (const rightsClearanceFlag_type& x);

    void
    rightsClearanceFlag (const rightsClearanceFlag_optional& x);

    // disclaimer
    // 
    typedef ::dc::elementType disclaimer_type;
    typedef ::xsd::cxx::tree::sequence< disclaimer_type > disclaimer_sequence;
    typedef disclaimer_sequence::iterator disclaimer_iterator;
    typedef disclaimer_sequence::const_iterator disclaimer_const_iterator;
    typedef ::xsd::cxx::tree::traits< disclaimer_type, char > disclaimer_traits;

    const disclaimer_sequence&
    disclaimer () const;

    disclaimer_sequence&
    disclaimer ();

    void
    disclaimer (const disclaimer_sequence& s);

    // rightsId
    // 
    typedef ::ebuCore_2011::identifierType rightsId_type;
    typedef ::xsd::cxx::tree::sequence< rightsId_type > rightsId_sequence;
    typedef rightsId_sequence::iterator rightsId_iterator;
    typedef rightsId_sequence::const_iterator rightsId_const_iterator;
    typedef ::xsd::cxx::tree::traits< rightsId_type, char > rightsId_traits;

    const rightsId_sequence&
    rightsId () const;

    rightsId_sequence&
    rightsId ();

    void
    rightsId (const rightsId_sequence& s);

    // contactDetails
    // 
    typedef ::ebuCore_2011::contactDetailsType contactDetails_type;
    typedef ::xsd::cxx::tree::sequence< contactDetails_type > contactDetails_sequence;
    typedef contactDetails_sequence::iterator contactDetails_iterator;
    typedef contactDetails_sequence::const_iterator contactDetails_const_iterator;
    typedef ::xsd::cxx::tree::traits< contactDetails_type, char > contactDetails_traits;

    const contactDetails_sequence&
    contactDetails () const;

    contactDetails_sequence&
    contactDetails ();

    void
    contactDetails (const contactDetails_sequence& s);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // formatIDRefs
    // 
    typedef ::xml_schema::idrefs formatIDRefs_type;
    typedef ::xsd::cxx::tree::optional< formatIDRefs_type > formatIDRefs_optional;
    typedef ::xsd::cxx::tree::traits< formatIDRefs_type, char > formatIDRefs_traits;

    const formatIDRefs_optional&
    formatIDRefs () const;

    formatIDRefs_optional&
    formatIDRefs ();

    void
    formatIDRefs (const formatIDRefs_type& x);

    void
    formatIDRefs (const formatIDRefs_optional& x);

    void
    formatIDRefs (::std::auto_ptr< formatIDRefs_type > p);

    // Constructors.
    //
    rightsType ();

    rightsType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    rightsType (const rightsType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual rightsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~rightsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    rights_optional rights_;
    rightsLink_optional rightsLink_;
    rightsHolder_optional rightsHolder_;
    exploitationIssues_optional exploitationIssues_;
    coverage_optional coverage_;
    rightsClearanceFlag_optional rightsClearanceFlag_;
    disclaimer_sequence disclaimer_;
    rightsId_sequence rightsId_;
    contactDetails_sequence contactDetails_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    note_optional note_;
    formatIDRefs_optional formatIDRefs_;
  };

  class formatType: public ::xml_schema::type
  {
    public:
    // format
    // 
    typedef ::dc::elementType format_type;
    typedef ::xsd::cxx::tree::optional< format_type > format_optional;
    typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

    const format_optional&
    format () const;

    format_optional&
    format ();

    void
    format (const format_type& x);

    void
    format (const format_optional& x);

    void
    format (::std::auto_ptr< format_type > p);

    // regionDelimX
    // 
    typedef ::xml_schema::non_negative_integer regionDelimX_type;
    typedef ::xsd::cxx::tree::optional< regionDelimX_type > regionDelimX_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimX_type, char > regionDelimX_traits;

    const regionDelimX_optional&
    regionDelimX () const;

    regionDelimX_optional&
    regionDelimX ();

    void
    regionDelimX (const regionDelimX_type& x);

    void
    regionDelimX (const regionDelimX_optional& x);

    // regionDelimY
    // 
    typedef ::xml_schema::non_negative_integer regionDelimY_type;
    typedef ::xsd::cxx::tree::optional< regionDelimY_type > regionDelimY_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimY_type, char > regionDelimY_traits;

    const regionDelimY_optional&
    regionDelimY () const;

    regionDelimY_optional&
    regionDelimY ();

    void
    regionDelimY (const regionDelimY_type& x);

    void
    regionDelimY (const regionDelimY_optional& x);

    // width
    // 
    typedef ::ebuCore_2011::lengthType width_type;
    typedef ::xsd::cxx::tree::optional< width_type > width_optional;
    typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

    const width_optional&
    width () const;

    width_optional&
    width ();

    void
    width (const width_type& x);

    void
    width (const width_optional& x);

    void
    width (::std::auto_ptr< width_type > p);

    // height
    // 
    typedef ::ebuCore_2011::lengthType height_type;
    typedef ::xsd::cxx::tree::optional< height_type > height_optional;
    typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

    const height_optional&
    height () const;

    height_optional&
    height ();

    void
    height (const height_type& x);

    void
    height (const height_optional& x);

    void
    height (::std::auto_ptr< height_type > p);

    // medium
    // 
    typedef ::ebuCore_2011::medium medium_type;
    typedef ::xsd::cxx::tree::sequence< medium_type > medium_sequence;
    typedef medium_sequence::iterator medium_iterator;
    typedef medium_sequence::const_iterator medium_const_iterator;
    typedef ::xsd::cxx::tree::traits< medium_type, char > medium_traits;

    const medium_sequence&
    medium () const;

    medium_sequence&
    medium ();

    void
    medium (const medium_sequence& s);

    // mimeType
    // 
    typedef ::ebuCore_2011::mimeType mimeType_type;
    typedef ::xsd::cxx::tree::sequence< mimeType_type > mimeType_sequence;
    typedef mimeType_sequence::iterator mimeType_iterator;
    typedef mimeType_sequence::const_iterator mimeType_const_iterator;
    typedef ::xsd::cxx::tree::traits< mimeType_type, char > mimeType_traits;

    const mimeType_sequence&
    mimeType () const;

    mimeType_sequence&
    mimeType ();

    void
    mimeType (const mimeType_sequence& s);

    // imageFormat
    // 
    typedef ::ebuCore_2011::imageFormatType imageFormat_type;
    typedef ::xsd::cxx::tree::sequence< imageFormat_type > imageFormat_sequence;
    typedef imageFormat_sequence::iterator imageFormat_iterator;
    typedef imageFormat_sequence::const_iterator imageFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< imageFormat_type, char > imageFormat_traits;

    const imageFormat_sequence&
    imageFormat () const;

    imageFormat_sequence&
    imageFormat ();

    void
    imageFormat (const imageFormat_sequence& s);

    // videoFormat
    // 
    typedef ::ebuCore_2011::videoFormatType videoFormat_type;
    typedef ::xsd::cxx::tree::sequence< videoFormat_type > videoFormat_sequence;
    typedef videoFormat_sequence::iterator videoFormat_iterator;
    typedef videoFormat_sequence::const_iterator videoFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< videoFormat_type, char > videoFormat_traits;

    const videoFormat_sequence&
    videoFormat () const;

    videoFormat_sequence&
    videoFormat ();

    void
    videoFormat (const videoFormat_sequence& s);

    // audioFormat
    // 
    typedef ::ebuCore_2011::audioFormatType audioFormat_type;
    typedef ::xsd::cxx::tree::sequence< audioFormat_type > audioFormat_sequence;
    typedef audioFormat_sequence::iterator audioFormat_iterator;
    typedef audioFormat_sequence::const_iterator audioFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< audioFormat_type, char > audioFormat_traits;

    const audioFormat_sequence&
    audioFormat () const;

    audioFormat_sequence&
    audioFormat ();

    void
    audioFormat (const audioFormat_sequence& s);

    // containerFormat
    // 
    typedef ::ebuCore_2011::containerFormat containerFormat_type;
    typedef ::xsd::cxx::tree::sequence< containerFormat_type > containerFormat_sequence;
    typedef containerFormat_sequence::iterator containerFormat_iterator;
    typedef containerFormat_sequence::const_iterator containerFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< containerFormat_type, char > containerFormat_traits;

    const containerFormat_sequence&
    containerFormat () const;

    containerFormat_sequence&
    containerFormat ();

    void
    containerFormat (const containerFormat_sequence& s);

    // dataFormat
    // 
    typedef ::ebuCore_2011::dataFormatType dataFormat_type;
    typedef ::xsd::cxx::tree::sequence< dataFormat_type > dataFormat_sequence;
    typedef dataFormat_sequence::iterator dataFormat_iterator;
    typedef dataFormat_sequence::const_iterator dataFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< dataFormat_type, char > dataFormat_traits;

    const dataFormat_sequence&
    dataFormat () const;

    dataFormat_sequence&
    dataFormat ();

    void
    dataFormat (const dataFormat_sequence& s);

    // signingFormat
    // 
    typedef ::ebuCore_2011::signingFormat signingFormat_type;
    typedef ::xsd::cxx::tree::sequence< signingFormat_type > signingFormat_sequence;
    typedef signingFormat_sequence::iterator signingFormat_iterator;
    typedef signingFormat_sequence::const_iterator signingFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< signingFormat_type, char > signingFormat_traits;

    const signingFormat_sequence&
    signingFormat () const;

    signingFormat_sequence&
    signingFormat ();

    void
    signingFormat (const signingFormat_sequence& s);

    // start
    // 
    typedef ::ebuCore_2011::timeType start_type;
    typedef ::xsd::cxx::tree::optional< start_type > start_optional;
    typedef ::xsd::cxx::tree::traits< start_type, char > start_traits;

    const start_optional&
    start () const;

    start_optional&
    start ();

    void
    start (const start_type& x);

    void
    start (const start_optional& x);

    void
    start (::std::auto_ptr< start_type > p);

    // end
    // 
    typedef ::ebuCore_2011::timeType end_type;
    typedef ::xsd::cxx::tree::optional< end_type > end_optional;
    typedef ::xsd::cxx::tree::traits< end_type, char > end_traits;

    const end_optional&
    end () const;

    end_optional&
    end ();

    void
    end (const end_type& x);

    void
    end (const end_optional& x);

    void
    end (::std::auto_ptr< end_type > p);

    // duration
    // 
    typedef ::ebuCore_2011::durationType duration_type;
    typedef ::xsd::cxx::tree::optional< duration_type > duration_optional;
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    const duration_optional&
    duration () const;

    duration_optional&
    duration ();

    void
    duration (const duration_type& x);

    void
    duration (const duration_optional& x);

    void
    duration (::std::auto_ptr< duration_type > p);

    // fileSize
    // 
    typedef ::xml_schema::long_ fileSize_type;
    typedef ::xsd::cxx::tree::optional< fileSize_type > fileSize_optional;
    typedef ::xsd::cxx::tree::traits< fileSize_type, char > fileSize_traits;

    const fileSize_optional&
    fileSize () const;

    fileSize_optional&
    fileSize ();

    void
    fileSize (const fileSize_type& x);

    void
    fileSize (const fileSize_optional& x);

    // filename
    // 
    typedef ::xml_schema::string filename_type;
    typedef ::xsd::cxx::tree::optional< filename_type > filename_optional;
    typedef ::xsd::cxx::tree::traits< filename_type, char > filename_traits;

    const filename_optional&
    filename () const;

    filename_optional&
    filename ();

    void
    filename (const filename_type& x);

    void
    filename (const filename_optional& x);

    void
    filename (::std::auto_ptr< filename_type > p);

    // locator
    // 
    typedef ::ebuCore_2011::locator locator_type;
    typedef ::xsd::cxx::tree::optional< locator_type > locator_optional;
    typedef ::xsd::cxx::tree::traits< locator_type, char > locator_traits;

    const locator_optional&
    locator () const;

    locator_optional&
    locator ();

    void
    locator (const locator_type& x);

    void
    locator (const locator_optional& x);

    void
    locator (::std::auto_ptr< locator_type > p);

    // documentFormat
    // 
    typedef ::ebuCore_2011::documentFormatType documentFormat_type;
    typedef ::xsd::cxx::tree::optional< documentFormat_type > documentFormat_optional;
    typedef ::xsd::cxx::tree::traits< documentFormat_type, char > documentFormat_traits;

    const documentFormat_optional&
    documentFormat () const;

    documentFormat_optional&
    documentFormat ();

    void
    documentFormat (const documentFormat_type& x);

    void
    documentFormat (const documentFormat_optional& x);

    void
    documentFormat (::std::auto_ptr< documentFormat_type > p);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2011::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2011::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2011::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2011::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2011::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2011::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2011::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2011::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2011::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2011::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2011::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2011::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2011::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // dateCreated
    // 
    typedef ::ebuCore_2011::dateCreated dateCreated_type;
    typedef ::xsd::cxx::tree::optional< dateCreated_type > dateCreated_optional;
    typedef ::xsd::cxx::tree::traits< dateCreated_type, char > dateCreated_traits;

    const dateCreated_optional&
    dateCreated () const;

    dateCreated_optional&
    dateCreated ();

    void
    dateCreated (const dateCreated_type& x);

    void
    dateCreated (const dateCreated_optional& x);

    void
    dateCreated (::std::auto_ptr< dateCreated_type > p);

    // dateModified
    // 
    typedef ::ebuCore_2011::dateModified dateModified_type;
    typedef ::xsd::cxx::tree::optional< dateModified_type > dateModified_optional;
    typedef ::xsd::cxx::tree::traits< dateModified_type, char > dateModified_traits;

    const dateModified_optional&
    dateModified () const;

    dateModified_optional&
    dateModified ();

    void
    dateModified (const dateModified_type& x);

    void
    dateModified (const dateModified_optional& x);

    void
    dateModified (::std::auto_ptr< dateModified_type > p);

    // formatId
    // 
    typedef ::xml_schema::id formatId_type;
    typedef ::xsd::cxx::tree::optional< formatId_type > formatId_optional;
    typedef ::xsd::cxx::tree::traits< formatId_type, char > formatId_traits;

    const formatId_optional&
    formatId () const;

    formatId_optional&
    formatId ();

    void
    formatId (const formatId_type& x);

    void
    formatId (const formatId_optional& x);

    void
    formatId (::std::auto_ptr< formatId_type > p);

    // formatName
    // 
    typedef ::xml_schema::string formatName_type;
    typedef ::xsd::cxx::tree::optional< formatName_type > formatName_optional;
    typedef ::xsd::cxx::tree::traits< formatName_type, char > formatName_traits;

    const formatName_optional&
    formatName () const;

    formatName_optional&
    formatName ();

    void
    formatName (const formatName_type& x);

    void
    formatName (const formatName_optional& x);

    void
    formatName (::std::auto_ptr< formatName_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // Constructors.
    //
    formatType ();

    formatType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    formatType (const formatType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual formatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~formatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    format_optional format_;
    regionDelimX_optional regionDelimX_;
    regionDelimY_optional regionDelimY_;
    width_optional width_;
    height_optional height_;
    medium_sequence medium_;
    mimeType_sequence mimeType_;
    imageFormat_sequence imageFormat_;
    videoFormat_sequence videoFormat_;
    audioFormat_sequence audioFormat_;
    containerFormat_sequence containerFormat_;
    dataFormat_sequence dataFormat_;
    signingFormat_sequence signingFormat_;
    start_optional start_;
    end_optional end_;
    duration_optional duration_;
    fileSize_optional fileSize_;
    filename_optional filename_;
    locator_optional locator_;
    documentFormat_optional documentFormat_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    dateCreated_optional dateCreated_;
    dateModified_optional dateModified_;
    formatId_optional formatId_;
    formatName_optional formatName_;
    formatDefinition_optional formatDefinition_;
  };

  class relationType: public ::xml_schema::type
  {
    public:
    // relation
    // 
    typedef ::dc::elementType relation_type;
    typedef ::xsd::cxx::tree::optional< relation_type > relation_optional;
    typedef ::xsd::cxx::tree::traits< relation_type, char > relation_traits;

    const relation_optional&
    relation () const;

    relation_optional&
    relation ();

    void
    relation (const relation_type& x);

    void
    relation (const relation_optional& x);

    void
    relation (::std::auto_ptr< relation_type > p);

    // relationIdentifier
    // 
    typedef ::ebuCore_2011::identifierType relationIdentifier_type;
    typedef ::xsd::cxx::tree::optional< relationIdentifier_type > relationIdentifier_optional;
    typedef ::xsd::cxx::tree::traits< relationIdentifier_type, char > relationIdentifier_traits;

    const relationIdentifier_optional&
    relationIdentifier () const;

    relationIdentifier_optional&
    relationIdentifier ();

    void
    relationIdentifier (const relationIdentifier_type& x);

    void
    relationIdentifier (const relationIdentifier_optional& x);

    void
    relationIdentifier (::std::auto_ptr< relationIdentifier_type > p);

    // relationLink
    // 
    typedef ::xml_schema::uri relationLink_type;
    typedef ::xsd::cxx::tree::optional< relationLink_type > relationLink_optional;
    typedef ::xsd::cxx::tree::traits< relationLink_type, char > relationLink_traits;

    const relationLink_optional&
    relationLink () const;

    relationLink_optional&
    relationLink ();

    void
    relationLink (const relationLink_type& x);

    void
    relationLink (const relationLink_optional& x);

    void
    relationLink (::std::auto_ptr< relationLink_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // runningOrderNumber
    // 
    typedef ::xml_schema::integer runningOrderNumber_type;
    typedef ::xsd::cxx::tree::optional< runningOrderNumber_type > runningOrderNumber_optional;
    typedef ::xsd::cxx::tree::traits< runningOrderNumber_type, char > runningOrderNumber_traits;

    const runningOrderNumber_optional&
    runningOrderNumber () const;

    runningOrderNumber_optional&
    runningOrderNumber ();

    void
    runningOrderNumber (const runningOrderNumber_type& x);

    void
    runningOrderNumber (const runningOrderNumber_optional& x);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    relationType ();

    relationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    relationType (const relationType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual relationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~relationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    relation_optional relation_;
    relationIdentifier_optional relationIdentifier_;
    relationLink_optional relationLink_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    runningOrderNumber_optional runningOrderNumber_;
    note_optional note_;
  };

  class languageType: public ::xml_schema::type
  {
    public:
    // language
    // 
    typedef ::dc::elementType language_type;
    typedef ::xsd::cxx::tree::optional< language_type > language_optional;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_optional&
    language () const;

    language_optional&
    language ();

    void
    language (const language_type& x);

    void
    language (const language_optional& x);

    void
    language (::std::auto_ptr< language_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    languageType ();

    languageType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    languageType (const languageType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual languageType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~languageType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    language_optional language_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    note_optional note_;
  };

  class dateType: public ::xml_schema::type
  {
    public:
    // date
    // 
    typedef ::dc::elementType date_type;
    typedef ::xsd::cxx::tree::sequence< date_type > date_sequence;
    typedef date_sequence::iterator date_iterator;
    typedef date_sequence::const_iterator date_const_iterator;
    typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

    const date_sequence&
    date () const;

    date_sequence&
    date ();

    void
    date (const date_sequence& s);

    // created
    // 
    typedef ::ebuCore_2011::created created_type;
    typedef ::xsd::cxx::tree::optional< created_type > created_optional;
    typedef ::xsd::cxx::tree::traits< created_type, char > created_traits;

    const created_optional&
    created () const;

    created_optional&
    created ();

    void
    created (const created_type& x);

    void
    created (const created_optional& x);

    void
    created (::std::auto_ptr< created_type > p);

    // issued
    // 
    typedef ::ebuCore_2011::issued issued_type;
    typedef ::xsd::cxx::tree::optional< issued_type > issued_optional;
    typedef ::xsd::cxx::tree::traits< issued_type, char > issued_traits;

    const issued_optional&
    issued () const;

    issued_optional&
    issued ();

    void
    issued (const issued_type& x);

    void
    issued (const issued_optional& x);

    void
    issued (::std::auto_ptr< issued_type > p);

    // modified
    // 
    typedef ::ebuCore_2011::modified modified_type;
    typedef ::xsd::cxx::tree::optional< modified_type > modified_optional;
    typedef ::xsd::cxx::tree::traits< modified_type, char > modified_traits;

    const modified_optional&
    modified () const;

    modified_optional&
    modified ();

    void
    modified (const modified_type& x);

    void
    modified (const modified_optional& x);

    void
    modified (::std::auto_ptr< modified_type > p);

    // digitised
    // 
    typedef ::ebuCore_2011::digitised digitised_type;
    typedef ::xsd::cxx::tree::optional< digitised_type > digitised_optional;
    typedef ::xsd::cxx::tree::traits< digitised_type, char > digitised_traits;

    const digitised_optional&
    digitised () const;

    digitised_optional&
    digitised ();

    void
    digitised (const digitised_type& x);

    void
    digitised (const digitised_optional& x);

    void
    digitised (::std::auto_ptr< digitised_type > p);

    // alternative
    // 
    typedef ::ebuCore_2011::alternative alternative_type;
    typedef ::xsd::cxx::tree::sequence< alternative_type > alternative_sequence;
    typedef alternative_sequence::iterator alternative_iterator;
    typedef alternative_sequence::const_iterator alternative_const_iterator;
    typedef ::xsd::cxx::tree::traits< alternative_type, char > alternative_traits;

    const alternative_sequence&
    alternative () const;

    alternative_sequence&
    alternative ();

    void
    alternative (const alternative_sequence& s);

    // Constructors.
    //
    dateType ();

    dateType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    dateType (const dateType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual dateType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~dateType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    date_sequence date_;
    created_optional created_;
    issued_optional issued_;
    modified_optional modified_;
    digitised_optional digitised_;
    alternative_sequence alternative_;
  };

  class publicationHistoryType: public ::xml_schema::type
  {
    public:
    // firstPublicationDate
    // 
    typedef ::xml_schema::date firstPublicationDate_type;
    typedef ::xsd::cxx::tree::optional< firstPublicationDate_type > firstPublicationDate_optional;
    typedef ::xsd::cxx::tree::traits< firstPublicationDate_type, char > firstPublicationDate_traits;

    const firstPublicationDate_optional&
    firstPublicationDate () const;

    firstPublicationDate_optional&
    firstPublicationDate ();

    void
    firstPublicationDate (const firstPublicationDate_type& x);

    void
    firstPublicationDate (const firstPublicationDate_optional& x);

    void
    firstPublicationDate (::std::auto_ptr< firstPublicationDate_type > p);

    // firstPublicationTime
    // 
    typedef ::xml_schema::time firstPublicationTime_type;
    typedef ::xsd::cxx::tree::optional< firstPublicationTime_type > firstPublicationTime_optional;
    typedef ::xsd::cxx::tree::traits< firstPublicationTime_type, char > firstPublicationTime_traits;

    const firstPublicationTime_optional&
    firstPublicationTime () const;

    firstPublicationTime_optional&
    firstPublicationTime ();

    void
    firstPublicationTime (const firstPublicationTime_type& x);

    void
    firstPublicationTime (const firstPublicationTime_optional& x);

    void
    firstPublicationTime (::std::auto_ptr< firstPublicationTime_type > p);

    // firstPublicationChannel
    // 
    typedef ::ebuCore_2011::firstPublicationChannel firstPublicationChannel_type;
    typedef ::xsd::cxx::tree::optional< firstPublicationChannel_type > firstPublicationChannel_optional;
    typedef ::xsd::cxx::tree::traits< firstPublicationChannel_type, char > firstPublicationChannel_traits;

    const firstPublicationChannel_optional&
    firstPublicationChannel () const;

    firstPublicationChannel_optional&
    firstPublicationChannel ();

    void
    firstPublicationChannel (const firstPublicationChannel_type& x);

    void
    firstPublicationChannel (const firstPublicationChannel_optional& x);

    void
    firstPublicationChannel (::std::auto_ptr< firstPublicationChannel_type > p);

    // repeatDate
    // 
    typedef ::xml_schema::date repeatDate_type;
    typedef ::xsd::cxx::tree::sequence< repeatDate_type > repeatDate_sequence;
    typedef repeatDate_sequence::iterator repeatDate_iterator;
    typedef repeatDate_sequence::const_iterator repeatDate_const_iterator;
    typedef ::xsd::cxx::tree::traits< repeatDate_type, char > repeatDate_traits;

    const repeatDate_sequence&
    repeatDate () const;

    repeatDate_sequence&
    repeatDate ();

    void
    repeatDate (const repeatDate_sequence& s);

    // repeatTime
    // 
    typedef ::xml_schema::time repeatTime_type;
    typedef ::xsd::cxx::tree::sequence< repeatTime_type > repeatTime_sequence;
    typedef repeatTime_sequence::iterator repeatTime_iterator;
    typedef repeatTime_sequence::const_iterator repeatTime_const_iterator;
    typedef ::xsd::cxx::tree::traits< repeatTime_type, char > repeatTime_traits;

    const repeatTime_sequence&
    repeatTime () const;

    repeatTime_sequence&
    repeatTime ();

    void
    repeatTime (const repeatTime_sequence& s);

    // repeatChannel
    // 
    typedef ::ebuCore_2011::repeatChannel repeatChannel_type;
    typedef ::xsd::cxx::tree::sequence< repeatChannel_type > repeatChannel_sequence;
    typedef repeatChannel_sequence::iterator repeatChannel_iterator;
    typedef repeatChannel_sequence::const_iterator repeatChannel_const_iterator;
    typedef ::xsd::cxx::tree::traits< repeatChannel_type, char > repeatChannel_traits;

    const repeatChannel_sequence&
    repeatChannel () const;

    repeatChannel_sequence&
    repeatChannel ();

    void
    repeatChannel (const repeatChannel_sequence& s);

    // Constructors.
    //
    publicationHistoryType ();

    publicationHistoryType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    publicationHistoryType (const publicationHistoryType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual publicationHistoryType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~publicationHistoryType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    firstPublicationDate_optional firstPublicationDate_;
    firstPublicationTime_optional firstPublicationTime_;
    firstPublicationChannel_optional firstPublicationChannel_;
    repeatDate_sequence repeatDate_;
    repeatTime_sequence repeatTime_;
    repeatChannel_sequence repeatChannel_;
  };

  class entityType: public ::xml_schema::type
  {
    public:
    // contactDetails
    // 
    typedef ::ebuCore_2011::contactDetailsType contactDetails_type;
    typedef ::xsd::cxx::tree::sequence< contactDetails_type > contactDetails_sequence;
    typedef contactDetails_sequence::iterator contactDetails_iterator;
    typedef contactDetails_sequence::const_iterator contactDetails_const_iterator;
    typedef ::xsd::cxx::tree::traits< contactDetails_type, char > contactDetails_traits;

    const contactDetails_sequence&
    contactDetails () const;

    contactDetails_sequence&
    contactDetails ();

    void
    contactDetails (const contactDetails_sequence& s);

    // organisationDetails
    // 
    typedef ::ebuCore_2011::organisationDetailsType organisationDetails_type;
    typedef ::xsd::cxx::tree::optional< organisationDetails_type > organisationDetails_optional;
    typedef ::xsd::cxx::tree::traits< organisationDetails_type, char > organisationDetails_traits;

    const organisationDetails_optional&
    organisationDetails () const;

    organisationDetails_optional&
    organisationDetails ();

    void
    organisationDetails (const organisationDetails_type& x);

    void
    organisationDetails (const organisationDetails_optional& x);

    void
    organisationDetails (::std::auto_ptr< organisationDetails_type > p);

    // role
    // 
    typedef ::ebuCore_2011::role role_type;
    typedef ::xsd::cxx::tree::sequence< role_type > role_sequence;
    typedef role_sequence::iterator role_iterator;
    typedef role_sequence::const_iterator role_const_iterator;
    typedef ::xsd::cxx::tree::traits< role_type, char > role_traits;

    const role_sequence&
    role () const;

    role_sequence&
    role ();

    void
    role (const role_sequence& s);

    // entityId
    // 
    typedef ::xml_schema::uri entityId_type;
    typedef ::xsd::cxx::tree::optional< entityId_type > entityId_optional;
    typedef ::xsd::cxx::tree::traits< entityId_type, char > entityId_traits;

    const entityId_optional&
    entityId () const;

    entityId_optional&
    entityId ();

    void
    entityId (const entityId_type& x);

    void
    entityId (const entityId_optional& x);

    void
    entityId (::std::auto_ptr< entityId_type > p);

    // Constructors.
    //
    entityType ();

    entityType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    entityType (const entityType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual entityType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~entityType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    contactDetails_sequence contactDetails_;
    organisationDetails_optional organisationDetails_;
    role_sequence role_;
    entityId_optional entityId_;
  };

  class contactDetailsType: public ::xml_schema::type
  {
    public:
    // name
    // 
    typedef ::xml_schema::string name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // givenName
    // 
    typedef ::xml_schema::string givenName_type;
    typedef ::xsd::cxx::tree::optional< givenName_type > givenName_optional;
    typedef ::xsd::cxx::tree::traits< givenName_type, char > givenName_traits;

    const givenName_optional&
    givenName () const;

    givenName_optional&
    givenName ();

    void
    givenName (const givenName_type& x);

    void
    givenName (const givenName_optional& x);

    void
    givenName (::std::auto_ptr< givenName_type > p);

    // familyName
    // 
    typedef ::xml_schema::string familyName_type;
    typedef ::xsd::cxx::tree::optional< familyName_type > familyName_optional;
    typedef ::xsd::cxx::tree::traits< familyName_type, char > familyName_traits;

    const familyName_optional&
    familyName () const;

    familyName_optional&
    familyName ();

    void
    familyName (const familyName_type& x);

    void
    familyName (const familyName_optional& x);

    void
    familyName (::std::auto_ptr< familyName_type > p);

    // username
    // 
    typedef ::xml_schema::string username_type;
    typedef ::xsd::cxx::tree::optional< username_type > username_optional;
    typedef ::xsd::cxx::tree::traits< username_type, char > username_traits;

    const username_optional&
    username () const;

    username_optional&
    username ();

    void
    username (const username_type& x);

    void
    username (const username_optional& x);

    void
    username (::std::auto_ptr< username_type > p);

    // occupation
    // 
    typedef ::xml_schema::string occupation_type;
    typedef ::xsd::cxx::tree::optional< occupation_type > occupation_optional;
    typedef ::xsd::cxx::tree::traits< occupation_type, char > occupation_traits;

    const occupation_optional&
    occupation () const;

    occupation_optional&
    occupation ();

    void
    occupation (const occupation_type& x);

    void
    occupation (const occupation_optional& x);

    void
    occupation (::std::auto_ptr< occupation_type > p);

    // details
    // 
    typedef ::ebuCore_2011::detailsType details_type;
    typedef ::xsd::cxx::tree::sequence< details_type > details_sequence;
    typedef details_sequence::iterator details_iterator;
    typedef details_sequence::const_iterator details_const_iterator;
    typedef ::xsd::cxx::tree::traits< details_type, char > details_traits;

    const details_sequence&
    details () const;

    details_sequence&
    details ();

    void
    details (const details_sequence& s);

    // stageName
    // 
    typedef ::xml_schema::string stageName_type;
    typedef ::xsd::cxx::tree::sequence< stageName_type > stageName_sequence;
    typedef stageName_sequence::iterator stageName_iterator;
    typedef stageName_sequence::const_iterator stageName_const_iterator;
    typedef ::xsd::cxx::tree::traits< stageName_type, char > stageName_traits;

    const stageName_sequence&
    stageName () const;

    stageName_sequence&
    stageName ();

    void
    stageName (const stageName_sequence& s);

    // relatedContacts
    // 
    typedef ::ebuCore_2011::entityType relatedContacts_type;
    typedef ::xsd::cxx::tree::sequence< relatedContacts_type > relatedContacts_sequence;
    typedef relatedContacts_sequence::iterator relatedContacts_iterator;
    typedef relatedContacts_sequence::const_iterator relatedContacts_const_iterator;
    typedef ::xsd::cxx::tree::traits< relatedContacts_type, char > relatedContacts_traits;

    const relatedContacts_sequence&
    relatedContacts () const;

    relatedContacts_sequence&
    relatedContacts ();

    void
    relatedContacts (const relatedContacts_sequence& s);

    // contactId
    // 
    typedef ::xml_schema::uri contactId_type;
    typedef ::xsd::cxx::tree::optional< contactId_type > contactId_optional;
    typedef ::xsd::cxx::tree::traits< contactId_type, char > contactId_traits;

    const contactId_optional&
    contactId () const;

    contactId_optional&
    contactId ();

    void
    contactId (const contactId_type& x);

    void
    contactId (const contactId_optional& x);

    void
    contactId (::std::auto_ptr< contactId_type > p);

    // Constructors.
    //
    contactDetailsType ();

    contactDetailsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    contactDetailsType (const contactDetailsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual contactDetailsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~contactDetailsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    name_optional name_;
    givenName_optional givenName_;
    familyName_optional familyName_;
    username_optional username_;
    occupation_optional occupation_;
    details_sequence details_;
    stageName_sequence stageName_;
    relatedContacts_sequence relatedContacts_;
    contactId_optional contactId_;
  };

  class organisationDetailsType: public ::xml_schema::type
  {
    public:
    // organisationName
    // 
    typedef ::dc::elementType organisationName_type;
    typedef ::xsd::cxx::tree::traits< organisationName_type, char > organisationName_traits;

    const organisationName_type&
    organisationName () const;

    organisationName_type&
    organisationName ();

    void
    organisationName (const organisationName_type& x);

    void
    organisationName (::std::auto_ptr< organisationName_type > p);

    // organisationDepartment
    // 
    typedef ::ebuCore_2011::organisationDepartment organisationDepartment_type;
    typedef ::xsd::cxx::tree::optional< organisationDepartment_type > organisationDepartment_optional;
    typedef ::xsd::cxx::tree::traits< organisationDepartment_type, char > organisationDepartment_traits;

    const organisationDepartment_optional&
    organisationDepartment () const;

    organisationDepartment_optional&
    organisationDepartment ();

    void
    organisationDepartment (const organisationDepartment_type& x);

    void
    organisationDepartment (const organisationDepartment_optional& x);

    void
    organisationDepartment (::std::auto_ptr< organisationDepartment_type > p);

    // details
    // 
    typedef ::ebuCore_2011::detailsType details_type;
    typedef ::xsd::cxx::tree::sequence< details_type > details_sequence;
    typedef details_sequence::iterator details_iterator;
    typedef details_sequence::const_iterator details_const_iterator;
    typedef ::xsd::cxx::tree::traits< details_type, char > details_traits;

    const details_sequence&
    details () const;

    details_sequence&
    details ();

    void
    details (const details_sequence& s);

    // contacts
    // 
    typedef ::ebuCore_2011::entityType contacts_type;
    typedef ::xsd::cxx::tree::sequence< contacts_type > contacts_sequence;
    typedef contacts_sequence::iterator contacts_iterator;
    typedef contacts_sequence::const_iterator contacts_const_iterator;
    typedef ::xsd::cxx::tree::traits< contacts_type, char > contacts_traits;

    const contacts_sequence&
    contacts () const;

    contacts_sequence&
    contacts ();

    void
    contacts (const contacts_sequence& s);

    // organisationId
    // 
    typedef ::xml_schema::uri organisationId_type;
    typedef ::xsd::cxx::tree::optional< organisationId_type > organisationId_optional;
    typedef ::xsd::cxx::tree::traits< organisationId_type, char > organisationId_traits;

    const organisationId_optional&
    organisationId () const;

    organisationId_optional&
    organisationId ();

    void
    organisationId (const organisationId_type& x);

    void
    organisationId (const organisationId_optional& x);

    void
    organisationId (::std::auto_ptr< organisationId_type > p);

    // Constructors.
    //
    organisationDetailsType (const organisationName_type&);

    organisationDetailsType (::std::auto_ptr< organisationName_type >&);

    organisationDetailsType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    organisationDetailsType (const organisationDetailsType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual organisationDetailsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~organisationDetailsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< organisationName_type > organisationName_;
    organisationDepartment_optional organisationDepartment_;
    details_sequence details_;
    contacts_sequence contacts_;
    organisationId_optional organisationId_;
  };

  class detailsType: public ::xml_schema::type
  {
    public:
    // emailAddress
    // 
    typedef ::xml_schema::string emailAddress_type;
    typedef ::xsd::cxx::tree::optional< emailAddress_type > emailAddress_optional;
    typedef ::xsd::cxx::tree::traits< emailAddress_type, char > emailAddress_traits;

    const emailAddress_optional&
    emailAddress () const;

    emailAddress_optional&
    emailAddress ();

    void
    emailAddress (const emailAddress_type& x);

    void
    emailAddress (const emailAddress_optional& x);

    void
    emailAddress (::std::auto_ptr< emailAddress_type > p);

    // webAddress
    // 
    typedef ::xml_schema::string webAddress_type;
    typedef ::xsd::cxx::tree::optional< webAddress_type > webAddress_optional;
    typedef ::xsd::cxx::tree::traits< webAddress_type, char > webAddress_traits;

    const webAddress_optional&
    webAddress () const;

    webAddress_optional&
    webAddress ();

    void
    webAddress (const webAddress_type& x);

    void
    webAddress (const webAddress_optional& x);

    void
    webAddress (::std::auto_ptr< webAddress_type > p);

    // address
    // 
    typedef ::ebuCore_2011::addressType address_type;
    typedef ::xsd::cxx::tree::optional< address_type > address_optional;
    typedef ::xsd::cxx::tree::traits< address_type, char > address_traits;

    const address_optional&
    address () const;

    address_optional&
    address ();

    void
    address (const address_type& x);

    void
    address (const address_optional& x);

    void
    address (::std::auto_ptr< address_type > p);

    // telephoneNumber
    // 
    typedef ::xml_schema::string telephoneNumber_type;
    typedef ::xsd::cxx::tree::optional< telephoneNumber_type > telephoneNumber_optional;
    typedef ::xsd::cxx::tree::traits< telephoneNumber_type, char > telephoneNumber_traits;

    const telephoneNumber_optional&
    telephoneNumber () const;

    telephoneNumber_optional&
    telephoneNumber ();

    void
    telephoneNumber (const telephoneNumber_type& x);

    void
    telephoneNumber (const telephoneNumber_optional& x);

    void
    telephoneNumber (::std::auto_ptr< telephoneNumber_type > p);

    // mobileTelephoneNumber
    // 
    typedef ::xml_schema::string mobileTelephoneNumber_type;
    typedef ::xsd::cxx::tree::optional< mobileTelephoneNumber_type > mobileTelephoneNumber_optional;
    typedef ::xsd::cxx::tree::traits< mobileTelephoneNumber_type, char > mobileTelephoneNumber_traits;

    const mobileTelephoneNumber_optional&
    mobileTelephoneNumber () const;

    mobileTelephoneNumber_optional&
    mobileTelephoneNumber ();

    void
    mobileTelephoneNumber (const mobileTelephoneNumber_type& x);

    void
    mobileTelephoneNumber (const mobileTelephoneNumber_optional& x);

    void
    mobileTelephoneNumber (::std::auto_ptr< mobileTelephoneNumber_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    detailsType ();

    detailsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    detailsType (const detailsType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual detailsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~detailsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    emailAddress_optional emailAddress_;
    webAddress_optional webAddress_;
    address_optional address_;
    telephoneNumber_optional telephoneNumber_;
    mobileTelephoneNumber_optional mobileTelephoneNumber_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class addressType: public ::xml_schema::type
  {
    public:
    // addressLine
    // 
    typedef ::xml_schema::string addressLine_type;
    typedef ::xsd::cxx::tree::sequence< addressLine_type > addressLine_sequence;
    typedef addressLine_sequence::iterator addressLine_iterator;
    typedef addressLine_sequence::const_iterator addressLine_const_iterator;
    typedef ::xsd::cxx::tree::traits< addressLine_type, char > addressLine_traits;

    const addressLine_sequence&
    addressLine () const;

    addressLine_sequence&
    addressLine ();

    void
    addressLine (const addressLine_sequence& s);

    // addressTownCity
    // 
    typedef ::xml_schema::string addressTownCity_type;
    typedef ::xsd::cxx::tree::optional< addressTownCity_type > addressTownCity_optional;
    typedef ::xsd::cxx::tree::traits< addressTownCity_type, char > addressTownCity_traits;

    const addressTownCity_optional&
    addressTownCity () const;

    addressTownCity_optional&
    addressTownCity ();

    void
    addressTownCity (const addressTownCity_type& x);

    void
    addressTownCity (const addressTownCity_optional& x);

    void
    addressTownCity (::std::auto_ptr< addressTownCity_type > p);

    // addressCountyState
    // 
    typedef ::xml_schema::string addressCountyState_type;
    typedef ::xsd::cxx::tree::optional< addressCountyState_type > addressCountyState_optional;
    typedef ::xsd::cxx::tree::traits< addressCountyState_type, char > addressCountyState_traits;

    const addressCountyState_optional&
    addressCountyState () const;

    addressCountyState_optional&
    addressCountyState ();

    void
    addressCountyState (const addressCountyState_type& x);

    void
    addressCountyState (const addressCountyState_optional& x);

    void
    addressCountyState (::std::auto_ptr< addressCountyState_type > p);

    // addressDeliveryCode
    // 
    typedef ::xml_schema::string addressDeliveryCode_type;
    typedef ::xsd::cxx::tree::optional< addressDeliveryCode_type > addressDeliveryCode_optional;
    typedef ::xsd::cxx::tree::traits< addressDeliveryCode_type, char > addressDeliveryCode_traits;

    const addressDeliveryCode_optional&
    addressDeliveryCode () const;

    addressDeliveryCode_optional&
    addressDeliveryCode ();

    void
    addressDeliveryCode (const addressDeliveryCode_type& x);

    void
    addressDeliveryCode (const addressDeliveryCode_optional& x);

    void
    addressDeliveryCode (::std::auto_ptr< addressDeliveryCode_type > p);

    // country
    // 
    typedef ::ebuCore_2011::country country_type;
    typedef ::xsd::cxx::tree::optional< country_type > country_optional;
    typedef ::xsd::cxx::tree::traits< country_type, char > country_traits;

    const country_optional&
    country () const;

    country_optional&
    country ();

    void
    country (const country_type& x);

    void
    country (const country_optional& x);

    void
    country (::std::auto_ptr< country_type > p);

    // Constructors.
    //
    addressType ();

    addressType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    addressType (const addressType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual addressType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~addressType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    addressLine_sequence addressLine_;
    addressTownCity_optional addressTownCity_;
    addressCountyState_optional addressCountyState_;
    addressDeliveryCode_optional addressDeliveryCode_;
    country_optional country_;
  };

  class editUnitNumberType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >
  {
    public:
    // editRate
    // 
    typedef ::xml_schema::positive_integer editRate_type;
    typedef ::xsd::cxx::tree::optional< editRate_type > editRate_optional;
    typedef ::xsd::cxx::tree::traits< editRate_type, char > editRate_traits;

    const editRate_optional&
    editRate () const;

    editRate_optional&
    editRate ();

    void
    editRate (const editRate_type& x);

    void
    editRate (const editRate_optional& x);

    // factorNumerator
    // 
    typedef ::xml_schema::positive_integer factorNumerator_type;
    typedef ::xsd::cxx::tree::traits< factorNumerator_type, char > factorNumerator_traits;

    const factorNumerator_type&
    factorNumerator () const;

    factorNumerator_type&
    factorNumerator ();

    void
    factorNumerator (const factorNumerator_type& x);

    static factorNumerator_type
    factorNumerator_default_value ();

    // factorDenominator
    // 
    typedef ::xml_schema::positive_integer factorDenominator_type;
    typedef ::xsd::cxx::tree::traits< factorDenominator_type, char > factorDenominator_traits;

    const factorDenominator_type&
    factorDenominator () const;

    factorDenominator_type&
    factorDenominator ();

    void
    factorDenominator (const factorDenominator_type& x);

    static factorDenominator_type
    factorDenominator_default_value ();

    // Constructors.
    //
    editUnitNumberType (const ::xml_schema::long_&);

    editUnitNumberType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    editUnitNumberType (const editUnitNumberType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual editUnitNumberType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~editUnitNumberType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    editRate_optional editRate_;
    ::xsd::cxx::tree::one< factorNumerator_type > factorNumerator_;
    ::xsd::cxx::tree::one< factorDenominator_type > factorDenominator_;
  };

  class ratingType: public ::xml_schema::type
  {
    public:
    // ratingValue
    // 
    typedef ::xml_schema::string ratingValue_type;
    typedef ::xsd::cxx::tree::traits< ratingValue_type, char > ratingValue_traits;

    const ratingValue_type&
    ratingValue () const;

    ratingValue_type&
    ratingValue ();

    void
    ratingValue (const ratingValue_type& x);

    void
    ratingValue (::std::auto_ptr< ratingValue_type > p);

    // ratingScaleMaxValue
    // 
    typedef ::xml_schema::string ratingScaleMaxValue_type;
    typedef ::xsd::cxx::tree::traits< ratingScaleMaxValue_type, char > ratingScaleMaxValue_traits;

    const ratingScaleMaxValue_type&
    ratingScaleMaxValue () const;

    ratingScaleMaxValue_type&
    ratingScaleMaxValue ();

    void
    ratingScaleMaxValue (const ratingScaleMaxValue_type& x);

    void
    ratingScaleMaxValue (::std::auto_ptr< ratingScaleMaxValue_type > p);

    // ratingScaleMinValue
    // 
    typedef ::xml_schema::string ratingScaleMinValue_type;
    typedef ::xsd::cxx::tree::traits< ratingScaleMinValue_type, char > ratingScaleMinValue_traits;

    const ratingScaleMinValue_type&
    ratingScaleMinValue () const;

    ratingScaleMinValue_type&
    ratingScaleMinValue ();

    void
    ratingScaleMinValue (const ratingScaleMinValue_type& x);

    void
    ratingScaleMinValue (::std::auto_ptr< ratingScaleMinValue_type > p);

    // ratingProvider
    // 
    typedef ::ebuCore_2011::entityType ratingProvider_type;
    typedef ::xsd::cxx::tree::traits< ratingProvider_type, char > ratingProvider_traits;

    const ratingProvider_type&
    ratingProvider () const;

    ratingProvider_type&
    ratingProvider ();

    void
    ratingProvider (const ratingProvider_type& x);

    void
    ratingProvider (::std::auto_ptr< ratingProvider_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // Constructors.
    //
    ratingType (const ratingValue_type&,
                const ratingScaleMaxValue_type&,
                const ratingScaleMinValue_type&,
                const ratingProvider_type&);

    ratingType (const ratingValue_type&,
                const ratingScaleMaxValue_type&,
                const ratingScaleMinValue_type&,
                ::std::auto_ptr< ratingProvider_type >&);

    ratingType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ratingType (const ratingType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual ratingType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ratingType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ratingValue_type > ratingValue_;
    ::xsd::cxx::tree::one< ratingScaleMaxValue_type > ratingScaleMaxValue_;
    ::xsd::cxx::tree::one< ratingScaleMinValue_type > ratingScaleMinValue_;
    ::xsd::cxx::tree::one< ratingProvider_type > ratingProvider_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
  };

  class lengthType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >
  {
    public:
    // unit
    // 
    typedef ::xml_schema::string unit_type;
    typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
    typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

    const unit_optional&
    unit () const;

    unit_optional&
    unit ();

    void
    unit (const unit_type& x);

    void
    unit (const unit_optional& x);

    void
    unit (::std::auto_ptr< unit_type > p);

    // Constructors.
    //
    lengthType (const ::xml_schema::non_negative_integer&);

    lengthType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    lengthType (const lengthType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual lengthType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~lengthType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    unit_optional unit_;
  };

  class imageFormatType: public ::xml_schema::type
  {
    public:
    // regionDelimX
    // 
    typedef ::xml_schema::non_negative_integer regionDelimX_type;
    typedef ::xsd::cxx::tree::optional< regionDelimX_type > regionDelimX_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimX_type, char > regionDelimX_traits;

    const regionDelimX_optional&
    regionDelimX () const;

    regionDelimX_optional&
    regionDelimX ();

    void
    regionDelimX (const regionDelimX_type& x);

    void
    regionDelimX (const regionDelimX_optional& x);

    // regionDelimY
    // 
    typedef ::xml_schema::non_negative_integer regionDelimY_type;
    typedef ::xsd::cxx::tree::optional< regionDelimY_type > regionDelimY_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimY_type, char > regionDelimY_traits;

    const regionDelimY_optional&
    regionDelimY () const;

    regionDelimY_optional&
    regionDelimY ();

    void
    regionDelimY (const regionDelimY_type& x);

    void
    regionDelimY (const regionDelimY_optional& x);

    // width
    // 
    typedef ::ebuCore_2011::lengthType width_type;
    typedef ::xsd::cxx::tree::optional< width_type > width_optional;
    typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

    const width_optional&
    width () const;

    width_optional&
    width ();

    void
    width (const width_type& x);

    void
    width (const width_optional& x);

    void
    width (::std::auto_ptr< width_type > p);

    // height
    // 
    typedef ::ebuCore_2011::lengthType height_type;
    typedef ::xsd::cxx::tree::optional< height_type > height_optional;
    typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

    const height_optional&
    height () const;

    height_optional&
    height ();

    void
    height (const height_type& x);

    void
    height (const height_optional& x);

    void
    height (::std::auto_ptr< height_type > p);

    // orientation
    // 
    typedef ::ebuCore_2011::orientation orientation_type;
    typedef ::xsd::cxx::tree::optional< orientation_type > orientation_optional;
    typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

    const orientation_optional&
    orientation () const;

    orientation_optional&
    orientation ();

    void
    orientation (const orientation_type& x);

    void
    orientation (const orientation_optional& x);

    void
    orientation (::std::auto_ptr< orientation_type > p);

    // imageEncoding
    // 
    typedef ::ebuCore_2011::imageEncoding imageEncoding_type;
    typedef ::xsd::cxx::tree::sequence< imageEncoding_type > imageEncoding_sequence;
    typedef imageEncoding_sequence::iterator imageEncoding_iterator;
    typedef imageEncoding_sequence::const_iterator imageEncoding_const_iterator;
    typedef ::xsd::cxx::tree::traits< imageEncoding_type, char > imageEncoding_traits;

    const imageEncoding_sequence&
    imageEncoding () const;

    imageEncoding_sequence&
    imageEncoding ();

    void
    imageEncoding (const imageEncoding_sequence& s);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2011::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2011::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2011::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2011::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2011::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2011::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2011::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2011::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2011::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2011::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2011::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2011::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2011::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // imageFormatId
    // 
    typedef ::xml_schema::uri imageFormatId_type;
    typedef ::xsd::cxx::tree::optional< imageFormatId_type > imageFormatId_optional;
    typedef ::xsd::cxx::tree::traits< imageFormatId_type, char > imageFormatId_traits;

    const imageFormatId_optional&
    imageFormatId () const;

    imageFormatId_optional&
    imageFormatId ();

    void
    imageFormatId (const imageFormatId_type& x);

    void
    imageFormatId (const imageFormatId_optional& x);

    void
    imageFormatId (::std::auto_ptr< imageFormatId_type > p);

    // imageFormatName
    // 
    typedef ::xml_schema::string imageFormatName_type;
    typedef ::xsd::cxx::tree::optional< imageFormatName_type > imageFormatName_optional;
    typedef ::xsd::cxx::tree::traits< imageFormatName_type, char > imageFormatName_traits;

    const imageFormatName_optional&
    imageFormatName () const;

    imageFormatName_optional&
    imageFormatName ();

    void
    imageFormatName (const imageFormatName_type& x);

    void
    imageFormatName (const imageFormatName_optional& x);

    void
    imageFormatName (::std::auto_ptr< imageFormatName_type > p);

    // imageFormatDefinition
    // 
    typedef ::xml_schema::string imageFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< imageFormatDefinition_type > imageFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< imageFormatDefinition_type, char > imageFormatDefinition_traits;

    const imageFormatDefinition_optional&
    imageFormatDefinition () const;

    imageFormatDefinition_optional&
    imageFormatDefinition ();

    void
    imageFormatDefinition (const imageFormatDefinition_type& x);

    void
    imageFormatDefinition (const imageFormatDefinition_optional& x);

    void
    imageFormatDefinition (::std::auto_ptr< imageFormatDefinition_type > p);

    // Constructors.
    //
    imageFormatType ();

    imageFormatType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    imageFormatType (const imageFormatType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual imageFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~imageFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    regionDelimX_optional regionDelimX_;
    regionDelimY_optional regionDelimY_;
    width_optional width_;
    height_optional height_;
    orientation_optional orientation_;
    imageEncoding_sequence imageEncoding_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    imageFormatId_optional imageFormatId_;
    imageFormatName_optional imageFormatName_;
    imageFormatDefinition_optional imageFormatDefinition_;
  };

  class videoFormatType: public ::xml_schema::type
  {
    public:
    // regionDelimX
    // 
    typedef ::xml_schema::non_negative_integer regionDelimX_type;
    typedef ::xsd::cxx::tree::optional< regionDelimX_type > regionDelimX_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimX_type, char > regionDelimX_traits;

    const regionDelimX_optional&
    regionDelimX () const;

    regionDelimX_optional&
    regionDelimX ();

    void
    regionDelimX (const regionDelimX_type& x);

    void
    regionDelimX (const regionDelimX_optional& x);

    // regionDelimY
    // 
    typedef ::xml_schema::non_negative_integer regionDelimY_type;
    typedef ::xsd::cxx::tree::optional< regionDelimY_type > regionDelimY_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimY_type, char > regionDelimY_traits;

    const regionDelimY_optional&
    regionDelimY () const;

    regionDelimY_optional&
    regionDelimY ();

    void
    regionDelimY (const regionDelimY_type& x);

    void
    regionDelimY (const regionDelimY_optional& x);

    // width
    // 
    typedef ::ebuCore_2011::lengthType width_type;
    typedef ::xsd::cxx::tree::optional< width_type > width_optional;
    typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

    const width_optional&
    width () const;

    width_optional&
    width ();

    void
    width (const width_type& x);

    void
    width (const width_optional& x);

    void
    width (::std::auto_ptr< width_type > p);

    // height
    // 
    typedef ::ebuCore_2011::lengthType height_type;
    typedef ::xsd::cxx::tree::optional< height_type > height_optional;
    typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

    const height_optional&
    height () const;

    height_optional&
    height ();

    void
    height (const height_type& x);

    void
    height (const height_optional& x);

    void
    height (::std::auto_ptr< height_type > p);

    // aspectRatio
    // 
    typedef ::ebuCore_2011::aspectRatio aspectRatio_type;
    typedef ::xsd::cxx::tree::optional< aspectRatio_type > aspectRatio_optional;
    typedef ::xsd::cxx::tree::traits< aspectRatio_type, char > aspectRatio_traits;

    const aspectRatio_optional&
    aspectRatio () const;

    aspectRatio_optional&
    aspectRatio ();

    void
    aspectRatio (const aspectRatio_type& x);

    void
    aspectRatio (const aspectRatio_optional& x);

    void
    aspectRatio (::std::auto_ptr< aspectRatio_type > p);

    // videoEncoding
    // 
    typedef ::ebuCore_2011::videoEncoding videoEncoding_type;
    typedef ::xsd::cxx::tree::sequence< videoEncoding_type > videoEncoding_sequence;
    typedef videoEncoding_sequence::iterator videoEncoding_iterator;
    typedef videoEncoding_sequence::const_iterator videoEncoding_const_iterator;
    typedef ::xsd::cxx::tree::traits< videoEncoding_type, char > videoEncoding_traits;

    const videoEncoding_sequence&
    videoEncoding () const;

    videoEncoding_sequence&
    videoEncoding ();

    void
    videoEncoding (const videoEncoding_sequence& s);

    // videoTrack
    // 
    typedef ::ebuCore_2011::videoTrack videoTrack_type;
    typedef ::xsd::cxx::tree::sequence< videoTrack_type > videoTrack_sequence;
    typedef videoTrack_sequence::iterator videoTrack_iterator;
    typedef videoTrack_sequence::const_iterator videoTrack_const_iterator;
    typedef ::xsd::cxx::tree::traits< videoTrack_type, char > videoTrack_traits;

    const videoTrack_sequence&
    videoTrack () const;

    videoTrack_sequence&
    videoTrack ();

    void
    videoTrack (const videoTrack_sequence& s);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2011::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2011::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2011::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2011::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2011::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2011::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2011::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2011::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2011::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2011::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2011::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2011::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2011::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // videoFormatId
    // 
    typedef ::xml_schema::uri videoFormatId_type;
    typedef ::xsd::cxx::tree::optional< videoFormatId_type > videoFormatId_optional;
    typedef ::xsd::cxx::tree::traits< videoFormatId_type, char > videoFormatId_traits;

    const videoFormatId_optional&
    videoFormatId () const;

    videoFormatId_optional&
    videoFormatId ();

    void
    videoFormatId (const videoFormatId_type& x);

    void
    videoFormatId (const videoFormatId_optional& x);

    void
    videoFormatId (::std::auto_ptr< videoFormatId_type > p);

    // videoFormatName
    // 
    typedef ::xml_schema::string videoFormatName_type;
    typedef ::xsd::cxx::tree::optional< videoFormatName_type > videoFormatName_optional;
    typedef ::xsd::cxx::tree::traits< videoFormatName_type, char > videoFormatName_traits;

    const videoFormatName_optional&
    videoFormatName () const;

    videoFormatName_optional&
    videoFormatName ();

    void
    videoFormatName (const videoFormatName_type& x);

    void
    videoFormatName (const videoFormatName_optional& x);

    void
    videoFormatName (::std::auto_ptr< videoFormatName_type > p);

    // videoFormatDefinition
    // 
    typedef ::xml_schema::string videoFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< videoFormatDefinition_type > videoFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< videoFormatDefinition_type, char > videoFormatDefinition_traits;

    const videoFormatDefinition_optional&
    videoFormatDefinition () const;

    videoFormatDefinition_optional&
    videoFormatDefinition ();

    void
    videoFormatDefinition (const videoFormatDefinition_type& x);

    void
    videoFormatDefinition (const videoFormatDefinition_optional& x);

    void
    videoFormatDefinition (::std::auto_ptr< videoFormatDefinition_type > p);

    // Constructors.
    //
    videoFormatType ();

    videoFormatType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    videoFormatType (const videoFormatType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual videoFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~videoFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    regionDelimX_optional regionDelimX_;
    regionDelimY_optional regionDelimY_;
    width_optional width_;
    height_optional height_;
    aspectRatio_optional aspectRatio_;
    videoEncoding_sequence videoEncoding_;
    videoTrack_sequence videoTrack_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    videoFormatId_optional videoFormatId_;
    videoFormatName_optional videoFormatName_;
    videoFormatDefinition_optional videoFormatDefinition_;
  };

  class audioFormatType: public ::xml_schema::type
  {
    public:
    // audioEncoding
    // 
    typedef ::ebuCore_2011::audioEncoding audioEncoding_type;
    typedef ::xsd::cxx::tree::sequence< audioEncoding_type > audioEncoding_sequence;
    typedef audioEncoding_sequence::iterator audioEncoding_iterator;
    typedef audioEncoding_sequence::const_iterator audioEncoding_const_iterator;
    typedef ::xsd::cxx::tree::traits< audioEncoding_type, char > audioEncoding_traits;

    const audioEncoding_sequence&
    audioEncoding () const;

    audioEncoding_sequence&
    audioEncoding ();

    void
    audioEncoding (const audioEncoding_sequence& s);

    // audioTrackConfiguration
    // 
    typedef ::ebuCore_2011::audioTrackConfiguration audioTrackConfiguration_type;
    typedef ::xsd::cxx::tree::optional< audioTrackConfiguration_type > audioTrackConfiguration_optional;
    typedef ::xsd::cxx::tree::traits< audioTrackConfiguration_type, char > audioTrackConfiguration_traits;

    const audioTrackConfiguration_optional&
    audioTrackConfiguration () const;

    audioTrackConfiguration_optional&
    audioTrackConfiguration ();

    void
    audioTrackConfiguration (const audioTrackConfiguration_type& x);

    void
    audioTrackConfiguration (const audioTrackConfiguration_optional& x);

    void
    audioTrackConfiguration (::std::auto_ptr< audioTrackConfiguration_type > p);

    // audioTrack
    // 
    typedef ::ebuCore_2011::audioTrack audioTrack_type;
    typedef ::xsd::cxx::tree::sequence< audioTrack_type > audioTrack_sequence;
    typedef audioTrack_sequence::iterator audioTrack_iterator;
    typedef audioTrack_sequence::const_iterator audioTrack_const_iterator;
    typedef ::xsd::cxx::tree::traits< audioTrack_type, char > audioTrack_traits;

    const audioTrack_sequence&
    audioTrack () const;

    audioTrack_sequence&
    audioTrack ();

    void
    audioTrack (const audioTrack_sequence& s);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2011::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2011::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2011::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2011::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2011::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2011::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2011::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2011::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2011::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2011::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2011::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2011::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2011::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // audioFormatId
    // 
    typedef ::xml_schema::uri audioFormatId_type;
    typedef ::xsd::cxx::tree::optional< audioFormatId_type > audioFormatId_optional;
    typedef ::xsd::cxx::tree::traits< audioFormatId_type, char > audioFormatId_traits;

    const audioFormatId_optional&
    audioFormatId () const;

    audioFormatId_optional&
    audioFormatId ();

    void
    audioFormatId (const audioFormatId_type& x);

    void
    audioFormatId (const audioFormatId_optional& x);

    void
    audioFormatId (::std::auto_ptr< audioFormatId_type > p);

    // audioFormatName
    // 
    typedef ::xml_schema::string audioFormatName_type;
    typedef ::xsd::cxx::tree::optional< audioFormatName_type > audioFormatName_optional;
    typedef ::xsd::cxx::tree::traits< audioFormatName_type, char > audioFormatName_traits;

    const audioFormatName_optional&
    audioFormatName () const;

    audioFormatName_optional&
    audioFormatName ();

    void
    audioFormatName (const audioFormatName_type& x);

    void
    audioFormatName (const audioFormatName_optional& x);

    void
    audioFormatName (::std::auto_ptr< audioFormatName_type > p);

    // audioFormatDefinition
    // 
    typedef ::xml_schema::string audioFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< audioFormatDefinition_type > audioFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< audioFormatDefinition_type, char > audioFormatDefinition_traits;

    const audioFormatDefinition_optional&
    audioFormatDefinition () const;

    audioFormatDefinition_optional&
    audioFormatDefinition ();

    void
    audioFormatDefinition (const audioFormatDefinition_type& x);

    void
    audioFormatDefinition (const audioFormatDefinition_optional& x);

    void
    audioFormatDefinition (::std::auto_ptr< audioFormatDefinition_type > p);

    // Constructors.
    //
    audioFormatType ();

    audioFormatType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    audioFormatType (const audioFormatType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual audioFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~audioFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    audioEncoding_sequence audioEncoding_;
    audioTrackConfiguration_optional audioTrackConfiguration_;
    audioTrack_sequence audioTrack_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    audioFormatId_optional audioFormatId_;
    audioFormatName_optional audioFormatName_;
    audioFormatDefinition_optional audioFormatDefinition_;
  };

  class dataFormatType: public ::xml_schema::type
  {
    public:
    // captioningFormat
    // 
    typedef ::ebuCore_2011::captioningFormat captioningFormat_type;
    typedef ::xsd::cxx::tree::sequence< captioningFormat_type > captioningFormat_sequence;
    typedef captioningFormat_sequence::iterator captioningFormat_iterator;
    typedef captioningFormat_sequence::const_iterator captioningFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< captioningFormat_type, char > captioningFormat_traits;

    const captioningFormat_sequence&
    captioningFormat () const;

    captioningFormat_sequence&
    captioningFormat ();

    void
    captioningFormat (const captioningFormat_sequence& s);

    // ancillaryDataFormat
    // 
    typedef ::ebuCore_2011::ancillaryDataFormat ancillaryDataFormat_type;
    typedef ::xsd::cxx::tree::sequence< ancillaryDataFormat_type > ancillaryDataFormat_sequence;
    typedef ancillaryDataFormat_sequence::iterator ancillaryDataFormat_iterator;
    typedef ancillaryDataFormat_sequence::const_iterator ancillaryDataFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< ancillaryDataFormat_type, char > ancillaryDataFormat_traits;

    const ancillaryDataFormat_sequence&
    ancillaryDataFormat () const;

    ancillaryDataFormat_sequence&
    ancillaryDataFormat ();

    void
    ancillaryDataFormat (const ancillaryDataFormat_sequence& s);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2011::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2011::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2011::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2011::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2011::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2011::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2011::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2011::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2011::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2011::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2011::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2011::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2011::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // dataFormatId
    // 
    typedef ::xml_schema::uri dataFormatId_type;
    typedef ::xsd::cxx::tree::optional< dataFormatId_type > dataFormatId_optional;
    typedef ::xsd::cxx::tree::traits< dataFormatId_type, char > dataFormatId_traits;

    const dataFormatId_optional&
    dataFormatId () const;

    dataFormatId_optional&
    dataFormatId ();

    void
    dataFormatId (const dataFormatId_type& x);

    void
    dataFormatId (const dataFormatId_optional& x);

    void
    dataFormatId (::std::auto_ptr< dataFormatId_type > p);

    // dataFormatName
    // 
    typedef ::xml_schema::string dataFormatName_type;
    typedef ::xsd::cxx::tree::optional< dataFormatName_type > dataFormatName_optional;
    typedef ::xsd::cxx::tree::traits< dataFormatName_type, char > dataFormatName_traits;

    const dataFormatName_optional&
    dataFormatName () const;

    dataFormatName_optional&
    dataFormatName ();

    void
    dataFormatName (const dataFormatName_type& x);

    void
    dataFormatName (const dataFormatName_optional& x);

    void
    dataFormatName (::std::auto_ptr< dataFormatName_type > p);

    // dataFormatDefinition
    // 
    typedef ::xml_schema::string dataFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< dataFormatDefinition_type > dataFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< dataFormatDefinition_type, char > dataFormatDefinition_traits;

    const dataFormatDefinition_optional&
    dataFormatDefinition () const;

    dataFormatDefinition_optional&
    dataFormatDefinition ();

    void
    dataFormatDefinition (const dataFormatDefinition_type& x);

    void
    dataFormatDefinition (const dataFormatDefinition_optional& x);

    void
    dataFormatDefinition (::std::auto_ptr< dataFormatDefinition_type > p);

    // Constructors.
    //
    dataFormatType ();

    dataFormatType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    dataFormatType (const dataFormatType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual dataFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~dataFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    captioningFormat_sequence captioningFormat_;
    ancillaryDataFormat_sequence ancillaryDataFormat_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    dataFormatId_optional dataFormatId_;
    dataFormatName_optional dataFormatName_;
    dataFormatDefinition_optional dataFormatDefinition_;
  };

  class documentFormatType: public ::xml_schema::type
  {
    public:
    // wordCount
    // 
    typedef ::xml_schema::integer wordCount_type;
    typedef ::xsd::cxx::tree::optional< wordCount_type > wordCount_optional;
    typedef ::xsd::cxx::tree::traits< wordCount_type, char > wordCount_traits;

    const wordCount_optional&
    wordCount () const;

    wordCount_optional&
    wordCount ();

    void
    wordCount (const wordCount_type& x);

    void
    wordCount (const wordCount_optional& x);

    // regionDelimX
    // 
    typedef ::xml_schema::non_negative_integer regionDelimX_type;
    typedef ::xsd::cxx::tree::optional< regionDelimX_type > regionDelimX_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimX_type, char > regionDelimX_traits;

    const regionDelimX_optional&
    regionDelimX () const;

    regionDelimX_optional&
    regionDelimX ();

    void
    regionDelimX (const regionDelimX_type& x);

    void
    regionDelimX (const regionDelimX_optional& x);

    // regionDelimY
    // 
    typedef ::xml_schema::non_negative_integer regionDelimY_type;
    typedef ::xsd::cxx::tree::optional< regionDelimY_type > regionDelimY_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimY_type, char > regionDelimY_traits;

    const regionDelimY_optional&
    regionDelimY () const;

    regionDelimY_optional&
    regionDelimY ();

    void
    regionDelimY (const regionDelimY_type& x);

    void
    regionDelimY (const regionDelimY_optional& x);

    // width
    // 
    typedef ::ebuCore_2011::lengthType width_type;
    typedef ::xsd::cxx::tree::optional< width_type > width_optional;
    typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

    const width_optional&
    width () const;

    width_optional&
    width ();

    void
    width (const width_type& x);

    void
    width (const width_optional& x);

    void
    width (::std::auto_ptr< width_type > p);

    // height
    // 
    typedef ::ebuCore_2011::lengthType height_type;
    typedef ::xsd::cxx::tree::optional< height_type > height_optional;
    typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

    const height_optional&
    height () const;

    height_optional&
    height ();

    void
    height (const height_type& x);

    void
    height (const height_optional& x);

    void
    height (::std::auto_ptr< height_type > p);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2011::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2011::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2011::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2011::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2011::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2011::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2011::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2011::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2011::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2011::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2011::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2011::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2011::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // documentFormatId
    // 
    typedef ::xml_schema::uri documentFormatId_type;
    typedef ::xsd::cxx::tree::optional< documentFormatId_type > documentFormatId_optional;
    typedef ::xsd::cxx::tree::traits< documentFormatId_type, char > documentFormatId_traits;

    const documentFormatId_optional&
    documentFormatId () const;

    documentFormatId_optional&
    documentFormatId ();

    void
    documentFormatId (const documentFormatId_type& x);

    void
    documentFormatId (const documentFormatId_optional& x);

    void
    documentFormatId (::std::auto_ptr< documentFormatId_type > p);

    // documentFormatName
    // 
    typedef ::xml_schema::string documentFormatName_type;
    typedef ::xsd::cxx::tree::optional< documentFormatName_type > documentFormatName_optional;
    typedef ::xsd::cxx::tree::traits< documentFormatName_type, char > documentFormatName_traits;

    const documentFormatName_optional&
    documentFormatName () const;

    documentFormatName_optional&
    documentFormatName ();

    void
    documentFormatName (const documentFormatName_type& x);

    void
    documentFormatName (const documentFormatName_optional& x);

    void
    documentFormatName (::std::auto_ptr< documentFormatName_type > p);

    // documentFormatDefinition
    // 
    typedef ::xml_schema::string documentFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< documentFormatDefinition_type > documentFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< documentFormatDefinition_type, char > documentFormatDefinition_traits;

    const documentFormatDefinition_optional&
    documentFormatDefinition () const;

    documentFormatDefinition_optional&
    documentFormatDefinition ();

    void
    documentFormatDefinition (const documentFormatDefinition_type& x);

    void
    documentFormatDefinition (const documentFormatDefinition_optional& x);

    void
    documentFormatDefinition (::std::auto_ptr< documentFormatDefinition_type > p);

    // Constructors.
    //
    documentFormatType ();

    documentFormatType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    documentFormatType (const documentFormatType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual documentFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~documentFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    wordCount_optional wordCount_;
    regionDelimX_optional regionDelimX_;
    regionDelimY_optional regionDelimY_;
    width_optional width_;
    height_optional height_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    documentFormatId_optional documentFormatId_;
    documentFormatName_optional documentFormatName_;
    documentFormatDefinition_optional documentFormatDefinition_;
  };

  class timeType: public ::xml_schema::type
  {
    public:
    // timecode
    // 
    typedef ::ebuCore_2011::timecode timecode_type;
    typedef ::xsd::cxx::tree::optional< timecode_type > timecode_optional;
    typedef ::xsd::cxx::tree::traits< timecode_type, char > timecode_traits;

    const timecode_optional&
    timecode () const;

    timecode_optional&
    timecode ();

    void
    timecode (const timecode_type& x);

    void
    timecode (const timecode_optional& x);

    void
    timecode (::std::auto_ptr< timecode_type > p);

    // normalPlayTime
    // 
    typedef ::xml_schema::time normalPlayTime_type;
    typedef ::xsd::cxx::tree::optional< normalPlayTime_type > normalPlayTime_optional;
    typedef ::xsd::cxx::tree::traits< normalPlayTime_type, char > normalPlayTime_traits;

    const normalPlayTime_optional&
    normalPlayTime () const;

    normalPlayTime_optional&
    normalPlayTime ();

    void
    normalPlayTime (const normalPlayTime_type& x);

    void
    normalPlayTime (const normalPlayTime_optional& x);

    void
    normalPlayTime (::std::auto_ptr< normalPlayTime_type > p);

    // editUnitNumber
    // 
    typedef ::ebuCore_2011::editUnitNumberType editUnitNumber_type;
    typedef ::xsd::cxx::tree::optional< editUnitNumber_type > editUnitNumber_optional;
    typedef ::xsd::cxx::tree::traits< editUnitNumber_type, char > editUnitNumber_traits;

    const editUnitNumber_optional&
    editUnitNumber () const;

    editUnitNumber_optional&
    editUnitNumber ();

    void
    editUnitNumber (const editUnitNumber_type& x);

    void
    editUnitNumber (const editUnitNumber_optional& x);

    void
    editUnitNumber (::std::auto_ptr< editUnitNumber_type > p);

    // time
    // 
    typedef ::ebuCore_2011::time time_type;
    typedef ::xsd::cxx::tree::optional< time_type > time_optional;
    typedef ::xsd::cxx::tree::traits< time_type, char > time_traits;

    const time_optional&
    time () const;

    time_optional&
    time ();

    void
    time (const time_type& x);

    void
    time (const time_optional& x);

    void
    time (::std::auto_ptr< time_type > p);

    // Constructors.
    //
    timeType ();

    timeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    timeType (const timeType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual timeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~timeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    timecode_optional timecode_;
    normalPlayTime_optional normalPlayTime_;
    editUnitNumber_optional editUnitNumber_;
    time_optional time_;
  };

  class durationType: public ::xml_schema::type
  {
    public:
    // timecode
    // 
    typedef ::ebuCore_2011::timecode1 timecode_type;
    typedef ::xsd::cxx::tree::optional< timecode_type > timecode_optional;
    typedef ::xsd::cxx::tree::traits< timecode_type, char > timecode_traits;

    const timecode_optional&
    timecode () const;

    timecode_optional&
    timecode ();

    void
    timecode (const timecode_type& x);

    void
    timecode (const timecode_optional& x);

    void
    timecode (::std::auto_ptr< timecode_type > p);

    // normalPlayTime
    // 
    typedef ::xml_schema::duration normalPlayTime_type;
    typedef ::xsd::cxx::tree::optional< normalPlayTime_type > normalPlayTime_optional;
    typedef ::xsd::cxx::tree::traits< normalPlayTime_type, char > normalPlayTime_traits;

    const normalPlayTime_optional&
    normalPlayTime () const;

    normalPlayTime_optional&
    normalPlayTime ();

    void
    normalPlayTime (const normalPlayTime_type& x);

    void
    normalPlayTime (const normalPlayTime_optional& x);

    void
    normalPlayTime (::std::auto_ptr< normalPlayTime_type > p);

    // editUnitNumber
    // 
    typedef ::ebuCore_2011::editUnitNumberType editUnitNumber_type;
    typedef ::xsd::cxx::tree::optional< editUnitNumber_type > editUnitNumber_optional;
    typedef ::xsd::cxx::tree::traits< editUnitNumber_type, char > editUnitNumber_traits;

    const editUnitNumber_optional&
    editUnitNumber () const;

    editUnitNumber_optional&
    editUnitNumber ();

    void
    editUnitNumber (const editUnitNumber_type& x);

    void
    editUnitNumber (const editUnitNumber_optional& x);

    void
    editUnitNumber (::std::auto_ptr< editUnitNumber_type > p);

    // time
    // 
    typedef ::ebuCore_2011::time1 time_type;
    typedef ::xsd::cxx::tree::optional< time_type > time_optional;
    typedef ::xsd::cxx::tree::traits< time_type, char > time_traits;

    const time_optional&
    time () const;

    time_optional&
    time ();

    void
    time (const time_type& x);

    void
    time (const time_optional& x);

    void
    time (::std::auto_ptr< time_type > p);

    // Constructors.
    //
    durationType ();

    durationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    durationType (const durationType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual durationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~durationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    timecode_optional timecode_;
    normalPlayTime_optional normalPlayTime_;
    editUnitNumber_optional editUnitNumber_;
    time_optional time_;
  };

  class String: public ::xml_schema::string
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // Constructors.
    //
    String ();

    String (const char*);

    String (const ::std::string&);

    String (const ::xml_schema::string&);

    String (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    String (const String& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual String*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~String ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
  };

  class Boolean: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    Boolean (const ::xml_schema::boolean&);

    Boolean (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Boolean (const Boolean& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Boolean*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Boolean ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class Float: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    Float (const ::xml_schema::double_&);

    Float (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Float (const Float& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Float*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Float ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class Int8: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    Int8 (const ::xml_schema::byte&);

    Int8 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Int8 (const Int8& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Int8*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Int8 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class Int16: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    Int16 (const ::xml_schema::short_&);

    Int16 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Int16 (const Int16& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Int16*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Int16 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class Int32: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    Int32 (const ::xml_schema::integer&);

    Int32 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Int32 (const Int32& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Int32*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Int32 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class Int64: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    Int64 (const ::xml_schema::long_&);

    Int64 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Int64 (const Int64& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Int64*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Int64 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class UInt8: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    UInt8 (const ::xml_schema::unsigned_byte&);

    UInt8 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    UInt8 (const UInt8& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual UInt8*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UInt8 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class UInt16: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    UInt16 (const ::xml_schema::unsigned_short&);

    UInt16 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    UInt16 (const UInt16& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual UInt16*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UInt16 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class UInt32: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    UInt32 (const ::xml_schema::unsigned_int&);

    UInt32 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    UInt32 (const UInt32& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual UInt32*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UInt32 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class UInt64: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    UInt64 (const ::xml_schema::unsigned_long&);

    UInt64 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    UInt64 (const UInt64& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual UInt64*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UInt64 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class technicalAttributeRationalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >
  {
    public:
    // factorNumerator
    // 
    typedef ::xml_schema::integer factorNumerator_type;
    typedef ::xsd::cxx::tree::traits< factorNumerator_type, char > factorNumerator_traits;

    const factorNumerator_type&
    factorNumerator () const;

    factorNumerator_type&
    factorNumerator ();

    void
    factorNumerator (const factorNumerator_type& x);

    static factorNumerator_type
    factorNumerator_default_value ();

    // factorDenominator
    // 
    typedef ::xml_schema::integer factorDenominator_type;
    typedef ::xsd::cxx::tree::traits< factorDenominator_type, char > factorDenominator_traits;

    const factorDenominator_type&
    factorDenominator () const;

    factorDenominator_type&
    factorDenominator ();

    void
    factorDenominator (const factorDenominator_type& x);

    static factorDenominator_type
    factorDenominator_default_value ();

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    technicalAttributeRationalType (const ::xml_schema::long_&);

    technicalAttributeRationalType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    technicalAttributeRationalType (const technicalAttributeRationalType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual technicalAttributeRationalType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~technicalAttributeRationalType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< factorNumerator_type > factorNumerator_;
    ::xsd::cxx::tree::one< factorDenominator_type > factorDenominator_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class technicalAttributeUriType: public ::xml_schema::uri
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    technicalAttributeUriType (const ::xml_schema::uri&);

    technicalAttributeUriType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    technicalAttributeUriType (const technicalAttributeUriType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual technicalAttributeUriType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~technicalAttributeUriType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class hasTrackPart: public ::ebuCore_2011::relationType
  {
    public:
    // trackPartTitle
    // 
    typedef ::ebuCore_2011::alternativeTitleType trackPartTitle_type;
    typedef ::xsd::cxx::tree::traits< trackPartTitle_type, char > trackPartTitle_traits;

    const trackPartTitle_type&
    trackPartTitle () const;

    trackPartTitle_type&
    trackPartTitle ();

    void
    trackPartTitle (const trackPartTitle_type& x);

    void
    trackPartTitle (::std::auto_ptr< trackPartTitle_type > p);

    // destinationStart
    // 
    typedef ::ebuCore_2011::timeType destinationStart_type;
    typedef ::xsd::cxx::tree::optional< destinationStart_type > destinationStart_optional;
    typedef ::xsd::cxx::tree::traits< destinationStart_type, char > destinationStart_traits;

    const destinationStart_optional&
    destinationStart () const;

    destinationStart_optional&
    destinationStart ();

    void
    destinationStart (const destinationStart_type& x);

    void
    destinationStart (const destinationStart_optional& x);

    void
    destinationStart (::std::auto_ptr< destinationStart_type > p);

    // destinationEnd
    // 
    typedef ::ebuCore_2011::timeType destinationEnd_type;
    typedef ::xsd::cxx::tree::optional< destinationEnd_type > destinationEnd_optional;
    typedef ::xsd::cxx::tree::traits< destinationEnd_type, char > destinationEnd_traits;

    const destinationEnd_optional&
    destinationEnd () const;

    destinationEnd_optional&
    destinationEnd ();

    void
    destinationEnd (const destinationEnd_type& x);

    void
    destinationEnd (const destinationEnd_optional& x);

    void
    destinationEnd (::std::auto_ptr< destinationEnd_type > p);

    // sourceStart
    // 
    typedef ::ebuCore_2011::timeType sourceStart_type;
    typedef ::xsd::cxx::tree::optional< sourceStart_type > sourceStart_optional;
    typedef ::xsd::cxx::tree::traits< sourceStart_type, char > sourceStart_traits;

    const sourceStart_optional&
    sourceStart () const;

    sourceStart_optional&
    sourceStart ();

    void
    sourceStart (const sourceStart_type& x);

    void
    sourceStart (const sourceStart_optional& x);

    void
    sourceStart (::std::auto_ptr< sourceStart_type > p);

    // sourceEnd
    // 
    typedef ::ebuCore_2011::timeType sourceEnd_type;
    typedef ::xsd::cxx::tree::optional< sourceEnd_type > sourceEnd_optional;
    typedef ::xsd::cxx::tree::traits< sourceEnd_type, char > sourceEnd_traits;

    const sourceEnd_optional&
    sourceEnd () const;

    sourceEnd_optional&
    sourceEnd ();

    void
    sourceEnd (const sourceEnd_type& x);

    void
    sourceEnd (const sourceEnd_optional& x);

    void
    sourceEnd (::std::auto_ptr< sourceEnd_type > p);

    // Constructors.
    //
    hasTrackPart (const trackPartTitle_type&);

    hasTrackPart (::std::auto_ptr< trackPartTitle_type >&);

    hasTrackPart (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    hasTrackPart (const hasTrackPart& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual hasTrackPart*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~hasTrackPart ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< trackPartTitle_type > trackPartTitle_;
    destinationStart_optional destinationStart_;
    destinationEnd_optional destinationEnd_;
    sourceStart_optional sourceStart_;
    sourceEnd_optional sourceEnd_;
  };

  class part: public ::ebuCore_2011::coreMetadataType
  {
    public:
    // partId
    // 
    typedef ::xml_schema::nmtoken partId_type;
    typedef ::xsd::cxx::tree::optional< partId_type > partId_optional;
    typedef ::xsd::cxx::tree::traits< partId_type, char > partId_traits;

    const partId_optional&
    partId () const;

    partId_optional&
    partId ();

    void
    partId (const partId_type& x);

    void
    partId (const partId_optional& x);

    void
    partId (::std::auto_ptr< partId_type > p);

    // partName
    // 
    typedef ::xml_schema::string partName_type;
    typedef ::xsd::cxx::tree::optional< partName_type > partName_optional;
    typedef ::xsd::cxx::tree::traits< partName_type, char > partName_traits;

    const partName_optional&
    partName () const;

    partName_optional&
    partName ();

    void
    partName (const partName_type& x);

    void
    partName (const partName_optional& x);

    void
    partName (::std::auto_ptr< partName_type > p);

    // Constructors.
    //
    part ();

    part (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    part (const part& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual part*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~part ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    partId_optional partId_;
    partName_optional partName_;
  };

  class genre: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    genre ();

    genre (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    genre (const genre& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual genre*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~genre ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class objectType: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    objectType ();

    objectType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    objectType (const objectType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual objectType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~objectType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class targetAudience: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    targetAudience ();

    targetAudience (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    targetAudience (const targetAudience& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual targetAudience*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~targetAudience ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class temporal: public ::xml_schema::type
  {
    public:
    // PeriodOfTime
    // 
    typedef ::ebuCore_2011::PeriodOfTime PeriodOfTime_type;
    typedef ::xsd::cxx::tree::optional< PeriodOfTime_type > PeriodOfTime_optional;
    typedef ::xsd::cxx::tree::traits< PeriodOfTime_type, char > PeriodOfTime_traits;

    const PeriodOfTime_optional&
    PeriodOfTime () const;

    PeriodOfTime_optional&
    PeriodOfTime ();

    void
    PeriodOfTime (const PeriodOfTime_type& x);

    void
    PeriodOfTime (const PeriodOfTime_optional& x);

    void
    PeriodOfTime (::std::auto_ptr< PeriodOfTime_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // periodId
    // 
    typedef ::xml_schema::uri periodId_type;
    typedef ::xsd::cxx::tree::optional< periodId_type > periodId_optional;
    typedef ::xsd::cxx::tree::traits< periodId_type, char > periodId_traits;

    const periodId_optional&
    periodId () const;

    periodId_optional&
    periodId ();

    void
    periodId (const periodId_type& x);

    void
    periodId (const periodId_optional& x);

    void
    periodId (::std::auto_ptr< periodId_type > p);

    // Constructors.
    //
    temporal ();

    temporal (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    temporal (const temporal& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual temporal*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~temporal ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    PeriodOfTime_optional PeriodOfTime_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    note_optional note_;
    periodId_optional periodId_;
  };

  class spatial: public ::xml_schema::type
  {
    public:
    // location
    // 
    typedef ::ebuCore_2011::location location_type;
    typedef ::xsd::cxx::tree::sequence< location_type > location_sequence;
    typedef location_sequence::iterator location_iterator;
    typedef location_sequence::const_iterator location_const_iterator;
    typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

    const location_sequence&
    location () const;

    location_sequence&
    location ();

    void
    location (const location_sequence& s);

    // Constructors.
    //
    spatial ();

    spatial (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    spatial (const spatial& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual spatial*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~spatial ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    location_sequence location_;
  };

  class medium: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    medium ();

    medium (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    medium (const medium& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual medium*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~medium ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class mimeType: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    mimeType ();

    mimeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    mimeType (const mimeType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual mimeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~mimeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class containerFormat: public ::xml_schema::type
  {
    public:
    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // Constructors.
    //
    containerFormat ();

    containerFormat (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    containerFormat (const containerFormat& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual containerFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~containerFormat ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
  };

  class signingFormat: public ::xml_schema::type
  {
    public:
    // trackId
    // 
    typedef ::xml_schema::nmtoken trackId_type;
    typedef ::xsd::cxx::tree::optional< trackId_type > trackId_optional;
    typedef ::xsd::cxx::tree::traits< trackId_type, char > trackId_traits;

    const trackId_optional&
    trackId () const;

    trackId_optional&
    trackId ();

    void
    trackId (const trackId_type& x);

    void
    trackId (const trackId_optional& x);

    void
    trackId (::std::auto_ptr< trackId_type > p);

    // trackName
    // 
    typedef ::xml_schema::string trackName_type;
    typedef ::xsd::cxx::tree::optional< trackName_type > trackName_optional;
    typedef ::xsd::cxx::tree::traits< trackName_type, char > trackName_traits;

    const trackName_optional&
    trackName () const;

    trackName_optional&
    trackName ();

    void
    trackName (const trackName_type& x);

    void
    trackName (const trackName_optional& x);

    void
    trackName (::std::auto_ptr< trackName_type > p);

    // language
    // 
    typedef ::xml_schema::language language_type;
    typedef ::xsd::cxx::tree::optional< language_type > language_optional;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_optional&
    language () const;

    language_optional&
    language ();

    void
    language (const language_type& x);

    void
    language (const language_optional& x);

    void
    language (::std::auto_ptr< language_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // signingSourceUri
    // 
    typedef ::xml_schema::uri signingSourceUri_type;
    typedef ::xsd::cxx::tree::optional< signingSourceUri_type > signingSourceUri_optional;
    typedef ::xsd::cxx::tree::traits< signingSourceUri_type, char > signingSourceUri_traits;

    const signingSourceUri_optional&
    signingSourceUri () const;

    signingSourceUri_optional&
    signingSourceUri ();

    void
    signingSourceUri (const signingSourceUri_type& x);

    void
    signingSourceUri (const signingSourceUri_optional& x);

    void
    signingSourceUri (::std::auto_ptr< signingSourceUri_type > p);

    // signingFormatId
    // 
    typedef ::xml_schema::uri signingFormatId_type;
    typedef ::xsd::cxx::tree::optional< signingFormatId_type > signingFormatId_optional;
    typedef ::xsd::cxx::tree::traits< signingFormatId_type, char > signingFormatId_traits;

    const signingFormatId_optional&
    signingFormatId () const;

    signingFormatId_optional&
    signingFormatId ();

    void
    signingFormatId (const signingFormatId_type& x);

    void
    signingFormatId (const signingFormatId_optional& x);

    void
    signingFormatId (::std::auto_ptr< signingFormatId_type > p);

    // signingFormatName
    // 
    typedef ::xml_schema::string signingFormatName_type;
    typedef ::xsd::cxx::tree::optional< signingFormatName_type > signingFormatName_optional;
    typedef ::xsd::cxx::tree::traits< signingFormatName_type, char > signingFormatName_traits;

    const signingFormatName_optional&
    signingFormatName () const;

    signingFormatName_optional&
    signingFormatName ();

    void
    signingFormatName (const signingFormatName_type& x);

    void
    signingFormatName (const signingFormatName_optional& x);

    void
    signingFormatName (::std::auto_ptr< signingFormatName_type > p);

    // signingFormatDefinition
    // 
    typedef ::xml_schema::string signingFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< signingFormatDefinition_type > signingFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< signingFormatDefinition_type, char > signingFormatDefinition_traits;

    const signingFormatDefinition_optional&
    signingFormatDefinition () const;

    signingFormatDefinition_optional&
    signingFormatDefinition ();

    void
    signingFormatDefinition (const signingFormatDefinition_type& x);

    void
    signingFormatDefinition (const signingFormatDefinition_optional& x);

    void
    signingFormatDefinition (::std::auto_ptr< signingFormatDefinition_type > p);

    // Constructors.
    //
    signingFormat ();

    signingFormat (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    signingFormat (const signingFormat& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual signingFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~signingFormat ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    trackId_optional trackId_;
    trackName_optional trackName_;
    language_optional language_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    signingSourceUri_optional signingSourceUri_;
    signingFormatId_optional signingFormatId_;
    signingFormatName_optional signingFormatName_;
    signingFormatDefinition_optional signingFormatDefinition_;
  };

  class locator: public ::xml_schema::string
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    locator ();

    locator (const char*);

    locator (const ::std::string&);

    locator (const ::xml_schema::string&);

    locator (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    locator (const locator& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual locator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~locator ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class dateCreated: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // period
    // 
    typedef ::xml_schema::string period_type;
    typedef ::xsd::cxx::tree::optional< period_type > period_optional;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_optional&
    period () const;

    period_optional&
    period ();

    void
    period (const period_type& x);

    void
    period (const period_optional& x);

    void
    period (::std::auto_ptr< period_type > p);

    // Constructors.
    //
    dateCreated ();

    dateCreated (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    dateCreated (const dateCreated& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual dateCreated*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~dateCreated ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    period_optional period_;
  };

  class dateModified: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // period
    // 
    typedef ::xml_schema::string period_type;
    typedef ::xsd::cxx::tree::optional< period_type > period_optional;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_optional&
    period () const;

    period_optional&
    period ();

    void
    period (const period_type& x);

    void
    period (const period_optional& x);

    void
    period (::std::auto_ptr< period_type > p);

    // Constructors.
    //
    dateModified ();

    dateModified (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    dateModified (const dateModified& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual dateModified*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~dateModified ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    period_optional period_;
  };

  class created: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // period
    // 
    typedef ::xml_schema::string period_type;
    typedef ::xsd::cxx::tree::optional< period_type > period_optional;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_optional&
    period () const;

    period_optional&
    period ();

    void
    period (const period_type& x);

    void
    period (const period_optional& x);

    void
    period (::std::auto_ptr< period_type > p);

    // Constructors.
    //
    created ();

    created (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    created (const created& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual created*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~created ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    period_optional period_;
  };

  class issued: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // period
    // 
    typedef ::xml_schema::string period_type;
    typedef ::xsd::cxx::tree::optional< period_type > period_optional;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_optional&
    period () const;

    period_optional&
    period ();

    void
    period (const period_type& x);

    void
    period (const period_optional& x);

    void
    period (::std::auto_ptr< period_type > p);

    // Constructors.
    //
    issued ();

    issued (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    issued (const issued& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual issued*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~issued ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    period_optional period_;
  };

  class modified: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // period
    // 
    typedef ::xml_schema::string period_type;
    typedef ::xsd::cxx::tree::optional< period_type > period_optional;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_optional&
    period () const;

    period_optional&
    period ();

    void
    period (const period_type& x);

    void
    period (const period_optional& x);

    void
    period (::std::auto_ptr< period_type > p);

    // Constructors.
    //
    modified ();

    modified (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    modified (const modified& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual modified*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~modified ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    period_optional period_;
  };

  class digitised: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // period
    // 
    typedef ::xml_schema::string period_type;
    typedef ::xsd::cxx::tree::optional< period_type > period_optional;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_optional&
    period () const;

    period_optional&
    period ();

    void
    period (const period_type& x);

    void
    period (const period_optional& x);

    void
    period (::std::auto_ptr< period_type > p);

    // Constructors.
    //
    digitised ();

    digitised (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    digitised (const digitised& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual digitised*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~digitised ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    period_optional period_;
  };

  class alternative: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // period
    // 
    typedef ::xml_schema::string period_type;
    typedef ::xsd::cxx::tree::optional< period_type > period_optional;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_optional&
    period () const;

    period_optional&
    period ();

    void
    period (const period_type& x);

    void
    period (const period_optional& x);

    void
    period (::std::auto_ptr< period_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    alternative ();

    alternative (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    alternative (const alternative& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual alternative*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~alternative ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    period_optional period_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class firstPublicationChannel: public ::xml_schema::string
  {
    public:
    // formatIdRef
    // 
    typedef ::xml_schema::idref formatIdRef_type;
    typedef ::xsd::cxx::tree::optional< formatIdRef_type > formatIdRef_optional;
    typedef ::xsd::cxx::tree::traits< formatIdRef_type, char > formatIdRef_traits;

    const formatIdRef_optional&
    formatIdRef () const;

    formatIdRef_optional&
    formatIdRef ();

    void
    formatIdRef (const formatIdRef_type& x);

    void
    formatIdRef (const formatIdRef_optional& x);

    void
    formatIdRef (::std::auto_ptr< formatIdRef_type > p);

    // Constructors.
    //
    firstPublicationChannel ();

    firstPublicationChannel (const char*);

    firstPublicationChannel (const ::std::string&);

    firstPublicationChannel (const ::xml_schema::string&);

    firstPublicationChannel (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    firstPublicationChannel (const firstPublicationChannel& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual firstPublicationChannel*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~firstPublicationChannel ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    formatIdRef_optional formatIdRef_;
  };

  class repeatChannel: public ::xml_schema::string
  {
    public:
    // formatIdRef
    // 
    typedef ::xml_schema::idref formatIdRef_type;
    typedef ::xsd::cxx::tree::optional< formatIdRef_type > formatIdRef_optional;
    typedef ::xsd::cxx::tree::traits< formatIdRef_type, char > formatIdRef_traits;

    const formatIdRef_optional&
    formatIdRef () const;

    formatIdRef_optional&
    formatIdRef ();

    void
    formatIdRef (const formatIdRef_type& x);

    void
    formatIdRef (const formatIdRef_optional& x);

    void
    formatIdRef (::std::auto_ptr< formatIdRef_type > p);

    // Constructors.
    //
    repeatChannel ();

    repeatChannel (const char*);

    repeatChannel (const ::std::string&);

    repeatChannel (const ::xml_schema::string&);

    repeatChannel (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    repeatChannel (const repeatChannel& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual repeatChannel*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~repeatChannel ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    formatIdRef_optional formatIdRef_;
  };

  class role: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    role ();

    role (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    role (const role& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual role*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~role ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class organisationDepartment: public ::dc::elementType
  {
    public:
    // departmentId
    // 
    typedef ::xml_schema::uri departmentId_type;
    typedef ::xsd::cxx::tree::optional< departmentId_type > departmentId_optional;
    typedef ::xsd::cxx::tree::traits< departmentId_type, char > departmentId_traits;

    const departmentId_optional&
    departmentId () const;

    departmentId_optional&
    departmentId ();

    void
    departmentId (const departmentId_type& x);

    void
    departmentId (const departmentId_optional& x);

    void
    departmentId (::std::auto_ptr< departmentId_type > p);

    // Constructors.
    //
    organisationDepartment ();

    organisationDepartment (const char*);

    organisationDepartment (const ::std::string&);

    organisationDepartment (const ::xml_schema::string&);

    organisationDepartment (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    organisationDepartment (const organisationDepartment& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual organisationDepartment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~organisationDepartment ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    departmentId_optional departmentId_;
  };

  class country: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    country ();

    country (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    country (const country& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual country*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~country ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class orientation: public ::xml_schema::string
  {
    public:
    enum value
    {
      landscape,
      portrait
    };

    orientation (value v);

    orientation (const char* v);

    orientation (const ::std::string& v);

    orientation (const ::xml_schema::string& v);

    orientation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    orientation (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    orientation (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    orientation (const orientation& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual orientation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    orientation&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_orientation_convert ();
    }

    protected:
    value
    _xsd_orientation_convert () const;

    public:
    static const char* const _xsd_orientation_literals_[2];
    static const value _xsd_orientation_indexes_[2];
  };

  class imageEncoding: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    imageEncoding ();

    imageEncoding (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    imageEncoding (const imageEncoding& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual imageEncoding*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~imageEncoding ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class aspectRatio: public ::xml_schema::string
  {
    public:
    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    aspectRatio ();

    aspectRatio (const char*);

    aspectRatio (const ::std::string&);

    aspectRatio (const ::xml_schema::string&);

    aspectRatio (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    aspectRatio (const aspectRatio& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual aspectRatio*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~aspectRatio ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    note_optional note_;
  };

  class videoEncoding: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    videoEncoding ();

    videoEncoding (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    videoEncoding (const videoEncoding& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual videoEncoding*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~videoEncoding ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class videoTrack: public ::xml_schema::type
  {
    public:
    // trackId
    // 
    typedef ::xml_schema::nmtoken trackId_type;
    typedef ::xsd::cxx::tree::optional< trackId_type > trackId_optional;
    typedef ::xsd::cxx::tree::traits< trackId_type, char > trackId_traits;

    const trackId_optional&
    trackId () const;

    trackId_optional&
    trackId ();

    void
    trackId (const trackId_type& x);

    void
    trackId (const trackId_optional& x);

    void
    trackId (::std::auto_ptr< trackId_type > p);

    // trackName
    // 
    typedef ::xml_schema::string trackName_type;
    typedef ::xsd::cxx::tree::optional< trackName_type > trackName_optional;
    typedef ::xsd::cxx::tree::traits< trackName_type, char > trackName_traits;

    const trackName_optional&
    trackName () const;

    trackName_optional&
    trackName ();

    void
    trackName (const trackName_type& x);

    void
    trackName (const trackName_optional& x);

    void
    trackName (::std::auto_ptr< trackName_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    videoTrack ();

    videoTrack (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    videoTrack (const videoTrack& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual videoTrack*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~videoTrack ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    trackId_optional trackId_;
    trackName_optional trackName_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class audioEncoding: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    audioEncoding ();

    audioEncoding (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    audioEncoding (const audioEncoding& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual audioEncoding*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~audioEncoding ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class audioTrackConfiguration: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    audioTrackConfiguration ();

    audioTrackConfiguration (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    audioTrackConfiguration (const audioTrackConfiguration& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual audioTrackConfiguration*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~audioTrackConfiguration ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class audioTrack: public ::xml_schema::type
  {
    public:
    // trackLanguage
    // 
    typedef ::xml_schema::language trackLanguage_type;
    typedef ::xsd::cxx::tree::optional< trackLanguage_type > trackLanguage_optional;
    typedef ::xsd::cxx::tree::traits< trackLanguage_type, char > trackLanguage_traits;

    const trackLanguage_optional&
    trackLanguage () const;

    trackLanguage_optional&
    trackLanguage ();

    void
    trackLanguage (const trackLanguage_type& x);

    void
    trackLanguage (const trackLanguage_optional& x);

    void
    trackLanguage (::std::auto_ptr< trackLanguage_type > p);

    // trackId
    // 
    typedef ::xml_schema::nmtoken trackId_type;
    typedef ::xsd::cxx::tree::optional< trackId_type > trackId_optional;
    typedef ::xsd::cxx::tree::traits< trackId_type, char > trackId_traits;

    const trackId_optional&
    trackId () const;

    trackId_optional&
    trackId ();

    void
    trackId (const trackId_type& x);

    void
    trackId (const trackId_optional& x);

    void
    trackId (::std::auto_ptr< trackId_type > p);

    // trackName
    // 
    typedef ::xml_schema::string trackName_type;
    typedef ::xsd::cxx::tree::optional< trackName_type > trackName_optional;
    typedef ::xsd::cxx::tree::traits< trackName_type, char > trackName_traits;

    const trackName_optional&
    trackName () const;

    trackName_optional&
    trackName ();

    void
    trackName (const trackName_type& x);

    void
    trackName (const trackName_optional& x);

    void
    trackName (::std::auto_ptr< trackName_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // Constructors.
    //
    audioTrack ();

    audioTrack (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    audioTrack (const audioTrack& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual audioTrack*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~audioTrack ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    trackLanguage_optional trackLanguage_;
    trackId_optional trackId_;
    trackName_optional trackName_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
  };

  class captioningFormat: public ::xml_schema::type
  {
    public:
    // trackId
    // 
    typedef ::xml_schema::nmtoken trackId_type;
    typedef ::xsd::cxx::tree::optional< trackId_type > trackId_optional;
    typedef ::xsd::cxx::tree::traits< trackId_type, char > trackId_traits;

    const trackId_optional&
    trackId () const;

    trackId_optional&
    trackId ();

    void
    trackId (const trackId_type& x);

    void
    trackId (const trackId_optional& x);

    void
    trackId (::std::auto_ptr< trackId_type > p);

    // trackName
    // 
    typedef ::xml_schema::string trackName_type;
    typedef ::xsd::cxx::tree::optional< trackName_type > trackName_optional;
    typedef ::xsd::cxx::tree::traits< trackName_type, char > trackName_traits;

    const trackName_optional&
    trackName () const;

    trackName_optional&
    trackName ();

    void
    trackName (const trackName_type& x);

    void
    trackName (const trackName_optional& x);

    void
    trackName (::std::auto_ptr< trackName_type > p);

    // language
    // 
    typedef ::xml_schema::language language_type;
    typedef ::xsd::cxx::tree::optional< language_type > language_optional;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_optional&
    language () const;

    language_optional&
    language ();

    void
    language (const language_type& x);

    void
    language (const language_optional& x);

    void
    language (::std::auto_ptr< language_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // captioningSourceUri
    // 
    typedef ::xml_schema::uri captioningSourceUri_type;
    typedef ::xsd::cxx::tree::optional< captioningSourceUri_type > captioningSourceUri_optional;
    typedef ::xsd::cxx::tree::traits< captioningSourceUri_type, char > captioningSourceUri_traits;

    const captioningSourceUri_optional&
    captioningSourceUri () const;

    captioningSourceUri_optional&
    captioningSourceUri ();

    void
    captioningSourceUri (const captioningSourceUri_type& x);

    void
    captioningSourceUri (const captioningSourceUri_optional& x);

    void
    captioningSourceUri (::std::auto_ptr< captioningSourceUri_type > p);

    // captioningFormatId
    // 
    typedef ::xml_schema::uri captioningFormatId_type;
    typedef ::xsd::cxx::tree::optional< captioningFormatId_type > captioningFormatId_optional;
    typedef ::xsd::cxx::tree::traits< captioningFormatId_type, char > captioningFormatId_traits;

    const captioningFormatId_optional&
    captioningFormatId () const;

    captioningFormatId_optional&
    captioningFormatId ();

    void
    captioningFormatId (const captioningFormatId_type& x);

    void
    captioningFormatId (const captioningFormatId_optional& x);

    void
    captioningFormatId (::std::auto_ptr< captioningFormatId_type > p);

    // captioningFormatName
    // 
    typedef ::xml_schema::string captioningFormatName_type;
    typedef ::xsd::cxx::tree::optional< captioningFormatName_type > captioningFormatName_optional;
    typedef ::xsd::cxx::tree::traits< captioningFormatName_type, char > captioningFormatName_traits;

    const captioningFormatName_optional&
    captioningFormatName () const;

    captioningFormatName_optional&
    captioningFormatName ();

    void
    captioningFormatName (const captioningFormatName_type& x);

    void
    captioningFormatName (const captioningFormatName_optional& x);

    void
    captioningFormatName (::std::auto_ptr< captioningFormatName_type > p);

    // Constructors.
    //
    captioningFormat ();

    captioningFormat (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    captioningFormat (const captioningFormat& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual captioningFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~captioningFormat ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    trackId_optional trackId_;
    trackName_optional trackName_;
    language_optional language_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    captioningSourceUri_optional captioningSourceUri_;
    captioningFormatId_optional captioningFormatId_;
    captioningFormatName_optional captioningFormatName_;
  };

  class ancillaryDataFormat: public ::xml_schema::type
  {
    public:
    // DID
    // 
    typedef ::xml_schema::integer DID_type;
    typedef ::xsd::cxx::tree::optional< DID_type > DID_optional;
    typedef ::xsd::cxx::tree::traits< DID_type, char > DID_traits;

    const DID_optional&
    DID () const;

    DID_optional&
    DID ();

    void
    DID (const DID_type& x);

    void
    DID (const DID_optional& x);

    // SDID
    // 
    typedef ::xml_schema::integer SDID_type;
    typedef ::xsd::cxx::tree::optional< SDID_type > SDID_optional;
    typedef ::xsd::cxx::tree::traits< SDID_type, char > SDID_traits;

    const SDID_optional&
    SDID () const;

    SDID_optional&
    SDID ();

    void
    SDID (const SDID_type& x);

    void
    SDID (const SDID_optional& x);

    // lineNumber
    // 
    typedef ::xml_schema::integer lineNumber_type;
    typedef ::xsd::cxx::tree::sequence< lineNumber_type > lineNumber_sequence;
    typedef lineNumber_sequence::iterator lineNumber_iterator;
    typedef lineNumber_sequence::const_iterator lineNumber_const_iterator;
    typedef ::xsd::cxx::tree::traits< lineNumber_type, char > lineNumber_traits;

    const lineNumber_sequence&
    lineNumber () const;

    lineNumber_sequence&
    lineNumber ();

    void
    lineNumber (const lineNumber_sequence& s);

    // wrappingType
    // 
    typedef ::xml_schema::integer wrappingType_type;
    typedef ::xsd::cxx::tree::optional< wrappingType_type > wrappingType_optional;
    typedef ::xsd::cxx::tree::traits< wrappingType_type, char > wrappingType_traits;

    const wrappingType_optional&
    wrappingType () const;

    wrappingType_optional&
    wrappingType ();

    void
    wrappingType (const wrappingType_type& x);

    void
    wrappingType (const wrappingType_optional& x);

    // ancillaryDataFormatId
    // 
    typedef ::xml_schema::uri ancillaryDataFormatId_type;
    typedef ::xsd::cxx::tree::optional< ancillaryDataFormatId_type > ancillaryDataFormatId_optional;
    typedef ::xsd::cxx::tree::traits< ancillaryDataFormatId_type, char > ancillaryDataFormatId_traits;

    const ancillaryDataFormatId_optional&
    ancillaryDataFormatId () const;

    ancillaryDataFormatId_optional&
    ancillaryDataFormatId ();

    void
    ancillaryDataFormatId (const ancillaryDataFormatId_type& x);

    void
    ancillaryDataFormatId (const ancillaryDataFormatId_optional& x);

    void
    ancillaryDataFormatId (::std::auto_ptr< ancillaryDataFormatId_type > p);

    // ancillaryDataFormatName
    // 
    typedef ::xml_schema::string ancillaryDataFormatName_type;
    typedef ::xsd::cxx::tree::optional< ancillaryDataFormatName_type > ancillaryDataFormatName_optional;
    typedef ::xsd::cxx::tree::traits< ancillaryDataFormatName_type, char > ancillaryDataFormatName_traits;

    const ancillaryDataFormatName_optional&
    ancillaryDataFormatName () const;

    ancillaryDataFormatName_optional&
    ancillaryDataFormatName ();

    void
    ancillaryDataFormatName (const ancillaryDataFormatName_type& x);

    void
    ancillaryDataFormatName (const ancillaryDataFormatName_optional& x);

    void
    ancillaryDataFormatName (::std::auto_ptr< ancillaryDataFormatName_type > p);

    // Constructors.
    //
    ancillaryDataFormat ();

    ancillaryDataFormat (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ancillaryDataFormat (const ancillaryDataFormat& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ancillaryDataFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ancillaryDataFormat ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DID_optional DID_;
    SDID_optional SDID_;
    lineNumber_sequence lineNumber_;
    wrappingType_optional wrappingType_;
    ancillaryDataFormatId_optional ancillaryDataFormatId_;
    ancillaryDataFormatName_optional ancillaryDataFormatName_;
  };

  class timecode: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    timecode ();

    timecode (const char*);

    timecode (const ::std::string&);

    timecode (const ::xml_schema::string&);

    timecode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    timecode (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    timecode (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    timecode (const timecode& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual timecode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~timecode ();
  };

  class time: public ::xml_schema::string
  {
    public:
    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // Constructors.
    //
    time ();

    time (const char*);

    time (const ::std::string&);

    time (const ::xml_schema::string&);

    time (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    time (const time& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual time*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~time ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
  };

  class timecode1: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    timecode1 ();

    timecode1 (const char*);

    timecode1 (const ::std::string&);

    timecode1 (const ::xml_schema::string&);

    timecode1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    timecode1 (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    timecode1 (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    timecode1 (const timecode1& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual timecode1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~timecode1 ();
  };

  class time1: public ::xml_schema::string
  {
    public:
    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // Constructors.
    //
    time1 ();

    time1 (const char*);

    time1 (const ::std::string&);

    time1 (const ::xml_schema::string&);

    time1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    time1 (const time1& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual time1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~time1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
  };

  class PeriodOfTime: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // period
    // 
    typedef ::xml_schema::string period_type;
    typedef ::xsd::cxx::tree::optional< period_type > period_optional;
    typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

    const period_optional&
    period () const;

    period_optional&
    period ();

    void
    period (const period_type& x);

    void
    period (const period_optional& x);

    void
    period (::std::auto_ptr< period_type > p);

    // Constructors.
    //
    PeriodOfTime ();

    PeriodOfTime (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    PeriodOfTime (const PeriodOfTime& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual PeriodOfTime*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~PeriodOfTime ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    period_optional period_;
  };

  class location: public ::xml_schema::type
  {
    public:
    // name
    // 
    typedef ::xml_schema::string name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // coordinates
    // 
    typedef ::ebuCore_2011::coordinates coordinates_type;
    typedef ::xsd::cxx::tree::optional< coordinates_type > coordinates_optional;
    typedef ::xsd::cxx::tree::traits< coordinates_type, char > coordinates_traits;

    const coordinates_optional&
    coordinates () const;

    coordinates_optional&
    coordinates ();

    void
    coordinates (const coordinates_type& x);

    void
    coordinates (const coordinates_optional& x);

    void
    coordinates (::std::auto_ptr< coordinates_type > p);

    // code
    // 
    typedef ::xml_schema::uri code_type;
    typedef ::xsd::cxx::tree::optional< code_type > code_optional;
    typedef ::xsd::cxx::tree::traits< code_type, char > code_traits;

    const code_optional&
    code () const;

    code_optional&
    code ();

    void
    code (const code_type& x);

    void
    code (const code_optional& x);

    void
    code (::std::auto_ptr< code_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // locationId
    // 
    typedef ::xml_schema::uri locationId_type;
    typedef ::xsd::cxx::tree::optional< locationId_type > locationId_optional;
    typedef ::xsd::cxx::tree::traits< locationId_type, char > locationId_traits;

    const locationId_optional&
    locationId () const;

    locationId_optional&
    locationId ();

    void
    locationId (const locationId_type& x);

    void
    locationId (const locationId_optional& x);

    void
    locationId (::std::auto_ptr< locationId_type > p);

    // Constructors.
    //
    location ();

    location (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    location (const location& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual location*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~location ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    name_optional name_;
    coordinates_optional coordinates_;
    code_optional code_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    note_optional note_;
    locationId_optional locationId_;
  };

  class coordinates: public ::xml_schema::type
  {
    public:
    // posy
    // 
    typedef ::xml_schema::float_ posy_type;
    typedef ::xsd::cxx::tree::traits< posy_type, char > posy_traits;

    const posy_type&
    posy () const;

    posy_type&
    posy ();

    void
    posy (const posy_type& x);

    // posx
    // 
    typedef ::xml_schema::float_ posx_type;
    typedef ::xsd::cxx::tree::traits< posx_type, char > posx_traits;

    const posx_type&
    posx () const;

    posx_type&
    posx ();

    void
    posx (const posx_type& x);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // Constructors.
    //
    coordinates (const posy_type&,
                 const posx_type&);

    coordinates (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    coordinates (const coordinates& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual coordinates*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~coordinates ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< posy_type > posy_;
    ::xsd::cxx::tree::one< posx_type > posx_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace ebuCore_2011
{
  // Parse a URI or a local file.
  //

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (const ::std::string& uri,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (const ::std::string& uri,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (const ::std::string& uri,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& id,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2011::ebuCoreMainType >
  ebuCoreMain (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace ebuCore_2011
{
  // Serialize to std::ostream.
  //

  void
  ebuCoreMain (::std::ostream& os,
               const ::ebuCore_2011::ebuCoreMainType& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  void
  ebuCoreMain (::std::ostream& os,
               const ::ebuCore_2011::ebuCoreMainType& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  void
  ebuCoreMain (::std::ostream& os,
               const ::ebuCore_2011::ebuCoreMainType& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& ft,
               const ::ebuCore_2011::ebuCoreMainType& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& ft,
               const ::ebuCore_2011::ebuCoreMainType& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& ft,
               const ::ebuCore_2011::ebuCoreMainType& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  ebuCoreMain (::xercesc::DOMDocument& d,
               const ::ebuCore_2011::ebuCoreMainType& x,
               ::xml_schema::flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  ebuCoreMain (const ::ebuCore_2011::ebuCoreMainType& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const ebuCoreMainType&);

  void
  operator<< (::xercesc::DOMElement&, const coreMetadataType&);

  void
  operator<< (::xercesc::DOMElement&, const titleType&);

  void
  operator<< (::xercesc::DOMElement&, const alternativeTitleType&);

  void
  operator<< (::xercesc::DOMElement&, const identifierType&);

  void
  operator<< (::xercesc::DOMElement&, const subjectType&);

  void
  operator<< (::xercesc::DOMElement&, const typeType&);

  void
  operator<< (::xercesc::DOMElement&, const descriptionType&);

  void
  operator<< (::xercesc::DOMElement&, const coverageType&);

  void
  operator<< (::xercesc::DOMElement&, const rightsType&);

  void
  operator<< (::xercesc::DOMElement&, const formatType&);

  void
  operator<< (::xercesc::DOMElement&, const relationType&);

  void
  operator<< (::xercesc::DOMElement&, const languageType&);

  void
  operator<< (::xercesc::DOMElement&, const dateType&);

  void
  operator<< (::xercesc::DOMElement&, const publicationHistoryType&);

  void
  operator<< (::xercesc::DOMElement&, const entityType&);

  void
  operator<< (::xercesc::DOMElement&, const contactDetailsType&);

  void
  operator<< (::xercesc::DOMElement&, const organisationDetailsType&);

  void
  operator<< (::xercesc::DOMElement&, const detailsType&);

  void
  operator<< (::xercesc::DOMElement&, const addressType&);

  void
  operator<< (::xercesc::DOMElement&, const editUnitNumberType&);

  void
  operator<< (::xercesc::DOMElement&, const ratingType&);

  void
  operator<< (::xercesc::DOMElement&, const lengthType&);

  void
  operator<< (::xercesc::DOMElement&, const imageFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const videoFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const audioFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const dataFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const documentFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const timeType&);

  void
  operator<< (::xercesc::DOMElement&, const durationType&);

  void
  operator<< (::xercesc::DOMElement&, const String&);

  void
  operator<< (::xercesc::DOMElement&, const Boolean&);

  void
  operator<< (::xercesc::DOMElement&, const Float&);

  void
  operator<< (::xercesc::DOMElement&, const Int8&);

  void
  operator<< (::xercesc::DOMElement&, const Int16&);

  void
  operator<< (::xercesc::DOMElement&, const Int32&);

  void
  operator<< (::xercesc::DOMElement&, const Int64&);

  void
  operator<< (::xercesc::DOMElement&, const UInt8&);

  void
  operator<< (::xercesc::DOMElement&, const UInt16&);

  void
  operator<< (::xercesc::DOMElement&, const UInt32&);

  void
  operator<< (::xercesc::DOMElement&, const UInt64&);

  void
  operator<< (::xercesc::DOMElement&, const technicalAttributeRationalType&);

  void
  operator<< (::xercesc::DOMElement&, const technicalAttributeUriType&);

  void
  operator<< (::xercesc::DOMElement&, const hasTrackPart&);

  void
  operator<< (::xercesc::DOMElement&, const part&);

  void
  operator<< (::xercesc::DOMElement&, const genre&);

  void
  operator<< (::xercesc::DOMElement&, const objectType&);

  void
  operator<< (::xercesc::DOMElement&, const targetAudience&);

  void
  operator<< (::xercesc::DOMElement&, const temporal&);

  void
  operator<< (::xercesc::DOMElement&, const spatial&);

  void
  operator<< (::xercesc::DOMElement&, const medium&);

  void
  operator<< (::xercesc::DOMElement&, const mimeType&);

  void
  operator<< (::xercesc::DOMElement&, const containerFormat&);

  void
  operator<< (::xercesc::DOMElement&, const signingFormat&);

  void
  operator<< (::xercesc::DOMElement&, const locator&);

  void
  operator<< (::xercesc::DOMElement&, const dateCreated&);

  void
  operator<< (::xercesc::DOMElement&, const dateModified&);

  void
  operator<< (::xercesc::DOMElement&, const created&);

  void
  operator<< (::xercesc::DOMElement&, const issued&);

  void
  operator<< (::xercesc::DOMElement&, const modified&);

  void
  operator<< (::xercesc::DOMElement&, const digitised&);

  void
  operator<< (::xercesc::DOMElement&, const alternative&);

  void
  operator<< (::xercesc::DOMElement&, const firstPublicationChannel&);

  void
  operator<< (::xercesc::DOMElement&, const repeatChannel&);

  void
  operator<< (::xercesc::DOMElement&, const role&);

  void
  operator<< (::xercesc::DOMElement&, const organisationDepartment&);

  void
  operator<< (::xercesc::DOMElement&, const country&);

  void
  operator<< (::xercesc::DOMElement&, const orientation&);

  void
  operator<< (::xercesc::DOMAttr&, const orientation&);

  void
  operator<< (::xml_schema::list_stream&,
              const orientation&);

  void
  operator<< (::xercesc::DOMElement&, const imageEncoding&);

  void
  operator<< (::xercesc::DOMElement&, const aspectRatio&);

  void
  operator<< (::xercesc::DOMElement&, const videoEncoding&);

  void
  operator<< (::xercesc::DOMElement&, const videoTrack&);

  void
  operator<< (::xercesc::DOMElement&, const audioEncoding&);

  void
  operator<< (::xercesc::DOMElement&, const audioTrackConfiguration&);

  void
  operator<< (::xercesc::DOMElement&, const audioTrack&);

  void
  operator<< (::xercesc::DOMElement&, const captioningFormat&);

  void
  operator<< (::xercesc::DOMElement&, const ancillaryDataFormat&);

  void
  operator<< (::xercesc::DOMElement&, const timecode&);

  void
  operator<< (::xercesc::DOMAttr&, const timecode&);

  void
  operator<< (::xml_schema::list_stream&,
              const timecode&);

  void
  operator<< (::xercesc::DOMElement&, const time&);

  void
  operator<< (::xercesc::DOMElement&, const timecode1&);

  void
  operator<< (::xercesc::DOMAttr&, const timecode1&);

  void
  operator<< (::xml_schema::list_stream&,
              const timecode1&);

  void
  operator<< (::xercesc::DOMElement&, const time1&);

  void
  operator<< (::xercesc::DOMElement&, const PeriodOfTime&);

  void
  operator<< (::xercesc::DOMElement&, const location&);

  void
  operator<< (::xercesc::DOMElement&, const coordinates&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // C__CODE_EBU_SDK_DOCUMENTATION_EBU_CORE_XSD_EBU_CORE_20110915_HXX
