// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef EBU_CORE_20130107_HXX
#define EBU_CORE_20130107_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace ebuCore_2012
{
  class ebuCoreMainType;
  class coreMetadataType;
  class partType;
  class titleType;
  class alternativeTitleType;
  class identifierType;
  class subjectType;
  class typeType;
  class descriptionType;
  class coverageType;
  class locationType;
  class periodOfTimeType;
  class rightsType;
  class relationType;
  class languageType;
  class dateType;
  class publicationHistoryType;
  class publicationEventType;
  class publicationServiceType;
  class publicationMediumType;
  class publicationChannelType;
  class formatType;
  class entityType;
  class contactDetailsType;
  class organisationDetailsType;
  class detailsType;
  class addressType;
  class compoundNameType;
  class regionType;
  class editUnitNumberType;
  class ratingType;
  class lengthType;
  class dimensionType;
  class imageFormatType;
  class videoFormatType;
  class audioFormatType;
  class dataFormatType;
  class documentFormatType;
  class codecType;
  class timeType;
  class durationType;
  class hashType;
  class String;
  class Boolean;
  class Float;
  class Int8;
  class Int16;
  class Int32;
  class Int64;
  class UInt8;
  class UInt16;
  class UInt32;
  class UInt64;
  class rationalType;
  class aspectRatioType;
  class technicalAttributeRationalType;
  class technicalAttributeUriType;
  class versionType;
  class hasTrackPart;
  class genre;
  class objectType;
  class targetAudience;
  class temporal;
  class spatial;
  class coordinates;
  class created;
  class issued;
  class modified;
  class digitised;
  class released;
  class copyrighted;
  class alternative;
  class medium;
  class containerFormat;
  class signingFormat;
  class dateCreated;
  class dateModified;
  class role;
  class relatedInformationLink;
  class organisationDepartment;
  class relatedInformationLink1;
  class country;
  class country1;
  class countryRegion;
  class orientation;
  class imageEncoding;
  class comment;
  class width;
  class height;
  class videoEncoding;
  class bitRateMode;
  class scanningFormat;
  class scanningOrder;
  class videoTrack;
  class comment1;
  class audioEncoding;
  class audioTrackConfiguration;
  class sampleType;
  class bitRateMode1;
  class audioTrack;
  class comment2;
  class captioningFormat;
  class subtitlingFormat;
  class ancillaryDataFormat;
  class comment3;
  class comment4;
  class timecode;
  class time;
  class timecode1;
  class duration;
  class hashFunction;
  class mimeType;
  class locator;
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "xsd/xml.hxx"

#include "xsd/simpledc20021212.hxx"

namespace ebuCore_2012
{
  class ebuCoreMainType: public ::xml_schema::type
  {
    public:
    // coreMetadata
    // 
    typedef ::ebuCore_2012::coreMetadataType coreMetadata_type;
    typedef ::xsd::cxx::tree::traits< coreMetadata_type, char > coreMetadata_traits;

    const coreMetadata_type&
    coreMetadata () const;

    coreMetadata_type&
    coreMetadata ();

    void
    coreMetadata (const coreMetadata_type& x);

    void
    coreMetadata (::std::auto_ptr< coreMetadata_type > p);

    // metadataProvider
    // 
    typedef ::ebuCore_2012::entityType metadataProvider_type;
    typedef ::xsd::cxx::tree::optional< metadataProvider_type > metadataProvider_optional;
    typedef ::xsd::cxx::tree::traits< metadataProvider_type, char > metadataProvider_traits;

    const metadataProvider_optional&
    metadataProvider () const;

    metadataProvider_optional&
    metadataProvider ();

    void
    metadataProvider (const metadataProvider_type& x);

    void
    metadataProvider (const metadataProvider_optional& x);

    void
    metadataProvider (::std::auto_ptr< metadataProvider_type > p);

    // schema
    // 
    typedef ::xml_schema::simple_type schema_type;
    typedef ::xsd::cxx::tree::optional< schema_type > schema_optional;
    typedef ::xsd::cxx::tree::traits< schema_type, char > schema_traits;

    const schema_optional&
    schema () const;

    schema_optional&
    schema ();

    void
    schema (const schema_type& x);

    void
    schema (const schema_optional& x);

    void
    schema (::std::auto_ptr< schema_type > p);

    // version
    // 
    typedef ::xml_schema::simple_type version_type;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_type&
    version () const;

    version_type&
    version ();

    void
    version (const version_type& x);

    void
    version (::std::auto_ptr< version_type > p);

    static const version_type&
    version_default_value ();

    // dateLastModified
    // 
    typedef ::xml_schema::date dateLastModified_type;
    typedef ::xsd::cxx::tree::optional< dateLastModified_type > dateLastModified_optional;
    typedef ::xsd::cxx::tree::traits< dateLastModified_type, char > dateLastModified_traits;

    const dateLastModified_optional&
    dateLastModified () const;

    dateLastModified_optional&
    dateLastModified ();

    void
    dateLastModified (const dateLastModified_type& x);

    void
    dateLastModified (const dateLastModified_optional& x);

    void
    dateLastModified (::std::auto_ptr< dateLastModified_type > p);

    // documentId
    // 
    typedef ::xml_schema::nmtoken documentId_type;
    typedef ::xsd::cxx::tree::optional< documentId_type > documentId_optional;
    typedef ::xsd::cxx::tree::traits< documentId_type, char > documentId_traits;

    const documentId_optional&
    documentId () const;

    documentId_optional&
    documentId ();

    void
    documentId (const documentId_type& x);

    void
    documentId (const documentId_optional& x);

    void
    documentId (::std::auto_ptr< documentId_type > p);

    // documentLocation
    // 
    typedef ::xml_schema::uri documentLocation_type;
    typedef ::xsd::cxx::tree::optional< documentLocation_type > documentLocation_optional;
    typedef ::xsd::cxx::tree::traits< documentLocation_type, char > documentLocation_traits;

    const documentLocation_optional&
    documentLocation () const;

    documentLocation_optional&
    documentLocation ();

    void
    documentLocation (const documentLocation_type& x);

    void
    documentLocation (const documentLocation_optional& x);

    void
    documentLocation (::std::auto_ptr< documentLocation_type > p);

    // lang
    // 
    typedef ::xml_schema::language lang_type;
    typedef ::xsd::cxx::tree::optional< lang_type > lang_optional;
    typedef ::xsd::cxx::tree::traits< lang_type, char > lang_traits;

    const lang_optional&
    lang () const;

    lang_optional&
    lang ();

    void
    lang (const lang_type& x);

    void
    lang (const lang_optional& x);

    void
    lang (::std::auto_ptr< lang_type > p);

    // Constructors.
    //
    ebuCoreMainType (const coreMetadata_type&);

    ebuCoreMainType (::std::auto_ptr< coreMetadata_type >&);

    ebuCoreMainType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    ebuCoreMainType (const ebuCoreMainType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual ebuCoreMainType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ebuCoreMainType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< coreMetadata_type > coreMetadata_;
    metadataProvider_optional metadataProvider_;
    schema_optional schema_;
    ::xsd::cxx::tree::one< version_type > version_;
    static const version_type version_default_value_;
    dateLastModified_optional dateLastModified_;
    documentId_optional documentId_;
    documentLocation_optional documentLocation_;
    lang_optional lang_;
  };

  class coreMetadataType: public ::xml_schema::type
  {
    public:
    // title
    // 
    typedef ::ebuCore_2012::titleType title_type;
    typedef ::xsd::cxx::tree::sequence< title_type > title_sequence;
    typedef title_sequence::iterator title_iterator;
    typedef title_sequence::const_iterator title_const_iterator;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_sequence&
    title () const;

    title_sequence&
    title ();

    void
    title (const title_sequence& s);

    // alternativeTitle
    // 
    typedef ::ebuCore_2012::alternativeTitleType alternativeTitle_type;
    typedef ::xsd::cxx::tree::sequence< alternativeTitle_type > alternativeTitle_sequence;
    typedef alternativeTitle_sequence::iterator alternativeTitle_iterator;
    typedef alternativeTitle_sequence::const_iterator alternativeTitle_const_iterator;
    typedef ::xsd::cxx::tree::traits< alternativeTitle_type, char > alternativeTitle_traits;

    const alternativeTitle_sequence&
    alternativeTitle () const;

    alternativeTitle_sequence&
    alternativeTitle ();

    void
    alternativeTitle (const alternativeTitle_sequence& s);

    // creator
    // 
    typedef ::ebuCore_2012::entityType creator_type;
    typedef ::xsd::cxx::tree::sequence< creator_type > creator_sequence;
    typedef creator_sequence::iterator creator_iterator;
    typedef creator_sequence::const_iterator creator_const_iterator;
    typedef ::xsd::cxx::tree::traits< creator_type, char > creator_traits;

    const creator_sequence&
    creator () const;

    creator_sequence&
    creator ();

    void
    creator (const creator_sequence& s);

    // subject
    // 
    typedef ::ebuCore_2012::subjectType subject_type;
    typedef ::xsd::cxx::tree::sequence< subject_type > subject_sequence;
    typedef subject_sequence::iterator subject_iterator;
    typedef subject_sequence::const_iterator subject_const_iterator;
    typedef ::xsd::cxx::tree::traits< subject_type, char > subject_traits;

    const subject_sequence&
    subject () const;

    subject_sequence&
    subject ();

    void
    subject (const subject_sequence& s);

    // description
    // 
    typedef ::ebuCore_2012::descriptionType description_type;
    typedef ::xsd::cxx::tree::sequence< description_type > description_sequence;
    typedef description_sequence::iterator description_iterator;
    typedef description_sequence::const_iterator description_const_iterator;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_sequence&
    description () const;

    description_sequence&
    description ();

    void
    description (const description_sequence& s);

    // publisher
    // 
    typedef ::ebuCore_2012::entityType publisher_type;
    typedef ::xsd::cxx::tree::sequence< publisher_type > publisher_sequence;
    typedef publisher_sequence::iterator publisher_iterator;
    typedef publisher_sequence::const_iterator publisher_const_iterator;
    typedef ::xsd::cxx::tree::traits< publisher_type, char > publisher_traits;

    const publisher_sequence&
    publisher () const;

    publisher_sequence&
    publisher ();

    void
    publisher (const publisher_sequence& s);

    // contributor
    // 
    typedef ::ebuCore_2012::entityType contributor_type;
    typedef ::xsd::cxx::tree::sequence< contributor_type > contributor_sequence;
    typedef contributor_sequence::iterator contributor_iterator;
    typedef contributor_sequence::const_iterator contributor_const_iterator;
    typedef ::xsd::cxx::tree::traits< contributor_type, char > contributor_traits;

    const contributor_sequence&
    contributor () const;

    contributor_sequence&
    contributor ();

    void
    contributor (const contributor_sequence& s);

    // date
    // 
    typedef ::ebuCore_2012::dateType date_type;
    typedef ::xsd::cxx::tree::sequence< date_type > date_sequence;
    typedef date_sequence::iterator date_iterator;
    typedef date_sequence::const_iterator date_const_iterator;
    typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

    const date_sequence&
    date () const;

    date_sequence&
    date ();

    void
    date (const date_sequence& s);

    // type
    // 
    typedef ::ebuCore_2012::typeType type_type;
    typedef ::xsd::cxx::tree::sequence< type_type > type_sequence;
    typedef type_sequence::iterator type_iterator;
    typedef type_sequence::const_iterator type_const_iterator;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_sequence&
    type () const;

    type_sequence&
    type ();

    void
    type (const type_sequence& s);

    // format
    // 
    typedef ::ebuCore_2012::formatType format_type;
    typedef ::xsd::cxx::tree::sequence< format_type > format_sequence;
    typedef format_sequence::iterator format_iterator;
    typedef format_sequence::const_iterator format_const_iterator;
    typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

    const format_sequence&
    format () const;

    format_sequence&
    format ();

    void
    format (const format_sequence& s);

    // identifier
    // 
    typedef ::ebuCore_2012::identifierType identifier_type;
    typedef ::xsd::cxx::tree::sequence< identifier_type > identifier_sequence;
    typedef identifier_sequence::iterator identifier_iterator;
    typedef identifier_sequence::const_iterator identifier_const_iterator;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_sequence&
    identifier () const;

    identifier_sequence&
    identifier ();

    void
    identifier (const identifier_sequence& s);

    // source
    // 
    typedef ::dc::elementType source_type;
    typedef ::xsd::cxx::tree::sequence< source_type > source_sequence;
    typedef source_sequence::iterator source_iterator;
    typedef source_sequence::const_iterator source_const_iterator;
    typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

    const source_sequence&
    source () const;

    source_sequence&
    source ();

    void
    source (const source_sequence& s);

    // language
    // 
    typedef ::ebuCore_2012::languageType language_type;
    typedef ::xsd::cxx::tree::sequence< language_type > language_sequence;
    typedef language_sequence::iterator language_iterator;
    typedef language_sequence::const_iterator language_const_iterator;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_sequence&
    language () const;

    language_sequence&
    language ();

    void
    language (const language_sequence& s);

    // relation
    // 
    typedef ::ebuCore_2012::relationType relation_type;
    typedef ::xsd::cxx::tree::sequence< relation_type > relation_sequence;
    typedef relation_sequence::iterator relation_iterator;
    typedef relation_sequence::const_iterator relation_const_iterator;
    typedef ::xsd::cxx::tree::traits< relation_type, char > relation_traits;

    const relation_sequence&
    relation () const;

    relation_sequence&
    relation ();

    void
    relation (const relation_sequence& s);

    // isVersionOf
    // 
    typedef ::ebuCore_2012::relationType isVersionOf_type;
    typedef ::xsd::cxx::tree::sequence< isVersionOf_type > isVersionOf_sequence;
    typedef isVersionOf_sequence::iterator isVersionOf_iterator;
    typedef isVersionOf_sequence::const_iterator isVersionOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isVersionOf_type, char > isVersionOf_traits;

    const isVersionOf_sequence&
    isVersionOf () const;

    isVersionOf_sequence&
    isVersionOf ();

    void
    isVersionOf (const isVersionOf_sequence& s);

    // hasVersion
    // 
    typedef ::ebuCore_2012::relationType hasVersion_type;
    typedef ::xsd::cxx::tree::sequence< hasVersion_type > hasVersion_sequence;
    typedef hasVersion_sequence::iterator hasVersion_iterator;
    typedef hasVersion_sequence::const_iterator hasVersion_const_iterator;
    typedef ::xsd::cxx::tree::traits< hasVersion_type, char > hasVersion_traits;

    const hasVersion_sequence&
    hasVersion () const;

    hasVersion_sequence&
    hasVersion ();

    void
    hasVersion (const hasVersion_sequence& s);

    // isReplacedBy
    // 
    typedef ::ebuCore_2012::relationType isReplacedBy_type;
    typedef ::xsd::cxx::tree::sequence< isReplacedBy_type > isReplacedBy_sequence;
    typedef isReplacedBy_sequence::iterator isReplacedBy_iterator;
    typedef isReplacedBy_sequence::const_iterator isReplacedBy_const_iterator;
    typedef ::xsd::cxx::tree::traits< isReplacedBy_type, char > isReplacedBy_traits;

    const isReplacedBy_sequence&
    isReplacedBy () const;

    isReplacedBy_sequence&
    isReplacedBy ();

    void
    isReplacedBy (const isReplacedBy_sequence& s);

    // replaces
    // 
    typedef ::ebuCore_2012::relationType replaces_type;
    typedef ::xsd::cxx::tree::sequence< replaces_type > replaces_sequence;
    typedef replaces_sequence::iterator replaces_iterator;
    typedef replaces_sequence::const_iterator replaces_const_iterator;
    typedef ::xsd::cxx::tree::traits< replaces_type, char > replaces_traits;

    const replaces_sequence&
    replaces () const;

    replaces_sequence&
    replaces ();

    void
    replaces (const replaces_sequence& s);

    // isRequiredBy
    // 
    typedef ::ebuCore_2012::relationType isRequiredBy_type;
    typedef ::xsd::cxx::tree::sequence< isRequiredBy_type > isRequiredBy_sequence;
    typedef isRequiredBy_sequence::iterator isRequiredBy_iterator;
    typedef isRequiredBy_sequence::const_iterator isRequiredBy_const_iterator;
    typedef ::xsd::cxx::tree::traits< isRequiredBy_type, char > isRequiredBy_traits;

    const isRequiredBy_sequence&
    isRequiredBy () const;

    isRequiredBy_sequence&
    isRequiredBy ();

    void
    isRequiredBy (const isRequiredBy_sequence& s);

    // requires
    // 
    typedef ::ebuCore_2012::relationType requires_type;
    typedef ::xsd::cxx::tree::sequence< requires_type > requires_sequence;
    typedef requires_sequence::iterator requires_iterator;
    typedef requires_sequence::const_iterator requires_const_iterator;
    typedef ::xsd::cxx::tree::traits< requires_type, char > requires_traits;

    const requires_sequence&
    requires () const;

    requires_sequence&
    requires ();

    void
    requires (const requires_sequence& s);

    // isPartOf
    // 
    typedef ::ebuCore_2012::relationType isPartOf_type;
    typedef ::xsd::cxx::tree::sequence< isPartOf_type > isPartOf_sequence;
    typedef isPartOf_sequence::iterator isPartOf_iterator;
    typedef isPartOf_sequence::const_iterator isPartOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isPartOf_type, char > isPartOf_traits;

    const isPartOf_sequence&
    isPartOf () const;

    isPartOf_sequence&
    isPartOf ();

    void
    isPartOf (const isPartOf_sequence& s);

    // hasPart
    // 
    typedef ::ebuCore_2012::relationType hasPart_type;
    typedef ::xsd::cxx::tree::sequence< hasPart_type > hasPart_sequence;
    typedef hasPart_sequence::iterator hasPart_iterator;
    typedef hasPart_sequence::const_iterator hasPart_const_iterator;
    typedef ::xsd::cxx::tree::traits< hasPart_type, char > hasPart_traits;

    const hasPart_sequence&
    hasPart () const;

    hasPart_sequence&
    hasPart ();

    void
    hasPart (const hasPart_sequence& s);

    // hasTrackPart
    // 
    typedef ::ebuCore_2012::hasTrackPart hasTrackPart_type;
    typedef ::xsd::cxx::tree::sequence< hasTrackPart_type > hasTrackPart_sequence;
    typedef hasTrackPart_sequence::iterator hasTrackPart_iterator;
    typedef hasTrackPart_sequence::const_iterator hasTrackPart_const_iterator;
    typedef ::xsd::cxx::tree::traits< hasTrackPart_type, char > hasTrackPart_traits;

    const hasTrackPart_sequence&
    hasTrackPart () const;

    hasTrackPart_sequence&
    hasTrackPart ();

    void
    hasTrackPart (const hasTrackPart_sequence& s);

    // isReferencedBy
    // 
    typedef ::ebuCore_2012::relationType isReferencedBy_type;
    typedef ::xsd::cxx::tree::sequence< isReferencedBy_type > isReferencedBy_sequence;
    typedef isReferencedBy_sequence::iterator isReferencedBy_iterator;
    typedef isReferencedBy_sequence::const_iterator isReferencedBy_const_iterator;
    typedef ::xsd::cxx::tree::traits< isReferencedBy_type, char > isReferencedBy_traits;

    const isReferencedBy_sequence&
    isReferencedBy () const;

    isReferencedBy_sequence&
    isReferencedBy ();

    void
    isReferencedBy (const isReferencedBy_sequence& s);

    // references
    // 
    typedef ::ebuCore_2012::relationType references_type;
    typedef ::xsd::cxx::tree::sequence< references_type > references_sequence;
    typedef references_sequence::iterator references_iterator;
    typedef references_sequence::const_iterator references_const_iterator;
    typedef ::xsd::cxx::tree::traits< references_type, char > references_traits;

    const references_sequence&
    references () const;

    references_sequence&
    references ();

    void
    references (const references_sequence& s);

    // isFormatOf
    // 
    typedef ::ebuCore_2012::relationType isFormatOf_type;
    typedef ::xsd::cxx::tree::sequence< isFormatOf_type > isFormatOf_sequence;
    typedef isFormatOf_sequence::iterator isFormatOf_iterator;
    typedef isFormatOf_sequence::const_iterator isFormatOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isFormatOf_type, char > isFormatOf_traits;

    const isFormatOf_sequence&
    isFormatOf () const;

    isFormatOf_sequence&
    isFormatOf ();

    void
    isFormatOf (const isFormatOf_sequence& s);

    // hasFormat
    // 
    typedef ::ebuCore_2012::relationType hasFormat_type;
    typedef ::xsd::cxx::tree::sequence< hasFormat_type > hasFormat_sequence;
    typedef hasFormat_sequence::iterator hasFormat_iterator;
    typedef hasFormat_sequence::const_iterator hasFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< hasFormat_type, char > hasFormat_traits;

    const hasFormat_sequence&
    hasFormat () const;

    hasFormat_sequence&
    hasFormat ();

    void
    hasFormat (const hasFormat_sequence& s);

    // isEpisodeOf
    // 
    typedef ::ebuCore_2012::relationType isEpisodeOf_type;
    typedef ::xsd::cxx::tree::sequence< isEpisodeOf_type > isEpisodeOf_sequence;
    typedef isEpisodeOf_sequence::iterator isEpisodeOf_iterator;
    typedef isEpisodeOf_sequence::const_iterator isEpisodeOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isEpisodeOf_type, char > isEpisodeOf_traits;

    const isEpisodeOf_sequence&
    isEpisodeOf () const;

    isEpisodeOf_sequence&
    isEpisodeOf ();

    void
    isEpisodeOf (const isEpisodeOf_sequence& s);

    // isMemberOf
    // 
    typedef ::ebuCore_2012::relationType isMemberOf_type;
    typedef ::xsd::cxx::tree::sequence< isMemberOf_type > isMemberOf_sequence;
    typedef isMemberOf_sequence::iterator isMemberOf_iterator;
    typedef isMemberOf_sequence::const_iterator isMemberOf_const_iterator;
    typedef ::xsd::cxx::tree::traits< isMemberOf_type, char > isMemberOf_traits;

    const isMemberOf_sequence&
    isMemberOf () const;

    isMemberOf_sequence&
    isMemberOf ();

    void
    isMemberOf (const isMemberOf_sequence& s);

    // hasMember
    // 
    typedef ::ebuCore_2012::relationType hasMember_type;
    typedef ::xsd::cxx::tree::sequence< hasMember_type > hasMember_sequence;
    typedef hasMember_sequence::iterator hasMember_iterator;
    typedef hasMember_sequence::const_iterator hasMember_const_iterator;
    typedef ::xsd::cxx::tree::traits< hasMember_type, char > hasMember_traits;

    const hasMember_sequence&
    hasMember () const;

    hasMember_sequence&
    hasMember ();

    void
    hasMember (const hasMember_sequence& s);

    // coverage
    // 
    typedef ::ebuCore_2012::coverageType coverage_type;
    typedef ::xsd::cxx::tree::sequence< coverage_type > coverage_sequence;
    typedef coverage_sequence::iterator coverage_iterator;
    typedef coverage_sequence::const_iterator coverage_const_iterator;
    typedef ::xsd::cxx::tree::traits< coverage_type, char > coverage_traits;

    const coverage_sequence&
    coverage () const;

    coverage_sequence&
    coverage ();

    void
    coverage (const coverage_sequence& s);

    // rights
    // 
    typedef ::ebuCore_2012::rightsType rights_type;
    typedef ::xsd::cxx::tree::sequence< rights_type > rights_sequence;
    typedef rights_sequence::iterator rights_iterator;
    typedef rights_sequence::const_iterator rights_const_iterator;
    typedef ::xsd::cxx::tree::traits< rights_type, char > rights_traits;

    const rights_sequence&
    rights () const;

    rights_sequence&
    rights ();

    void
    rights (const rights_sequence& s);

    // version
    // 
    typedef ::ebuCore_2012::versionType version_type;
    typedef ::xsd::cxx::tree::sequence< version_type > version_sequence;
    typedef version_sequence::iterator version_iterator;
    typedef version_sequence::const_iterator version_const_iterator;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_sequence&
    version () const;

    version_sequence&
    version ();

    void
    version (const version_sequence& s);

    // publicationHistory
    // 
    typedef ::ebuCore_2012::publicationHistoryType publicationHistory_type;
    typedef ::xsd::cxx::tree::optional< publicationHistory_type > publicationHistory_optional;
    typedef ::xsd::cxx::tree::traits< publicationHistory_type, char > publicationHistory_traits;

    const publicationHistory_optional&
    publicationHistory () const;

    publicationHistory_optional&
    publicationHistory ();

    void
    publicationHistory (const publicationHistory_type& x);

    void
    publicationHistory (const publicationHistory_optional& x);

    void
    publicationHistory (::std::auto_ptr< publicationHistory_type > p);

    // rating
    // 
    typedef ::ebuCore_2012::ratingType rating_type;
    typedef ::xsd::cxx::tree::sequence< rating_type > rating_sequence;
    typedef rating_sequence::iterator rating_iterator;
    typedef rating_sequence::const_iterator rating_const_iterator;
    typedef ::xsd::cxx::tree::traits< rating_type, char > rating_traits;

    const rating_sequence&
    rating () const;

    rating_sequence&
    rating ();

    void
    rating (const rating_sequence& s);

    // part
    // 
    typedef ::ebuCore_2012::partType part_type;
    typedef ::xsd::cxx::tree::sequence< part_type > part_sequence;
    typedef part_sequence::iterator part_iterator;
    typedef part_sequence::const_iterator part_const_iterator;
    typedef ::xsd::cxx::tree::traits< part_type, char > part_traits;

    const part_sequence&
    part () const;

    part_sequence&
    part ();

    void
    part (const part_sequence& s);

    // Constructors.
    //
    coreMetadataType ();

    coreMetadataType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    coreMetadataType (const coreMetadataType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual coreMetadataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~coreMetadataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    title_sequence title_;
    alternativeTitle_sequence alternativeTitle_;
    creator_sequence creator_;
    subject_sequence subject_;
    description_sequence description_;
    publisher_sequence publisher_;
    contributor_sequence contributor_;
    date_sequence date_;
    type_sequence type_;
    format_sequence format_;
    identifier_sequence identifier_;
    source_sequence source_;
    language_sequence language_;
    relation_sequence relation_;
    isVersionOf_sequence isVersionOf_;
    hasVersion_sequence hasVersion_;
    isReplacedBy_sequence isReplacedBy_;
    replaces_sequence replaces_;
    isRequiredBy_sequence isRequiredBy_;
    requires_sequence requires_;
    isPartOf_sequence isPartOf_;
    hasPart_sequence hasPart_;
    hasTrackPart_sequence hasTrackPart_;
    isReferencedBy_sequence isReferencedBy_;
    references_sequence references_;
    isFormatOf_sequence isFormatOf_;
    hasFormat_sequence hasFormat_;
    isEpisodeOf_sequence isEpisodeOf_;
    isMemberOf_sequence isMemberOf_;
    hasMember_sequence hasMember_;
    coverage_sequence coverage_;
    rights_sequence rights_;
    version_sequence version_;
    publicationHistory_optional publicationHistory_;
    rating_sequence rating_;
    part_sequence part_;
  };

  class partType: public ::ebuCore_2012::coreMetadataType
  {
    public:
    // partStartTime
    // 
    typedef ::ebuCore_2012::timeType partStartTime_type;
    typedef ::xsd::cxx::tree::optional< partStartTime_type > partStartTime_optional;
    typedef ::xsd::cxx::tree::traits< partStartTime_type, char > partStartTime_traits;

    const partStartTime_optional&
    partStartTime () const;

    partStartTime_optional&
    partStartTime ();

    void
    partStartTime (const partStartTime_type& x);

    void
    partStartTime (const partStartTime_optional& x);

    void
    partStartTime (::std::auto_ptr< partStartTime_type > p);

    // partDuration
    // 
    typedef ::ebuCore_2012::durationType partDuration_type;
    typedef ::xsd::cxx::tree::optional< partDuration_type > partDuration_optional;
    typedef ::xsd::cxx::tree::traits< partDuration_type, char > partDuration_traits;

    const partDuration_optional&
    partDuration () const;

    partDuration_optional&
    partDuration ();

    void
    partDuration (const partDuration_type& x);

    void
    partDuration (const partDuration_optional& x);

    void
    partDuration (::std::auto_ptr< partDuration_type > p);

    // partId
    // 
    typedef ::xml_schema::nmtoken partId_type;
    typedef ::xsd::cxx::tree::optional< partId_type > partId_optional;
    typedef ::xsd::cxx::tree::traits< partId_type, char > partId_traits;

    const partId_optional&
    partId () const;

    partId_optional&
    partId ();

    void
    partId (const partId_type& x);

    void
    partId (const partId_optional& x);

    void
    partId (::std::auto_ptr< partId_type > p);

    // partName
    // 
    typedef ::xml_schema::string partName_type;
    typedef ::xsd::cxx::tree::optional< partName_type > partName_optional;
    typedef ::xsd::cxx::tree::traits< partName_type, char > partName_traits;

    const partName_optional&
    partName () const;

    partName_optional&
    partName ();

    void
    partName (const partName_type& x);

    void
    partName (const partName_optional& x);

    void
    partName (::std::auto_ptr< partName_type > p);

    // partDefinition
    // 
    typedef ::xml_schema::string partDefinition_type;
    typedef ::xsd::cxx::tree::optional< partDefinition_type > partDefinition_optional;
    typedef ::xsd::cxx::tree::traits< partDefinition_type, char > partDefinition_traits;

    const partDefinition_optional&
    partDefinition () const;

    partDefinition_optional&
    partDefinition ();

    void
    partDefinition (const partDefinition_type& x);

    void
    partDefinition (const partDefinition_optional& x);

    void
    partDefinition (::std::auto_ptr< partDefinition_type > p);

    // partNumber
    // 
    typedef ::xml_schema::integer partNumber_type;
    typedef ::xsd::cxx::tree::optional< partNumber_type > partNumber_optional;
    typedef ::xsd::cxx::tree::traits< partNumber_type, char > partNumber_traits;

    const partNumber_optional&
    partNumber () const;

    partNumber_optional&
    partNumber ();

    void
    partNumber (const partNumber_type& x);

    void
    partNumber (const partNumber_optional& x);

    // partTotalNumber
    // 
    typedef ::xml_schema::integer partTotalNumber_type;
    typedef ::xsd::cxx::tree::optional< partTotalNumber_type > partTotalNumber_optional;
    typedef ::xsd::cxx::tree::traits< partTotalNumber_type, char > partTotalNumber_traits;

    const partTotalNumber_optional&
    partTotalNumber () const;

    partTotalNumber_optional&
    partTotalNumber ();

    void
    partTotalNumber (const partTotalNumber_type& x);

    void
    partTotalNumber (const partTotalNumber_optional& x);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    partType ();

    partType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    partType (const partType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual partType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~partType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    partStartTime_optional partStartTime_;
    partDuration_optional partDuration_;
    partId_optional partId_;
    partName_optional partName_;
    partDefinition_optional partDefinition_;
    partNumber_optional partNumber_;
    partTotalNumber_optional partTotalNumber_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class titleType: public ::xml_schema::type
  {
    public:
    // title
    // 
    typedef ::dc::elementType title_type;
    typedef ::xsd::cxx::tree::sequence< title_type > title_sequence;
    typedef title_sequence::iterator title_iterator;
    typedef title_sequence::const_iterator title_const_iterator;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_sequence&
    title () const;

    title_sequence&
    title ();

    void
    title (const title_sequence& s);

    // attributiondate
    // 
    typedef ::xml_schema::date attributiondate_type;
    typedef ::xsd::cxx::tree::optional< attributiondate_type > attributiondate_optional;
    typedef ::xsd::cxx::tree::traits< attributiondate_type, char > attributiondate_traits;

    const attributiondate_optional&
    attributiondate () const;

    attributiondate_optional&
    attributiondate ();

    void
    attributiondate (const attributiondate_type& x);

    void
    attributiondate (const attributiondate_optional& x);

    void
    attributiondate (::std::auto_ptr< attributiondate_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    titleType ();

    titleType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    titleType (const titleType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual titleType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~titleType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    title_sequence title_;
    attributiondate_optional attributiondate_;
    note_optional note_;
  };

  class alternativeTitleType: public ::xml_schema::type
  {
    public:
    // title
    // 
    typedef ::dc::elementType title_type;
    typedef ::xsd::cxx::tree::sequence< title_type > title_sequence;
    typedef title_sequence::iterator title_iterator;
    typedef title_sequence::const_iterator title_const_iterator;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_sequence&
    title () const;

    title_sequence&
    title ();

    void
    title (const title_sequence& s);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // statusLabel
    // 
    typedef ::xml_schema::string statusLabel_type;
    typedef ::xsd::cxx::tree::optional< statusLabel_type > statusLabel_optional;
    typedef ::xsd::cxx::tree::traits< statusLabel_type, char > statusLabel_traits;

    const statusLabel_optional&
    statusLabel () const;

    statusLabel_optional&
    statusLabel ();

    void
    statusLabel (const statusLabel_type& x);

    void
    statusLabel (const statusLabel_optional& x);

    void
    statusLabel (::std::auto_ptr< statusLabel_type > p);

    // statusDefinition
    // 
    typedef ::xml_schema::string statusDefinition_type;
    typedef ::xsd::cxx::tree::optional< statusDefinition_type > statusDefinition_optional;
    typedef ::xsd::cxx::tree::traits< statusDefinition_type, char > statusDefinition_traits;

    const statusDefinition_optional&
    statusDefinition () const;

    statusDefinition_optional&
    statusDefinition ();

    void
    statusDefinition (const statusDefinition_type& x);

    void
    statusDefinition (const statusDefinition_optional& x);

    void
    statusDefinition (::std::auto_ptr< statusDefinition_type > p);

    // statusLink
    // 
    typedef ::xml_schema::uri statusLink_type;
    typedef ::xsd::cxx::tree::optional< statusLink_type > statusLink_optional;
    typedef ::xsd::cxx::tree::traits< statusLink_type, char > statusLink_traits;

    const statusLink_optional&
    statusLink () const;

    statusLink_optional&
    statusLink ();

    void
    statusLink (const statusLink_type& x);

    void
    statusLink (const statusLink_optional& x);

    void
    statusLink (::std::auto_ptr< statusLink_type > p);

    // statusLanguage
    // 
    typedef ::xml_schema::language statusLanguage_type;
    typedef ::xsd::cxx::tree::optional< statusLanguage_type > statusLanguage_optional;
    typedef ::xsd::cxx::tree::traits< statusLanguage_type, char > statusLanguage_traits;

    const statusLanguage_optional&
    statusLanguage () const;

    statusLanguage_optional&
    statusLanguage ();

    void
    statusLanguage (const statusLanguage_type& x);

    void
    statusLanguage (const statusLanguage_optional& x);

    void
    statusLanguage (::std::auto_ptr< statusLanguage_type > p);

    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    alternativeTitleType ();

    alternativeTitleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    alternativeTitleType (const alternativeTitleType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual alternativeTitleType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~alternativeTitleType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    title_sequence title_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    statusLabel_optional statusLabel_;
    statusDefinition_optional statusDefinition_;
    statusLink_optional statusLink_;
    statusLanguage_optional statusLanguage_;
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    note_optional note_;
  };

  class identifierType: public ::xml_schema::type
  {
    public:
    // identifier
    // 
    typedef ::dc::elementType identifier_type;
    typedef ::xsd::cxx::tree::traits< identifier_type, char > identifier_traits;

    const identifier_type&
    identifier () const;

    identifier_type&
    identifier ();

    void
    identifier (const identifier_type& x);

    void
    identifier (::std::auto_ptr< identifier_type > p);

    // attributor
    // 
    typedef ::ebuCore_2012::entityType attributor_type;
    typedef ::xsd::cxx::tree::optional< attributor_type > attributor_optional;
    typedef ::xsd::cxx::tree::traits< attributor_type, char > attributor_traits;

    const attributor_optional&
    attributor () const;

    attributor_optional&
    attributor ();

    void
    attributor (const attributor_type& x);

    void
    attributor (const attributor_optional& x);

    void
    attributor (::std::auto_ptr< attributor_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    identifierType (const identifier_type&);

    identifierType (::std::auto_ptr< identifier_type >&);

    identifierType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    identifierType (const identifierType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual identifierType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~identifierType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< identifier_type > identifier_;
    attributor_optional attributor_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
    note_optional note_;
  };

  class subjectType: public ::xml_schema::type
  {
    public:
    // subject
    // 
    typedef ::dc::elementType subject_type;
    typedef ::xsd::cxx::tree::sequence< subject_type > subject_sequence;
    typedef subject_sequence::iterator subject_iterator;
    typedef subject_sequence::const_iterator subject_const_iterator;
    typedef ::xsd::cxx::tree::traits< subject_type, char > subject_traits;

    const subject_sequence&
    subject () const;

    subject_sequence&
    subject ();

    void
    subject (const subject_sequence& s);

    // subjectCode
    // 
    typedef ::xml_schema::uri subjectCode_type;
    typedef ::xsd::cxx::tree::optional< subjectCode_type > subjectCode_optional;
    typedef ::xsd::cxx::tree::traits< subjectCode_type, char > subjectCode_traits;

    const subjectCode_optional&
    subjectCode () const;

    subjectCode_optional&
    subjectCode ();

    void
    subjectCode (const subjectCode_type& x);

    void
    subjectCode (const subjectCode_optional& x);

    void
    subjectCode (::std::auto_ptr< subjectCode_type > p);

    // subjectDefinition
    // 
    typedef ::dc::elementType subjectDefinition_type;
    typedef ::xsd::cxx::tree::sequence< subjectDefinition_type > subjectDefinition_sequence;
    typedef subjectDefinition_sequence::iterator subjectDefinition_iterator;
    typedef subjectDefinition_sequence::const_iterator subjectDefinition_const_iterator;
    typedef ::xsd::cxx::tree::traits< subjectDefinition_type, char > subjectDefinition_traits;

    const subjectDefinition_sequence&
    subjectDefinition () const;

    subjectDefinition_sequence&
    subjectDefinition ();

    void
    subjectDefinition (const subjectDefinition_sequence& s);

    // attributor
    // 
    typedef ::ebuCore_2012::entityType attributor_type;
    typedef ::xsd::cxx::tree::optional< attributor_type > attributor_optional;
    typedef ::xsd::cxx::tree::traits< attributor_type, char > attributor_traits;

    const attributor_optional&
    attributor () const;

    attributor_optional&
    attributor ();

    void
    attributor (const attributor_type& x);

    void
    attributor (const attributor_optional& x);

    void
    attributor (::std::auto_ptr< attributor_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    subjectType ();

    subjectType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    subjectType (const subjectType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual subjectType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~subjectType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    subject_sequence subject_;
    subjectCode_optional subjectCode_;
    subjectDefinition_sequence subjectDefinition_;
    attributor_optional attributor_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    note_optional note_;
  };

  class typeType: public ::xml_schema::type
  {
    public:
    // type
    // 
    typedef ::dc::elementType type_type;
    typedef ::xsd::cxx::tree::sequence< type_type > type_sequence;
    typedef type_sequence::iterator type_iterator;
    typedef type_sequence::const_iterator type_const_iterator;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_sequence&
    type () const;

    type_sequence&
    type ();

    void
    type (const type_sequence& s);

    // genre
    // 
    typedef ::ebuCore_2012::genre genre_type;
    typedef ::xsd::cxx::tree::sequence< genre_type > genre_sequence;
    typedef genre_sequence::iterator genre_iterator;
    typedef genre_sequence::const_iterator genre_const_iterator;
    typedef ::xsd::cxx::tree::traits< genre_type, char > genre_traits;

    const genre_sequence&
    genre () const;

    genre_sequence&
    genre ();

    void
    genre (const genre_sequence& s);

    // objectType
    // 
    typedef ::ebuCore_2012::objectType objectType_type;
    typedef ::xsd::cxx::tree::sequence< objectType_type > objectType_sequence;
    typedef objectType_sequence::iterator objectType_iterator;
    typedef objectType_sequence::const_iterator objectType_const_iterator;
    typedef ::xsd::cxx::tree::traits< objectType_type, char > objectType_traits;

    const objectType_sequence&
    objectType () const;

    objectType_sequence&
    objectType ();

    void
    objectType (const objectType_sequence& s);

    // targetAudience
    // 
    typedef ::ebuCore_2012::targetAudience targetAudience_type;
    typedef ::xsd::cxx::tree::sequence< targetAudience_type > targetAudience_sequence;
    typedef targetAudience_sequence::iterator targetAudience_iterator;
    typedef targetAudience_sequence::const_iterator targetAudience_const_iterator;
    typedef ::xsd::cxx::tree::traits< targetAudience_type, char > targetAudience_traits;

    const targetAudience_sequence&
    targetAudience () const;

    targetAudience_sequence&
    targetAudience ();

    void
    targetAudience (const targetAudience_sequence& s);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    typeType ();

    typeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    typeType (const typeType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual typeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~typeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    type_sequence type_;
    genre_sequence genre_;
    objectType_sequence objectType_;
    targetAudience_sequence targetAudience_;
    note_optional note_;
  };

  class descriptionType: public ::xml_schema::type
  {
    public:
    // description
    // 
    typedef ::dc::elementType description_type;
    typedef ::xsd::cxx::tree::sequence< description_type > description_sequence;
    typedef description_sequence::iterator description_iterator;
    typedef description_sequence::const_iterator description_const_iterator;
    typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

    const description_sequence&
    description () const;

    description_sequence&
    description ();

    void
    description (const description_sequence& s);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    descriptionType ();

    descriptionType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    descriptionType (const descriptionType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual descriptionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~descriptionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    description_sequence description_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    note_optional note_;
  };

  class coverageType: public ::xml_schema::type
  {
    public:
    // coverage
    // 
    typedef ::dc::elementType coverage_type;
    typedef ::xsd::cxx::tree::optional< coverage_type > coverage_optional;
    typedef ::xsd::cxx::tree::traits< coverage_type, char > coverage_traits;

    const coverage_optional&
    coverage () const;

    coverage_optional&
    coverage ();

    void
    coverage (const coverage_type& x);

    void
    coverage (const coverage_optional& x);

    void
    coverage (::std::auto_ptr< coverage_type > p);

    // temporal
    // 
    typedef ::ebuCore_2012::temporal temporal_type;
    typedef ::xsd::cxx::tree::optional< temporal_type > temporal_optional;
    typedef ::xsd::cxx::tree::traits< temporal_type, char > temporal_traits;

    const temporal_optional&
    temporal () const;

    temporal_optional&
    temporal ();

    void
    temporal (const temporal_type& x);

    void
    temporal (const temporal_optional& x);

    void
    temporal (::std::auto_ptr< temporal_type > p);

    // spatial
    // 
    typedef ::ebuCore_2012::spatial spatial_type;
    typedef ::xsd::cxx::tree::optional< spatial_type > spatial_optional;
    typedef ::xsd::cxx::tree::traits< spatial_type, char > spatial_traits;

    const spatial_optional&
    spatial () const;

    spatial_optional&
    spatial ();

    void
    spatial (const spatial_type& x);

    void
    spatial (const spatial_optional& x);

    void
    spatial (::std::auto_ptr< spatial_type > p);

    // Constructors.
    //
    coverageType ();

    coverageType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    coverageType (const coverageType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual coverageType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~coverageType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    coverage_optional coverage_;
    temporal_optional temporal_;
    spatial_optional spatial_;
  };

  class locationType: public ::xml_schema::type
  {
    public:
    // name
    // 
    typedef ::dc::elementType name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // coordinates
    // 
    typedef ::ebuCore_2012::coordinates coordinates_type;
    typedef ::xsd::cxx::tree::optional< coordinates_type > coordinates_optional;
    typedef ::xsd::cxx::tree::traits< coordinates_type, char > coordinates_traits;

    const coordinates_optional&
    coordinates () const;

    coordinates_optional&
    coordinates ();

    void
    coordinates (const coordinates_type& x);

    void
    coordinates (const coordinates_optional& x);

    void
    coordinates (::std::auto_ptr< coordinates_type > p);

    // code
    // 
    typedef ::xml_schema::uri code_type;
    typedef ::xsd::cxx::tree::optional< code_type > code_optional;
    typedef ::xsd::cxx::tree::traits< code_type, char > code_traits;

    const code_optional&
    code () const;

    code_optional&
    code ();

    void
    code (const code_type& x);

    void
    code (const code_optional& x);

    void
    code (::std::auto_ptr< code_type > p);

    // region
    // 
    typedef ::ebuCore_2012::regionType region_type;
    typedef ::xsd::cxx::tree::optional< region_type > region_optional;
    typedef ::xsd::cxx::tree::traits< region_type, char > region_traits;

    const region_optional&
    region () const;

    region_optional&
    region ();

    void
    region (const region_type& x);

    void
    region (const region_optional& x);

    void
    region (::std::auto_ptr< region_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // locationId
    // 
    typedef ::xml_schema::uri locationId_type;
    typedef ::xsd::cxx::tree::optional< locationId_type > locationId_optional;
    typedef ::xsd::cxx::tree::traits< locationId_type, char > locationId_traits;

    const locationId_optional&
    locationId () const;

    locationId_optional&
    locationId ();

    void
    locationId (const locationId_type& x);

    void
    locationId (const locationId_optional& x);

    void
    locationId (::std::auto_ptr< locationId_type > p);

    // Constructors.
    //
    locationType ();

    locationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    locationType (const locationType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual locationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~locationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    name_optional name_;
    coordinates_optional coordinates_;
    code_optional code_;
    region_optional region_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    note_optional note_;
    locationId_optional locationId_;
  };

  class periodOfTimeType: public ::xml_schema::type
  {
    public:
    // periodName
    // 
    typedef ::dc::elementType periodName_type;
    typedef ::xsd::cxx::tree::optional< periodName_type > periodName_optional;
    typedef ::xsd::cxx::tree::traits< periodName_type, char > periodName_traits;

    const periodName_optional&
    periodName () const;

    periodName_optional&
    periodName ();

    void
    periodName (const periodName_type& x);

    void
    periodName (const periodName_optional& x);

    void
    periodName (::std::auto_ptr< periodName_type > p);

    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // Constructors.
    //
    periodOfTimeType ();

    periodOfTimeType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    periodOfTimeType (const periodOfTimeType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual periodOfTimeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~periodOfTimeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    periodName_optional periodName_;
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
  };

  class rightsType: public ::xml_schema::type
  {
    public:
    // rights
    // 
    typedef ::dc::elementType rights_type;
    typedef ::xsd::cxx::tree::sequence< rights_type > rights_sequence;
    typedef rights_sequence::iterator rights_iterator;
    typedef rights_sequence::const_iterator rights_const_iterator;
    typedef ::xsd::cxx::tree::traits< rights_type, char > rights_traits;

    const rights_sequence&
    rights () const;

    rights_sequence&
    rights ();

    void
    rights (const rights_sequence& s);

    // rightsLink
    // 
    typedef ::xml_schema::uri rightsLink_type;
    typedef ::xsd::cxx::tree::optional< rightsLink_type > rightsLink_optional;
    typedef ::xsd::cxx::tree::traits< rightsLink_type, char > rightsLink_traits;

    const rightsLink_optional&
    rightsLink () const;

    rightsLink_optional&
    rightsLink ();

    void
    rightsLink (const rightsLink_type& x);

    void
    rightsLink (const rightsLink_optional& x);

    void
    rightsLink (::std::auto_ptr< rightsLink_type > p);

    // rightsHolder
    // 
    typedef ::ebuCore_2012::entityType rightsHolder_type;
    typedef ::xsd::cxx::tree::sequence< rightsHolder_type > rightsHolder_sequence;
    typedef rightsHolder_sequence::iterator rightsHolder_iterator;
    typedef rightsHolder_sequence::const_iterator rightsHolder_const_iterator;
    typedef ::xsd::cxx::tree::traits< rightsHolder_type, char > rightsHolder_traits;

    const rightsHolder_sequence&
    rightsHolder () const;

    rightsHolder_sequence&
    rightsHolder ();

    void
    rightsHolder (const rightsHolder_sequence& s);

    // exploitationIssues
    // 
    typedef ::dc::elementType exploitationIssues_type;
    typedef ::xsd::cxx::tree::sequence< exploitationIssues_type > exploitationIssues_sequence;
    typedef exploitationIssues_sequence::iterator exploitationIssues_iterator;
    typedef exploitationIssues_sequence::const_iterator exploitationIssues_const_iterator;
    typedef ::xsd::cxx::tree::traits< exploitationIssues_type, char > exploitationIssues_traits;

    const exploitationIssues_sequence&
    exploitationIssues () const;

    exploitationIssues_sequence&
    exploitationIssues ();

    void
    exploitationIssues (const exploitationIssues_sequence& s);

    // copyrightStatement
    // 
    typedef ::dc::elementType copyrightStatement_type;
    typedef ::xsd::cxx::tree::sequence< copyrightStatement_type > copyrightStatement_sequence;
    typedef copyrightStatement_sequence::iterator copyrightStatement_iterator;
    typedef copyrightStatement_sequence::const_iterator copyrightStatement_const_iterator;
    typedef ::xsd::cxx::tree::traits< copyrightStatement_type, char > copyrightStatement_traits;

    const copyrightStatement_sequence&
    copyrightStatement () const;

    copyrightStatement_sequence&
    copyrightStatement ();

    void
    copyrightStatement (const copyrightStatement_sequence& s);

    // coverage
    // 
    typedef ::ebuCore_2012::coverageType coverage_type;
    typedef ::xsd::cxx::tree::optional< coverage_type > coverage_optional;
    typedef ::xsd::cxx::tree::traits< coverage_type, char > coverage_traits;

    const coverage_optional&
    coverage () const;

    coverage_optional&
    coverage ();

    void
    coverage (const coverage_type& x);

    void
    coverage (const coverage_optional& x);

    void
    coverage (::std::auto_ptr< coverage_type > p);

    // rightsClearanceFlag
    // 
    typedef ::xml_schema::boolean rightsClearanceFlag_type;
    typedef ::xsd::cxx::tree::optional< rightsClearanceFlag_type > rightsClearanceFlag_optional;
    typedef ::xsd::cxx::tree::traits< rightsClearanceFlag_type, char > rightsClearanceFlag_traits;

    const rightsClearanceFlag_optional&
    rightsClearanceFlag () const;

    rightsClearanceFlag_optional&
    rightsClearanceFlag ();

    void
    rightsClearanceFlag (const rightsClearanceFlag_type& x);

    void
    rightsClearanceFlag (const rightsClearanceFlag_optional& x);

    // disclaimer
    // 
    typedef ::dc::elementType disclaimer_type;
    typedef ::xsd::cxx::tree::sequence< disclaimer_type > disclaimer_sequence;
    typedef disclaimer_sequence::iterator disclaimer_iterator;
    typedef disclaimer_sequence::const_iterator disclaimer_const_iterator;
    typedef ::xsd::cxx::tree::traits< disclaimer_type, char > disclaimer_traits;

    const disclaimer_sequence&
    disclaimer () const;

    disclaimer_sequence&
    disclaimer ();

    void
    disclaimer (const disclaimer_sequence& s);

    // rightsAttributedId
    // 
    typedef ::ebuCore_2012::identifierType rightsAttributedId_type;
    typedef ::xsd::cxx::tree::sequence< rightsAttributedId_type > rightsAttributedId_sequence;
    typedef rightsAttributedId_sequence::iterator rightsAttributedId_iterator;
    typedef rightsAttributedId_sequence::const_iterator rightsAttributedId_const_iterator;
    typedef ::xsd::cxx::tree::traits< rightsAttributedId_type, char > rightsAttributedId_traits;

    const rightsAttributedId_sequence&
    rightsAttributedId () const;

    rightsAttributedId_sequence&
    rightsAttributedId ();

    void
    rightsAttributedId (const rightsAttributedId_sequence& s);

    // contactDetails
    // 
    typedef ::ebuCore_2012::contactDetailsType contactDetails_type;
    typedef ::xsd::cxx::tree::sequence< contactDetails_type > contactDetails_sequence;
    typedef contactDetails_sequence::iterator contactDetails_iterator;
    typedef contactDetails_sequence::const_iterator contactDetails_const_iterator;
    typedef ::xsd::cxx::tree::traits< contactDetails_type, char > contactDetails_traits;

    const contactDetails_sequence&
    contactDetails () const;

    contactDetails_sequence&
    contactDetails ();

    void
    contactDetails (const contactDetails_sequence& s);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // formatIDRefs
    // 
    typedef ::xml_schema::idrefs formatIDRefs_type;
    typedef ::xsd::cxx::tree::optional< formatIDRefs_type > formatIDRefs_optional;
    typedef ::xsd::cxx::tree::traits< formatIDRefs_type, char > formatIDRefs_traits;

    const formatIDRefs_optional&
    formatIDRefs () const;

    formatIDRefs_optional&
    formatIDRefs ();

    void
    formatIDRefs (const formatIDRefs_type& x);

    void
    formatIDRefs (const formatIDRefs_optional& x);

    void
    formatIDRefs (::std::auto_ptr< formatIDRefs_type > p);

    // rightsID
    // 
    typedef ::xml_schema::id rightsID_type;
    typedef ::xsd::cxx::tree::optional< rightsID_type > rightsID_optional;
    typedef ::xsd::cxx::tree::traits< rightsID_type, char > rightsID_traits;

    const rightsID_optional&
    rightsID () const;

    rightsID_optional&
    rightsID ();

    void
    rightsID (const rightsID_type& x);

    void
    rightsID (const rightsID_optional& x);

    void
    rightsID (::std::auto_ptr< rightsID_type > p);

    // Constructors.
    //
    rightsType ();

    rightsType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    rightsType (const rightsType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual rightsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~rightsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    rights_sequence rights_;
    rightsLink_optional rightsLink_;
    rightsHolder_sequence rightsHolder_;
    exploitationIssues_sequence exploitationIssues_;
    copyrightStatement_sequence copyrightStatement_;
    coverage_optional coverage_;
    rightsClearanceFlag_optional rightsClearanceFlag_;
    disclaimer_sequence disclaimer_;
    rightsAttributedId_sequence rightsAttributedId_;
    contactDetails_sequence contactDetails_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    note_optional note_;
    formatIDRefs_optional formatIDRefs_;
    rightsID_optional rightsID_;
  };

  class relationType: public ::xml_schema::type
  {
    public:
    // relation
    // 
    typedef ::dc::elementType relation_type;
    typedef ::xsd::cxx::tree::optional< relation_type > relation_optional;
    typedef ::xsd::cxx::tree::traits< relation_type, char > relation_traits;

    const relation_optional&
    relation () const;

    relation_optional&
    relation ();

    void
    relation (const relation_type& x);

    void
    relation (const relation_optional& x);

    void
    relation (::std::auto_ptr< relation_type > p);

    // relationIdentifier
    // 
    typedef ::ebuCore_2012::identifierType relationIdentifier_type;
    typedef ::xsd::cxx::tree::optional< relationIdentifier_type > relationIdentifier_optional;
    typedef ::xsd::cxx::tree::traits< relationIdentifier_type, char > relationIdentifier_traits;

    const relationIdentifier_optional&
    relationIdentifier () const;

    relationIdentifier_optional&
    relationIdentifier ();

    void
    relationIdentifier (const relationIdentifier_type& x);

    void
    relationIdentifier (const relationIdentifier_optional& x);

    void
    relationIdentifier (::std::auto_ptr< relationIdentifier_type > p);

    // relationLink
    // 
    typedef ::xml_schema::uri relationLink_type;
    typedef ::xsd::cxx::tree::optional< relationLink_type > relationLink_optional;
    typedef ::xsd::cxx::tree::traits< relationLink_type, char > relationLink_traits;

    const relationLink_optional&
    relationLink () const;

    relationLink_optional&
    relationLink ();

    void
    relationLink (const relationLink_type& x);

    void
    relationLink (const relationLink_optional& x);

    void
    relationLink (::std::auto_ptr< relationLink_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // runningOrderNumber
    // 
    typedef ::xml_schema::integer runningOrderNumber_type;
    typedef ::xsd::cxx::tree::optional< runningOrderNumber_type > runningOrderNumber_optional;
    typedef ::xsd::cxx::tree::traits< runningOrderNumber_type, char > runningOrderNumber_traits;

    const runningOrderNumber_optional&
    runningOrderNumber () const;

    runningOrderNumber_optional&
    runningOrderNumber ();

    void
    runningOrderNumber (const runningOrderNumber_type& x);

    void
    runningOrderNumber (const runningOrderNumber_optional& x);

    // totalNumberOfGroupMembers
    // 
    typedef ::xml_schema::integer totalNumberOfGroupMembers_type;
    typedef ::xsd::cxx::tree::optional< totalNumberOfGroupMembers_type > totalNumberOfGroupMembers_optional;
    typedef ::xsd::cxx::tree::traits< totalNumberOfGroupMembers_type, char > totalNumberOfGroupMembers_traits;

    const totalNumberOfGroupMembers_optional&
    totalNumberOfGroupMembers () const;

    totalNumberOfGroupMembers_optional&
    totalNumberOfGroupMembers ();

    void
    totalNumberOfGroupMembers (const totalNumberOfGroupMembers_type& x);

    void
    totalNumberOfGroupMembers (const totalNumberOfGroupMembers_optional& x);

    // orderedGroupFlag
    // 
    typedef ::xml_schema::boolean orderedGroupFlag_type;
    typedef ::xsd::cxx::tree::optional< orderedGroupFlag_type > orderedGroupFlag_optional;
    typedef ::xsd::cxx::tree::traits< orderedGroupFlag_type, char > orderedGroupFlag_traits;

    const orderedGroupFlag_optional&
    orderedGroupFlag () const;

    orderedGroupFlag_optional&
    orderedGroupFlag ();

    void
    orderedGroupFlag (const orderedGroupFlag_type& x);

    void
    orderedGroupFlag (const orderedGroupFlag_optional& x);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    relationType ();

    relationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    relationType (const relationType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual relationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~relationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    relation_optional relation_;
    relationIdentifier_optional relationIdentifier_;
    relationLink_optional relationLink_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    runningOrderNumber_optional runningOrderNumber_;
    totalNumberOfGroupMembers_optional totalNumberOfGroupMembers_;
    orderedGroupFlag_optional orderedGroupFlag_;
    note_optional note_;
  };

  class languageType: public ::xml_schema::type
  {
    public:
    // language
    // 
    typedef ::dc::elementType language_type;
    typedef ::xsd::cxx::tree::optional< language_type > language_optional;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_optional&
    language () const;

    language_optional&
    language ();

    void
    language (const language_type& x);

    void
    language (const language_optional& x);

    void
    language (::std::auto_ptr< language_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // Constructors.
    //
    languageType ();

    languageType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    languageType (const languageType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual languageType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~languageType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    language_optional language_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    note_optional note_;
  };

  class dateType: public ::xml_schema::type
  {
    public:
    // date
    // 
    typedef ::dc::elementType date_type;
    typedef ::xsd::cxx::tree::sequence< date_type > date_sequence;
    typedef date_sequence::iterator date_iterator;
    typedef date_sequence::const_iterator date_const_iterator;
    typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

    const date_sequence&
    date () const;

    date_sequence&
    date ();

    void
    date (const date_sequence& s);

    // created
    // 
    typedef ::ebuCore_2012::created created_type;
    typedef ::xsd::cxx::tree::optional< created_type > created_optional;
    typedef ::xsd::cxx::tree::traits< created_type, char > created_traits;

    const created_optional&
    created () const;

    created_optional&
    created ();

    void
    created (const created_type& x);

    void
    created (const created_optional& x);

    void
    created (::std::auto_ptr< created_type > p);

    // issued
    // 
    typedef ::ebuCore_2012::issued issued_type;
    typedef ::xsd::cxx::tree::optional< issued_type > issued_optional;
    typedef ::xsd::cxx::tree::traits< issued_type, char > issued_traits;

    const issued_optional&
    issued () const;

    issued_optional&
    issued ();

    void
    issued (const issued_type& x);

    void
    issued (const issued_optional& x);

    void
    issued (::std::auto_ptr< issued_type > p);

    // modified
    // 
    typedef ::ebuCore_2012::modified modified_type;
    typedef ::xsd::cxx::tree::optional< modified_type > modified_optional;
    typedef ::xsd::cxx::tree::traits< modified_type, char > modified_traits;

    const modified_optional&
    modified () const;

    modified_optional&
    modified ();

    void
    modified (const modified_type& x);

    void
    modified (const modified_optional& x);

    void
    modified (::std::auto_ptr< modified_type > p);

    // digitised
    // 
    typedef ::ebuCore_2012::digitised digitised_type;
    typedef ::xsd::cxx::tree::optional< digitised_type > digitised_optional;
    typedef ::xsd::cxx::tree::traits< digitised_type, char > digitised_traits;

    const digitised_optional&
    digitised () const;

    digitised_optional&
    digitised ();

    void
    digitised (const digitised_type& x);

    void
    digitised (const digitised_optional& x);

    void
    digitised (::std::auto_ptr< digitised_type > p);

    // released
    // 
    typedef ::ebuCore_2012::released released_type;
    typedef ::xsd::cxx::tree::optional< released_type > released_optional;
    typedef ::xsd::cxx::tree::traits< released_type, char > released_traits;

    const released_optional&
    released () const;

    released_optional&
    released ();

    void
    released (const released_type& x);

    void
    released (const released_optional& x);

    void
    released (::std::auto_ptr< released_type > p);

    // copyrighted
    // 
    typedef ::ebuCore_2012::copyrighted copyrighted_type;
    typedef ::xsd::cxx::tree::optional< copyrighted_type > copyrighted_optional;
    typedef ::xsd::cxx::tree::traits< copyrighted_type, char > copyrighted_traits;

    const copyrighted_optional&
    copyrighted () const;

    copyrighted_optional&
    copyrighted ();

    void
    copyrighted (const copyrighted_type& x);

    void
    copyrighted (const copyrighted_optional& x);

    void
    copyrighted (::std::auto_ptr< copyrighted_type > p);

    // alternative
    // 
    typedef ::ebuCore_2012::alternative alternative_type;
    typedef ::xsd::cxx::tree::sequence< alternative_type > alternative_sequence;
    typedef alternative_sequence::iterator alternative_iterator;
    typedef alternative_sequence::const_iterator alternative_const_iterator;
    typedef ::xsd::cxx::tree::traits< alternative_type, char > alternative_traits;

    const alternative_sequence&
    alternative () const;

    alternative_sequence&
    alternative ();

    void
    alternative (const alternative_sequence& s);

    // Constructors.
    //
    dateType ();

    dateType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    dateType (const dateType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual dateType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~dateType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    date_sequence date_;
    created_optional created_;
    issued_optional issued_;
    modified_optional modified_;
    digitised_optional digitised_;
    released_optional released_;
    copyrighted_optional copyrighted_;
    alternative_sequence alternative_;
  };

  class publicationHistoryType: public ::xml_schema::type
  {
    public:
    // publicationEvent
    // 
    typedef ::ebuCore_2012::publicationEventType publicationEvent_type;
    typedef ::xsd::cxx::tree::sequence< publicationEvent_type > publicationEvent_sequence;
    typedef publicationEvent_sequence::iterator publicationEvent_iterator;
    typedef publicationEvent_sequence::const_iterator publicationEvent_const_iterator;
    typedef ::xsd::cxx::tree::traits< publicationEvent_type, char > publicationEvent_traits;

    const publicationEvent_sequence&
    publicationEvent () const;

    publicationEvent_sequence&
    publicationEvent ();

    void
    publicationEvent (const publicationEvent_sequence& s);

    // Constructors.
    //
    publicationHistoryType ();

    publicationHistoryType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    publicationHistoryType (const publicationHistoryType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual publicationHistoryType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~publicationHistoryType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    publicationEvent_sequence publicationEvent_;
  };

  class publicationEventType: public ::xml_schema::type
  {
    public:
    // publicationDate
    // 
    typedef ::xml_schema::date publicationDate_type;
    typedef ::xsd::cxx::tree::optional< publicationDate_type > publicationDate_optional;
    typedef ::xsd::cxx::tree::traits< publicationDate_type, char > publicationDate_traits;

    const publicationDate_optional&
    publicationDate () const;

    publicationDate_optional&
    publicationDate ();

    void
    publicationDate (const publicationDate_type& x);

    void
    publicationDate (const publicationDate_optional& x);

    void
    publicationDate (::std::auto_ptr< publicationDate_type > p);

    // publicationTime
    // 
    typedef ::xml_schema::time publicationTime_type;
    typedef ::xsd::cxx::tree::optional< publicationTime_type > publicationTime_optional;
    typedef ::xsd::cxx::tree::traits< publicationTime_type, char > publicationTime_traits;

    const publicationTime_optional&
    publicationTime () const;

    publicationTime_optional&
    publicationTime ();

    void
    publicationTime (const publicationTime_type& x);

    void
    publicationTime (const publicationTime_optional& x);

    void
    publicationTime (::std::auto_ptr< publicationTime_type > p);

    // publicationService
    // 
    typedef ::ebuCore_2012::publicationServiceType publicationService_type;
    typedef ::xsd::cxx::tree::optional< publicationService_type > publicationService_optional;
    typedef ::xsd::cxx::tree::traits< publicationService_type, char > publicationService_traits;

    const publicationService_optional&
    publicationService () const;

    publicationService_optional&
    publicationService ();

    void
    publicationService (const publicationService_type& x);

    void
    publicationService (const publicationService_optional& x);

    void
    publicationService (::std::auto_ptr< publicationService_type > p);

    // publicationMedium
    // 
    typedef ::ebuCore_2012::publicationMediumType publicationMedium_type;
    typedef ::xsd::cxx::tree::optional< publicationMedium_type > publicationMedium_optional;
    typedef ::xsd::cxx::tree::traits< publicationMedium_type, char > publicationMedium_traits;

    const publicationMedium_optional&
    publicationMedium () const;

    publicationMedium_optional&
    publicationMedium ();

    void
    publicationMedium (const publicationMedium_type& x);

    void
    publicationMedium (const publicationMedium_optional& x);

    void
    publicationMedium (::std::auto_ptr< publicationMedium_type > p);

    // publicationChannel
    // 
    typedef ::ebuCore_2012::publicationChannelType publicationChannel_type;
    typedef ::xsd::cxx::tree::optional< publicationChannel_type > publicationChannel_optional;
    typedef ::xsd::cxx::tree::traits< publicationChannel_type, char > publicationChannel_traits;

    const publicationChannel_optional&
    publicationChannel () const;

    publicationChannel_optional&
    publicationChannel ();

    void
    publicationChannel (const publicationChannel_type& x);

    void
    publicationChannel (const publicationChannel_optional& x);

    void
    publicationChannel (::std::auto_ptr< publicationChannel_type > p);

    // publicationRegion
    // 
    typedef ::ebuCore_2012::regionType publicationRegion_type;
    typedef ::xsd::cxx::tree::sequence< publicationRegion_type > publicationRegion_sequence;
    typedef publicationRegion_sequence::iterator publicationRegion_iterator;
    typedef publicationRegion_sequence::const_iterator publicationRegion_const_iterator;
    typedef ::xsd::cxx::tree::traits< publicationRegion_type, char > publicationRegion_traits;

    const publicationRegion_sequence&
    publicationRegion () const;

    publicationRegion_sequence&
    publicationRegion ();

    void
    publicationRegion (const publicationRegion_sequence& s);

    // publicationEventId
    // 
    typedef ::xml_schema::uri publicationEventId_type;
    typedef ::xsd::cxx::tree::optional< publicationEventId_type > publicationEventId_optional;
    typedef ::xsd::cxx::tree::traits< publicationEventId_type, char > publicationEventId_traits;

    const publicationEventId_optional&
    publicationEventId () const;

    publicationEventId_optional&
    publicationEventId ();

    void
    publicationEventId (const publicationEventId_type& x);

    void
    publicationEventId (const publicationEventId_optional& x);

    void
    publicationEventId (::std::auto_ptr< publicationEventId_type > p);

    // publicationEventName
    // 
    typedef ::xml_schema::string publicationEventName_type;
    typedef ::xsd::cxx::tree::optional< publicationEventName_type > publicationEventName_optional;
    typedef ::xsd::cxx::tree::traits< publicationEventName_type, char > publicationEventName_traits;

    const publicationEventName_optional&
    publicationEventName () const;

    publicationEventName_optional&
    publicationEventName ();

    void
    publicationEventName (const publicationEventName_type& x);

    void
    publicationEventName (const publicationEventName_optional& x);

    void
    publicationEventName (::std::auto_ptr< publicationEventName_type > p);

    // firstShowing
    // 
    typedef ::xml_schema::boolean firstShowing_type;
    typedef ::xsd::cxx::tree::optional< firstShowing_type > firstShowing_optional;
    typedef ::xsd::cxx::tree::traits< firstShowing_type, char > firstShowing_traits;

    const firstShowing_optional&
    firstShowing () const;

    firstShowing_optional&
    firstShowing ();

    void
    firstShowing (const firstShowing_type& x);

    void
    firstShowing (const firstShowing_optional& x);

    // live
    // 
    typedef ::xml_schema::boolean live_type;
    typedef ::xsd::cxx::tree::optional< live_type > live_optional;
    typedef ::xsd::cxx::tree::traits< live_type, char > live_traits;

    const live_optional&
    live () const;

    live_optional&
    live ();

    void
    live (const live_type& x);

    void
    live (const live_optional& x);

    // free
    // 
    typedef ::xml_schema::boolean free_type;
    typedef ::xsd::cxx::tree::optional< free_type > free_optional;
    typedef ::xsd::cxx::tree::traits< free_type, char > free_traits;

    const free_optional&
    free () const;

    free_optional&
    free ();

    void
    free (const free_type& x);

    void
    free (const free_optional& x);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // formatIdRef
    // 
    typedef ::xml_schema::idref formatIdRef_type;
    typedef ::xsd::cxx::tree::optional< formatIdRef_type > formatIdRef_optional;
    typedef ::xsd::cxx::tree::traits< formatIdRef_type, char > formatIdRef_traits;

    const formatIdRef_optional&
    formatIdRef () const;

    formatIdRef_optional&
    formatIdRef ();

    void
    formatIdRef (const formatIdRef_type& x);

    void
    formatIdRef (const formatIdRef_optional& x);

    void
    formatIdRef (::std::auto_ptr< formatIdRef_type > p);

    // rightsIDRefs
    // 
    typedef ::xml_schema::idrefs rightsIDRefs_type;
    typedef ::xsd::cxx::tree::optional< rightsIDRefs_type > rightsIDRefs_optional;
    typedef ::xsd::cxx::tree::traits< rightsIDRefs_type, char > rightsIDRefs_traits;

    const rightsIDRefs_optional&
    rightsIDRefs () const;

    rightsIDRefs_optional&
    rightsIDRefs ();

    void
    rightsIDRefs (const rightsIDRefs_type& x);

    void
    rightsIDRefs (const rightsIDRefs_optional& x);

    void
    rightsIDRefs (::std::auto_ptr< rightsIDRefs_type > p);

    // Constructors.
    //
    publicationEventType ();

    publicationEventType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    publicationEventType (const publicationEventType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual publicationEventType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~publicationEventType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    publicationDate_optional publicationDate_;
    publicationTime_optional publicationTime_;
    publicationService_optional publicationService_;
    publicationMedium_optional publicationMedium_;
    publicationChannel_optional publicationChannel_;
    publicationRegion_sequence publicationRegion_;
    publicationEventId_optional publicationEventId_;
    publicationEventName_optional publicationEventName_;
    firstShowing_optional firstShowing_;
    live_optional live_;
    free_optional free_;
    note_optional note_;
    formatIdRef_optional formatIdRef_;
    rightsIDRefs_optional rightsIDRefs_;
  };

  class publicationServiceType: public ::xml_schema::type
  {
    public:
    // publicationServiceName
    // 
    typedef ::xml_schema::string publicationServiceName_type;
    typedef ::xsd::cxx::tree::optional< publicationServiceName_type > publicationServiceName_optional;
    typedef ::xsd::cxx::tree::traits< publicationServiceName_type, char > publicationServiceName_traits;

    const publicationServiceName_optional&
    publicationServiceName () const;

    publicationServiceName_optional&
    publicationServiceName ();

    void
    publicationServiceName (const publicationServiceName_type& x);

    void
    publicationServiceName (const publicationServiceName_optional& x);

    void
    publicationServiceName (::std::auto_ptr< publicationServiceName_type > p);

    // publicationSource
    // 
    typedef ::ebuCore_2012::organisationDetailsType publicationSource_type;
    typedef ::xsd::cxx::tree::optional< publicationSource_type > publicationSource_optional;
    typedef ::xsd::cxx::tree::traits< publicationSource_type, char > publicationSource_traits;

    const publicationSource_optional&
    publicationSource () const;

    publicationSource_optional&
    publicationSource ();

    void
    publicationSource (const publicationSource_type& x);

    void
    publicationSource (const publicationSource_optional& x);

    void
    publicationSource (::std::auto_ptr< publicationSource_type > p);

    // linkToLogo
    // 
    typedef ::xml_schema::uri linkToLogo_type;
    typedef ::xsd::cxx::tree::optional< linkToLogo_type > linkToLogo_optional;
    typedef ::xsd::cxx::tree::traits< linkToLogo_type, char > linkToLogo_traits;

    const linkToLogo_optional&
    linkToLogo () const;

    linkToLogo_optional&
    linkToLogo ();

    void
    linkToLogo (const linkToLogo_type& x);

    void
    linkToLogo (const linkToLogo_optional& x);

    void
    linkToLogo (::std::auto_ptr< linkToLogo_type > p);

    // Constructors.
    //
    publicationServiceType ();

    publicationServiceType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    publicationServiceType (const publicationServiceType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual publicationServiceType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~publicationServiceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    publicationServiceName_optional publicationServiceName_;
    publicationSource_optional publicationSource_;
    linkToLogo_optional linkToLogo_;
  };

  class publicationMediumType: public ::xml_schema::string
  {
    public:
    // publicationMediumId
    // 
    typedef ::xml_schema::uri publicationMediumId_type;
    typedef ::xsd::cxx::tree::optional< publicationMediumId_type > publicationMediumId_optional;
    typedef ::xsd::cxx::tree::traits< publicationMediumId_type, char > publicationMediumId_traits;

    const publicationMediumId_optional&
    publicationMediumId () const;

    publicationMediumId_optional&
    publicationMediumId ();

    void
    publicationMediumId (const publicationMediumId_type& x);

    void
    publicationMediumId (const publicationMediumId_optional& x);

    void
    publicationMediumId (::std::auto_ptr< publicationMediumId_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    publicationMediumType ();

    publicationMediumType (const char*);

    publicationMediumType (const ::std::string&);

    publicationMediumType (const ::xml_schema::string&);

    publicationMediumType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    publicationMediumType (const publicationMediumType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual publicationMediumType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~publicationMediumType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    publicationMediumId_optional publicationMediumId_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class publicationChannelType: public ::xml_schema::string
  {
    public:
    // publicationChannelId
    // 
    typedef ::xml_schema::uri publicationChannelId_type;
    typedef ::xsd::cxx::tree::optional< publicationChannelId_type > publicationChannelId_optional;
    typedef ::xsd::cxx::tree::traits< publicationChannelId_type, char > publicationChannelId_traits;

    const publicationChannelId_optional&
    publicationChannelId () const;

    publicationChannelId_optional&
    publicationChannelId ();

    void
    publicationChannelId (const publicationChannelId_type& x);

    void
    publicationChannelId (const publicationChannelId_optional& x);

    void
    publicationChannelId (::std::auto_ptr< publicationChannelId_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // linkToLogo
    // 
    typedef ::xml_schema::uri linkToLogo_type;
    typedef ::xsd::cxx::tree::optional< linkToLogo_type > linkToLogo_optional;
    typedef ::xsd::cxx::tree::traits< linkToLogo_type, char > linkToLogo_traits;

    const linkToLogo_optional&
    linkToLogo () const;

    linkToLogo_optional&
    linkToLogo ();

    void
    linkToLogo (const linkToLogo_type& x);

    void
    linkToLogo (const linkToLogo_optional& x);

    void
    linkToLogo (::std::auto_ptr< linkToLogo_type > p);

    // Constructors.
    //
    publicationChannelType ();

    publicationChannelType (const char*);

    publicationChannelType (const ::std::string&);

    publicationChannelType (const ::xml_schema::string&);

    publicationChannelType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    publicationChannelType (const publicationChannelType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual publicationChannelType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~publicationChannelType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    publicationChannelId_optional publicationChannelId_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    linkToLogo_optional linkToLogo_;
  };

  class formatType: public ::xml_schema::type
  {
    public:
    // format
    // 
    typedef ::dc::elementType format_type;
    typedef ::xsd::cxx::tree::optional< format_type > format_optional;
    typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

    const format_optional&
    format () const;

    format_optional&
    format ();

    void
    format (const format_type& x);

    void
    format (const format_optional& x);

    void
    format (::std::auto_ptr< format_type > p);

    // medium
    // 
    typedef ::ebuCore_2012::medium medium_type;
    typedef ::xsd::cxx::tree::sequence< medium_type > medium_sequence;
    typedef medium_sequence::iterator medium_iterator;
    typedef medium_sequence::const_iterator medium_const_iterator;
    typedef ::xsd::cxx::tree::traits< medium_type, char > medium_traits;

    const medium_sequence&
    medium () const;

    medium_sequence&
    medium ();

    void
    medium (const medium_sequence& s);

    // imageFormat
    // 
    typedef ::ebuCore_2012::imageFormatType imageFormat_type;
    typedef ::xsd::cxx::tree::sequence< imageFormat_type > imageFormat_sequence;
    typedef imageFormat_sequence::iterator imageFormat_iterator;
    typedef imageFormat_sequence::const_iterator imageFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< imageFormat_type, char > imageFormat_traits;

    const imageFormat_sequence&
    imageFormat () const;

    imageFormat_sequence&
    imageFormat ();

    void
    imageFormat (const imageFormat_sequence& s);

    // videoFormat
    // 
    typedef ::ebuCore_2012::videoFormatType videoFormat_type;
    typedef ::xsd::cxx::tree::sequence< videoFormat_type > videoFormat_sequence;
    typedef videoFormat_sequence::iterator videoFormat_iterator;
    typedef videoFormat_sequence::const_iterator videoFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< videoFormat_type, char > videoFormat_traits;

    const videoFormat_sequence&
    videoFormat () const;

    videoFormat_sequence&
    videoFormat ();

    void
    videoFormat (const videoFormat_sequence& s);

    // audioFormat
    // 
    typedef ::ebuCore_2012::audioFormatType audioFormat_type;
    typedef ::xsd::cxx::tree::sequence< audioFormat_type > audioFormat_sequence;
    typedef audioFormat_sequence::iterator audioFormat_iterator;
    typedef audioFormat_sequence::const_iterator audioFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< audioFormat_type, char > audioFormat_traits;

    const audioFormat_sequence&
    audioFormat () const;

    audioFormat_sequence&
    audioFormat ();

    void
    audioFormat (const audioFormat_sequence& s);

    // containerFormat
    // 
    typedef ::ebuCore_2012::containerFormat containerFormat_type;
    typedef ::xsd::cxx::tree::sequence< containerFormat_type > containerFormat_sequence;
    typedef containerFormat_sequence::iterator containerFormat_iterator;
    typedef containerFormat_sequence::const_iterator containerFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< containerFormat_type, char > containerFormat_traits;

    const containerFormat_sequence&
    containerFormat () const;

    containerFormat_sequence&
    containerFormat ();

    void
    containerFormat (const containerFormat_sequence& s);

    // dataFormat
    // 
    typedef ::ebuCore_2012::dataFormatType dataFormat_type;
    typedef ::xsd::cxx::tree::sequence< dataFormat_type > dataFormat_sequence;
    typedef dataFormat_sequence::iterator dataFormat_iterator;
    typedef dataFormat_sequence::const_iterator dataFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< dataFormat_type, char > dataFormat_traits;

    const dataFormat_sequence&
    dataFormat () const;

    dataFormat_sequence&
    dataFormat ();

    void
    dataFormat (const dataFormat_sequence& s);

    // signingFormat
    // 
    typedef ::ebuCore_2012::signingFormat signingFormat_type;
    typedef ::xsd::cxx::tree::sequence< signingFormat_type > signingFormat_sequence;
    typedef signingFormat_sequence::iterator signingFormat_iterator;
    typedef signingFormat_sequence::const_iterator signingFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< signingFormat_type, char > signingFormat_traits;

    const signingFormat_sequence&
    signingFormat () const;

    signingFormat_sequence&
    signingFormat ();

    void
    signingFormat (const signingFormat_sequence& s);

    // start
    // 
    typedef ::ebuCore_2012::timeType start_type;
    typedef ::xsd::cxx::tree::optional< start_type > start_optional;
    typedef ::xsd::cxx::tree::traits< start_type, char > start_traits;

    const start_optional&
    start () const;

    start_optional&
    start ();

    void
    start (const start_type& x);

    void
    start (const start_optional& x);

    void
    start (::std::auto_ptr< start_type > p);

    // end
    // 
    typedef ::ebuCore_2012::timeType end_type;
    typedef ::xsd::cxx::tree::optional< end_type > end_optional;
    typedef ::xsd::cxx::tree::traits< end_type, char > end_traits;

    const end_optional&
    end () const;

    end_optional&
    end ();

    void
    end (const end_type& x);

    void
    end (const end_optional& x);

    void
    end (::std::auto_ptr< end_type > p);

    // duration
    // 
    typedef ::ebuCore_2012::durationType duration_type;
    typedef ::xsd::cxx::tree::optional< duration_type > duration_optional;
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    const duration_optional&
    duration () const;

    duration_optional&
    duration ();

    void
    duration (const duration_type& x);

    void
    duration (const duration_optional& x);

    void
    duration (::std::auto_ptr< duration_type > p);

    // fileSize
    // 
    typedef ::xml_schema::long_ fileSize_type;
    typedef ::xsd::cxx::tree::optional< fileSize_type > fileSize_optional;
    typedef ::xsd::cxx::tree::traits< fileSize_type, char > fileSize_traits;

    const fileSize_optional&
    fileSize () const;

    fileSize_optional&
    fileSize ();

    void
    fileSize (const fileSize_type& x);

    void
    fileSize (const fileSize_optional& x);

    // fileName
    // 
    typedef ::xml_schema::string fileName_type;
    typedef ::xsd::cxx::tree::optional< fileName_type > fileName_optional;
    typedef ::xsd::cxx::tree::traits< fileName_type, char > fileName_traits;

    const fileName_optional&
    fileName () const;

    fileName_optional&
    fileName ();

    void
    fileName (const fileName_type& x);

    void
    fileName (const fileName_optional& x);

    void
    fileName (::std::auto_ptr< fileName_type > p);

    // mimeType
    // 
    typedef ::ebuCore_2012::mimeType mimeType_type;
    typedef ::xsd::cxx::tree::sequence< mimeType_type > mimeType_sequence;
    typedef mimeType_sequence::iterator mimeType_iterator;
    typedef mimeType_sequence::const_iterator mimeType_const_iterator;
    typedef ::xsd::cxx::tree::traits< mimeType_type, char > mimeType_traits;

    const mimeType_sequence&
    mimeType () const;

    mimeType_sequence&
    mimeType ();

    void
    mimeType (const mimeType_sequence& s);

    // locator
    // 
    typedef ::ebuCore_2012::locator locator_type;
    typedef ::xsd::cxx::tree::sequence< locator_type > locator_sequence;
    typedef locator_sequence::iterator locator_iterator;
    typedef locator_sequence::const_iterator locator_const_iterator;
    typedef ::xsd::cxx::tree::traits< locator_type, char > locator_traits;

    const locator_sequence&
    locator () const;

    locator_sequence&
    locator ();

    void
    locator (const locator_sequence& s);

    // hash
    // 
    typedef ::ebuCore_2012::hashType hash_type;
    typedef ::xsd::cxx::tree::optional< hash_type > hash_optional;
    typedef ::xsd::cxx::tree::traits< hash_type, char > hash_traits;

    const hash_optional&
    hash () const;

    hash_optional&
    hash ();

    void
    hash (const hash_type& x);

    void
    hash (const hash_optional& x);

    void
    hash (::std::auto_ptr< hash_type > p);

    // documentFormat
    // 
    typedef ::ebuCore_2012::documentFormatType documentFormat_type;
    typedef ::xsd::cxx::tree::optional< documentFormat_type > documentFormat_optional;
    typedef ::xsd::cxx::tree::traits< documentFormat_type, char > documentFormat_traits;

    const documentFormat_optional&
    documentFormat () const;

    documentFormat_optional&
    documentFormat ();

    void
    documentFormat (const documentFormat_type& x);

    void
    documentFormat (const documentFormat_optional& x);

    void
    documentFormat (::std::auto_ptr< documentFormat_type > p);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2012::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2012::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2012::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2012::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2012::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2012::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2012::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2012::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2012::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2012::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2012::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2012::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2012::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // dateCreated
    // 
    typedef ::ebuCore_2012::dateCreated dateCreated_type;
    typedef ::xsd::cxx::tree::optional< dateCreated_type > dateCreated_optional;
    typedef ::xsd::cxx::tree::traits< dateCreated_type, char > dateCreated_traits;

    const dateCreated_optional&
    dateCreated () const;

    dateCreated_optional&
    dateCreated ();

    void
    dateCreated (const dateCreated_type& x);

    void
    dateCreated (const dateCreated_optional& x);

    void
    dateCreated (::std::auto_ptr< dateCreated_type > p);

    // dateModified
    // 
    typedef ::ebuCore_2012::dateModified dateModified_type;
    typedef ::xsd::cxx::tree::optional< dateModified_type > dateModified_optional;
    typedef ::xsd::cxx::tree::traits< dateModified_type, char > dateModified_traits;

    const dateModified_optional&
    dateModified () const;

    dateModified_optional&
    dateModified ();

    void
    dateModified (const dateModified_type& x);

    void
    dateModified (const dateModified_optional& x);

    void
    dateModified (::std::auto_ptr< dateModified_type > p);

    // formatId
    // 
    typedef ::xml_schema::id formatId_type;
    typedef ::xsd::cxx::tree::optional< formatId_type > formatId_optional;
    typedef ::xsd::cxx::tree::traits< formatId_type, char > formatId_traits;

    const formatId_optional&
    formatId () const;

    formatId_optional&
    formatId ();

    void
    formatId (const formatId_type& x);

    void
    formatId (const formatId_optional& x);

    void
    formatId (::std::auto_ptr< formatId_type > p);

    // formatVersionId
    // 
    typedef ::xml_schema::string formatVersionId_type;
    typedef ::xsd::cxx::tree::optional< formatVersionId_type > formatVersionId_optional;
    typedef ::xsd::cxx::tree::traits< formatVersionId_type, char > formatVersionId_traits;

    const formatVersionId_optional&
    formatVersionId () const;

    formatVersionId_optional&
    formatVersionId ();

    void
    formatVersionId (const formatVersionId_type& x);

    void
    formatVersionId (const formatVersionId_optional& x);

    void
    formatVersionId (::std::auto_ptr< formatVersionId_type > p);

    // formatName
    // 
    typedef ::xml_schema::string formatName_type;
    typedef ::xsd::cxx::tree::optional< formatName_type > formatName_optional;
    typedef ::xsd::cxx::tree::traits< formatName_type, char > formatName_traits;

    const formatName_optional&
    formatName () const;

    formatName_optional&
    formatName ();

    void
    formatName (const formatName_type& x);

    void
    formatName (const formatName_optional& x);

    void
    formatName (::std::auto_ptr< formatName_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // Constructors.
    //
    formatType ();

    formatType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    formatType (const formatType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual formatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~formatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    format_optional format_;
    medium_sequence medium_;
    imageFormat_sequence imageFormat_;
    videoFormat_sequence videoFormat_;
    audioFormat_sequence audioFormat_;
    containerFormat_sequence containerFormat_;
    dataFormat_sequence dataFormat_;
    signingFormat_sequence signingFormat_;
    start_optional start_;
    end_optional end_;
    duration_optional duration_;
    fileSize_optional fileSize_;
    fileName_optional fileName_;
    mimeType_sequence mimeType_;
    locator_sequence locator_;
    hash_optional hash_;
    documentFormat_optional documentFormat_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    dateCreated_optional dateCreated_;
    dateModified_optional dateModified_;
    formatId_optional formatId_;
    formatVersionId_optional formatVersionId_;
    formatName_optional formatName_;
    formatDefinition_optional formatDefinition_;
  };

  class entityType: public ::xml_schema::type
  {
    public:
    // contactDetails
    // 
    typedef ::ebuCore_2012::contactDetailsType contactDetails_type;
    typedef ::xsd::cxx::tree::sequence< contactDetails_type > contactDetails_sequence;
    typedef contactDetails_sequence::iterator contactDetails_iterator;
    typedef contactDetails_sequence::const_iterator contactDetails_const_iterator;
    typedef ::xsd::cxx::tree::traits< contactDetails_type, char > contactDetails_traits;

    const contactDetails_sequence&
    contactDetails () const;

    contactDetails_sequence&
    contactDetails ();

    void
    contactDetails (const contactDetails_sequence& s);

    // organisationDetails
    // 
    typedef ::ebuCore_2012::organisationDetailsType organisationDetails_type;
    typedef ::xsd::cxx::tree::sequence< organisationDetails_type > organisationDetails_sequence;
    typedef organisationDetails_sequence::iterator organisationDetails_iterator;
    typedef organisationDetails_sequence::const_iterator organisationDetails_const_iterator;
    typedef ::xsd::cxx::tree::traits< organisationDetails_type, char > organisationDetails_traits;

    const organisationDetails_sequence&
    organisationDetails () const;

    organisationDetails_sequence&
    organisationDetails ();

    void
    organisationDetails (const organisationDetails_sequence& s);

    // role
    // 
    typedef ::ebuCore_2012::role role_type;
    typedef ::xsd::cxx::tree::sequence< role_type > role_sequence;
    typedef role_sequence::iterator role_iterator;
    typedef role_sequence::const_iterator role_const_iterator;
    typedef ::xsd::cxx::tree::traits< role_type, char > role_traits;

    const role_sequence&
    role () const;

    role_sequence&
    role ();

    void
    role (const role_sequence& s);

    // entityId
    // 
    typedef ::xml_schema::uri entityId_type;
    typedef ::xsd::cxx::tree::optional< entityId_type > entityId_optional;
    typedef ::xsd::cxx::tree::traits< entityId_type, char > entityId_traits;

    const entityId_optional&
    entityId () const;

    entityId_optional&
    entityId ();

    void
    entityId (const entityId_type& x);

    void
    entityId (const entityId_optional& x);

    void
    entityId (::std::auto_ptr< entityId_type > p);

    // Constructors.
    //
    entityType ();

    entityType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    entityType (const entityType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual entityType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~entityType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    contactDetails_sequence contactDetails_;
    organisationDetails_sequence organisationDetails_;
    role_sequence role_;
    entityId_optional entityId_;
  };

  class contactDetailsType: public ::xml_schema::type
  {
    public:
    // name
    // 
    typedef ::ebuCore_2012::compoundNameType name_type;
    typedef ::xsd::cxx::tree::sequence< name_type > name_sequence;
    typedef name_sequence::iterator name_iterator;
    typedef name_sequence::const_iterator name_const_iterator;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_sequence&
    name () const;

    name_sequence&
    name ();

    void
    name (const name_sequence& s);

    // givenName
    // 
    typedef ::xml_schema::string givenName_type;
    typedef ::xsd::cxx::tree::optional< givenName_type > givenName_optional;
    typedef ::xsd::cxx::tree::traits< givenName_type, char > givenName_traits;

    const givenName_optional&
    givenName () const;

    givenName_optional&
    givenName ();

    void
    givenName (const givenName_type& x);

    void
    givenName (const givenName_optional& x);

    void
    givenName (::std::auto_ptr< givenName_type > p);

    // familyName
    // 
    typedef ::xml_schema::string familyName_type;
    typedef ::xsd::cxx::tree::optional< familyName_type > familyName_optional;
    typedef ::xsd::cxx::tree::traits< familyName_type, char > familyName_traits;

    const familyName_optional&
    familyName () const;

    familyName_optional&
    familyName ();

    void
    familyName (const familyName_type& x);

    void
    familyName (const familyName_optional& x);

    void
    familyName (::std::auto_ptr< familyName_type > p);

    // otherGivenName
    // 
    typedef ::xml_schema::string otherGivenName_type;
    typedef ::xsd::cxx::tree::sequence< otherGivenName_type > otherGivenName_sequence;
    typedef otherGivenName_sequence::iterator otherGivenName_iterator;
    typedef otherGivenName_sequence::const_iterator otherGivenName_const_iterator;
    typedef ::xsd::cxx::tree::traits< otherGivenName_type, char > otherGivenName_traits;

    const otherGivenName_sequence&
    otherGivenName () const;

    otherGivenName_sequence&
    otherGivenName ();

    void
    otherGivenName (const otherGivenName_sequence& s);

    // suffix
    // 
    typedef ::xml_schema::string suffix_type;
    typedef ::xsd::cxx::tree::optional< suffix_type > suffix_optional;
    typedef ::xsd::cxx::tree::traits< suffix_type, char > suffix_traits;

    const suffix_optional&
    suffix () const;

    suffix_optional&
    suffix ();

    void
    suffix (const suffix_type& x);

    void
    suffix (const suffix_optional& x);

    void
    suffix (::std::auto_ptr< suffix_type > p);

    // salutation
    // 
    typedef ::xml_schema::string salutation_type;
    typedef ::xsd::cxx::tree::optional< salutation_type > salutation_optional;
    typedef ::xsd::cxx::tree::traits< salutation_type, char > salutation_traits;

    const salutation_optional&
    salutation () const;

    salutation_optional&
    salutation ();

    void
    salutation (const salutation_type& x);

    void
    salutation (const salutation_optional& x);

    void
    salutation (::std::auto_ptr< salutation_type > p);

    // username
    // 
    typedef ::dc::elementType username_type;
    typedef ::xsd::cxx::tree::sequence< username_type > username_sequence;
    typedef username_sequence::iterator username_iterator;
    typedef username_sequence::const_iterator username_const_iterator;
    typedef ::xsd::cxx::tree::traits< username_type, char > username_traits;

    const username_sequence&
    username () const;

    username_sequence&
    username ();

    void
    username (const username_sequence& s);

    // occupation
    // 
    typedef ::dc::elementType occupation_type;
    typedef ::xsd::cxx::tree::optional< occupation_type > occupation_optional;
    typedef ::xsd::cxx::tree::traits< occupation_type, char > occupation_traits;

    const occupation_optional&
    occupation () const;

    occupation_optional&
    occupation ();

    void
    occupation (const occupation_type& x);

    void
    occupation (const occupation_optional& x);

    void
    occupation (::std::auto_ptr< occupation_type > p);

    // details
    // 
    typedef ::ebuCore_2012::detailsType details_type;
    typedef ::xsd::cxx::tree::sequence< details_type > details_sequence;
    typedef details_sequence::iterator details_iterator;
    typedef details_sequence::const_iterator details_const_iterator;
    typedef ::xsd::cxx::tree::traits< details_type, char > details_traits;

    const details_sequence&
    details () const;

    details_sequence&
    details ();

    void
    details (const details_sequence& s);

    // stageName
    // 
    typedef ::dc::elementType stageName_type;
    typedef ::xsd::cxx::tree::sequence< stageName_type > stageName_sequence;
    typedef stageName_sequence::iterator stageName_iterator;
    typedef stageName_sequence::const_iterator stageName_const_iterator;
    typedef ::xsd::cxx::tree::traits< stageName_type, char > stageName_traits;

    const stageName_sequence&
    stageName () const;

    stageName_sequence&
    stageName ();

    void
    stageName (const stageName_sequence& s);

    // guest
    // 
    typedef ::xml_schema::boolean guest_type;
    typedef ::xsd::cxx::tree::optional< guest_type > guest_optional;
    typedef ::xsd::cxx::tree::traits< guest_type, char > guest_traits;

    const guest_optional&
    guest () const;

    guest_optional&
    guest ();

    void
    guest (const guest_type& x);

    void
    guest (const guest_optional& x);

    // gender
    // 
    typedef ::dc::elementType gender_type;
    typedef ::xsd::cxx::tree::optional< gender_type > gender_optional;
    typedef ::xsd::cxx::tree::traits< gender_type, char > gender_traits;

    const gender_optional&
    gender () const;

    gender_optional&
    gender ();

    void
    gender (const gender_type& x);

    void
    gender (const gender_optional& x);

    void
    gender (::std::auto_ptr< gender_type > p);

    // relatedInformationLink
    // 
    typedef ::ebuCore_2012::relatedInformationLink relatedInformationLink_type;
    typedef ::xsd::cxx::tree::sequence< relatedInformationLink_type > relatedInformationLink_sequence;
    typedef relatedInformationLink_sequence::iterator relatedInformationLink_iterator;
    typedef relatedInformationLink_sequence::const_iterator relatedInformationLink_const_iterator;
    typedef ::xsd::cxx::tree::traits< relatedInformationLink_type, char > relatedInformationLink_traits;

    const relatedInformationLink_sequence&
    relatedInformationLink () const;

    relatedInformationLink_sequence&
    relatedInformationLink ();

    void
    relatedInformationLink (const relatedInformationLink_sequence& s);

    // relatedContacts
    // 
    typedef ::ebuCore_2012::entityType relatedContacts_type;
    typedef ::xsd::cxx::tree::sequence< relatedContacts_type > relatedContacts_sequence;
    typedef relatedContacts_sequence::iterator relatedContacts_iterator;
    typedef relatedContacts_sequence::const_iterator relatedContacts_const_iterator;
    typedef ::xsd::cxx::tree::traits< relatedContacts_type, char > relatedContacts_traits;

    const relatedContacts_sequence&
    relatedContacts () const;

    relatedContacts_sequence&
    relatedContacts ();

    void
    relatedContacts (const relatedContacts_sequence& s);

    // contactId
    // 
    typedef ::xml_schema::uri contactId_type;
    typedef ::xsd::cxx::tree::optional< contactId_type > contactId_optional;
    typedef ::xsd::cxx::tree::traits< contactId_type, char > contactId_traits;

    const contactId_optional&
    contactId () const;

    contactId_optional&
    contactId ();

    void
    contactId (const contactId_type& x);

    void
    contactId (const contactId_optional& x);

    void
    contactId (::std::auto_ptr< contactId_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    contactDetailsType ();

    contactDetailsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    contactDetailsType (const contactDetailsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual contactDetailsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~contactDetailsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    name_sequence name_;
    givenName_optional givenName_;
    familyName_optional familyName_;
    otherGivenName_sequence otherGivenName_;
    suffix_optional suffix_;
    salutation_optional salutation_;
    username_sequence username_;
    occupation_optional occupation_;
    details_sequence details_;
    stageName_sequence stageName_;
    guest_optional guest_;
    gender_optional gender_;
    relatedInformationLink_sequence relatedInformationLink_;
    relatedContacts_sequence relatedContacts_;
    contactId_optional contactId_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class organisationDetailsType: public ::xml_schema::type
  {
    public:
    // organisationName
    // 
    typedef ::ebuCore_2012::compoundNameType organisationName_type;
    typedef ::xsd::cxx::tree::sequence< organisationName_type > organisationName_sequence;
    typedef organisationName_sequence::iterator organisationName_iterator;
    typedef organisationName_sequence::const_iterator organisationName_const_iterator;
    typedef ::xsd::cxx::tree::traits< organisationName_type, char > organisationName_traits;

    const organisationName_sequence&
    organisationName () const;

    organisationName_sequence&
    organisationName ();

    void
    organisationName (const organisationName_sequence& s);

    // organisationCode
    // 
    typedef ::ebuCore_2012::identifierType organisationCode_type;
    typedef ::xsd::cxx::tree::sequence< organisationCode_type > organisationCode_sequence;
    typedef organisationCode_sequence::iterator organisationCode_iterator;
    typedef organisationCode_sequence::const_iterator organisationCode_const_iterator;
    typedef ::xsd::cxx::tree::traits< organisationCode_type, char > organisationCode_traits;

    const organisationCode_sequence&
    organisationCode () const;

    organisationCode_sequence&
    organisationCode ();

    void
    organisationCode (const organisationCode_sequence& s);

    // organisationDepartment
    // 
    typedef ::ebuCore_2012::organisationDepartment organisationDepartment_type;
    typedef ::xsd::cxx::tree::optional< organisationDepartment_type > organisationDepartment_optional;
    typedef ::xsd::cxx::tree::traits< organisationDepartment_type, char > organisationDepartment_traits;

    const organisationDepartment_optional&
    organisationDepartment () const;

    organisationDepartment_optional&
    organisationDepartment ();

    void
    organisationDepartment (const organisationDepartment_type& x);

    void
    organisationDepartment (const organisationDepartment_optional& x);

    void
    organisationDepartment (::std::auto_ptr< organisationDepartment_type > p);

    // details
    // 
    typedef ::ebuCore_2012::detailsType details_type;
    typedef ::xsd::cxx::tree::sequence< details_type > details_sequence;
    typedef details_sequence::iterator details_iterator;
    typedef details_sequence::const_iterator details_const_iterator;
    typedef ::xsd::cxx::tree::traits< details_type, char > details_traits;

    const details_sequence&
    details () const;

    details_sequence&
    details ();

    void
    details (const details_sequence& s);

    // relatedInformationLink
    // 
    typedef ::ebuCore_2012::relatedInformationLink1 relatedInformationLink_type;
    typedef ::xsd::cxx::tree::sequence< relatedInformationLink_type > relatedInformationLink_sequence;
    typedef relatedInformationLink_sequence::iterator relatedInformationLink_iterator;
    typedef relatedInformationLink_sequence::const_iterator relatedInformationLink_const_iterator;
    typedef ::xsd::cxx::tree::traits< relatedInformationLink_type, char > relatedInformationLink_traits;

    const relatedInformationLink_sequence&
    relatedInformationLink () const;

    relatedInformationLink_sequence&
    relatedInformationLink ();

    void
    relatedInformationLink (const relatedInformationLink_sequence& s);

    // contacts
    // 
    typedef ::ebuCore_2012::entityType contacts_type;
    typedef ::xsd::cxx::tree::sequence< contacts_type > contacts_sequence;
    typedef contacts_sequence::iterator contacts_iterator;
    typedef contacts_sequence::const_iterator contacts_const_iterator;
    typedef ::xsd::cxx::tree::traits< contacts_type, char > contacts_traits;

    const contacts_sequence&
    contacts () const;

    contacts_sequence&
    contacts ();

    void
    contacts (const contacts_sequence& s);

    // organisationId
    // 
    typedef ::xml_schema::uri organisationId_type;
    typedef ::xsd::cxx::tree::optional< organisationId_type > organisationId_optional;
    typedef ::xsd::cxx::tree::traits< organisationId_type, char > organisationId_traits;

    const organisationId_optional&
    organisationId () const;

    organisationId_optional&
    organisationId ();

    void
    organisationId (const organisationId_type& x);

    void
    organisationId (const organisationId_optional& x);

    void
    organisationId (::std::auto_ptr< organisationId_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // linkToLogo
    // 
    typedef ::xml_schema::uri linkToLogo_type;
    typedef ::xsd::cxx::tree::optional< linkToLogo_type > linkToLogo_optional;
    typedef ::xsd::cxx::tree::traits< linkToLogo_type, char > linkToLogo_traits;

    const linkToLogo_optional&
    linkToLogo () const;

    linkToLogo_optional&
    linkToLogo ();

    void
    linkToLogo (const linkToLogo_type& x);

    void
    linkToLogo (const linkToLogo_optional& x);

    void
    linkToLogo (::std::auto_ptr< linkToLogo_type > p);

    // Constructors.
    //
    organisationDetailsType ();

    organisationDetailsType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    organisationDetailsType (const organisationDetailsType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual organisationDetailsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~organisationDetailsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    organisationName_sequence organisationName_;
    organisationCode_sequence organisationCode_;
    organisationDepartment_optional organisationDepartment_;
    details_sequence details_;
    relatedInformationLink_sequence relatedInformationLink_;
    contacts_sequence contacts_;
    organisationId_optional organisationId_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    linkToLogo_optional linkToLogo_;
  };

  class detailsType: public ::xml_schema::type
  {
    public:
    // emailAddress
    // 
    typedef ::xml_schema::string emailAddress_type;
    typedef ::xsd::cxx::tree::sequence< emailAddress_type > emailAddress_sequence;
    typedef emailAddress_sequence::iterator emailAddress_iterator;
    typedef emailAddress_sequence::const_iterator emailAddress_const_iterator;
    typedef ::xsd::cxx::tree::traits< emailAddress_type, char > emailAddress_traits;

    const emailAddress_sequence&
    emailAddress () const;

    emailAddress_sequence&
    emailAddress ();

    void
    emailAddress (const emailAddress_sequence& s);

    // webAddress
    // 
    typedef ::xml_schema::string webAddress_type;
    typedef ::xsd::cxx::tree::optional< webAddress_type > webAddress_optional;
    typedef ::xsd::cxx::tree::traits< webAddress_type, char > webAddress_traits;

    const webAddress_optional&
    webAddress () const;

    webAddress_optional&
    webAddress ();

    void
    webAddress (const webAddress_type& x);

    void
    webAddress (const webAddress_optional& x);

    void
    webAddress (::std::auto_ptr< webAddress_type > p);

    // address
    // 
    typedef ::ebuCore_2012::addressType address_type;
    typedef ::xsd::cxx::tree::optional< address_type > address_optional;
    typedef ::xsd::cxx::tree::traits< address_type, char > address_traits;

    const address_optional&
    address () const;

    address_optional&
    address ();

    void
    address (const address_type& x);

    void
    address (const address_optional& x);

    void
    address (::std::auto_ptr< address_type > p);

    // telephoneNumber
    // 
    typedef ::xml_schema::string telephoneNumber_type;
    typedef ::xsd::cxx::tree::optional< telephoneNumber_type > telephoneNumber_optional;
    typedef ::xsd::cxx::tree::traits< telephoneNumber_type, char > telephoneNumber_traits;

    const telephoneNumber_optional&
    telephoneNumber () const;

    telephoneNumber_optional&
    telephoneNumber ();

    void
    telephoneNumber (const telephoneNumber_type& x);

    void
    telephoneNumber (const telephoneNumber_optional& x);

    void
    telephoneNumber (::std::auto_ptr< telephoneNumber_type > p);

    // mobileTelephoneNumber
    // 
    typedef ::xml_schema::string mobileTelephoneNumber_type;
    typedef ::xsd::cxx::tree::optional< mobileTelephoneNumber_type > mobileTelephoneNumber_optional;
    typedef ::xsd::cxx::tree::traits< mobileTelephoneNumber_type, char > mobileTelephoneNumber_traits;

    const mobileTelephoneNumber_optional&
    mobileTelephoneNumber () const;

    mobileTelephoneNumber_optional&
    mobileTelephoneNumber ();

    void
    mobileTelephoneNumber (const mobileTelephoneNumber_type& x);

    void
    mobileTelephoneNumber (const mobileTelephoneNumber_optional& x);

    void
    mobileTelephoneNumber (::std::auto_ptr< mobileTelephoneNumber_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    detailsType ();

    detailsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    detailsType (const detailsType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual detailsType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~detailsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    emailAddress_sequence emailAddress_;
    webAddress_optional webAddress_;
    address_optional address_;
    telephoneNumber_optional telephoneNumber_;
    mobileTelephoneNumber_optional mobileTelephoneNumber_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class addressType: public ::xml_schema::type
  {
    public:
    // addressLine
    // 
    typedef ::dc::elementType addressLine_type;
    typedef ::xsd::cxx::tree::sequence< addressLine_type > addressLine_sequence;
    typedef addressLine_sequence::iterator addressLine_iterator;
    typedef addressLine_sequence::const_iterator addressLine_const_iterator;
    typedef ::xsd::cxx::tree::traits< addressLine_type, char > addressLine_traits;

    const addressLine_sequence&
    addressLine () const;

    addressLine_sequence&
    addressLine ();

    void
    addressLine (const addressLine_sequence& s);

    // addressTownCity
    // 
    typedef ::dc::elementType addressTownCity_type;
    typedef ::xsd::cxx::tree::optional< addressTownCity_type > addressTownCity_optional;
    typedef ::xsd::cxx::tree::traits< addressTownCity_type, char > addressTownCity_traits;

    const addressTownCity_optional&
    addressTownCity () const;

    addressTownCity_optional&
    addressTownCity ();

    void
    addressTownCity (const addressTownCity_type& x);

    void
    addressTownCity (const addressTownCity_optional& x);

    void
    addressTownCity (::std::auto_ptr< addressTownCity_type > p);

    // addressCountyState
    // 
    typedef ::dc::elementType addressCountyState_type;
    typedef ::xsd::cxx::tree::optional< addressCountyState_type > addressCountyState_optional;
    typedef ::xsd::cxx::tree::traits< addressCountyState_type, char > addressCountyState_traits;

    const addressCountyState_optional&
    addressCountyState () const;

    addressCountyState_optional&
    addressCountyState ();

    void
    addressCountyState (const addressCountyState_type& x);

    void
    addressCountyState (const addressCountyState_optional& x);

    void
    addressCountyState (::std::auto_ptr< addressCountyState_type > p);

    // addressDeliveryCode
    // 
    typedef ::xml_schema::string addressDeliveryCode_type;
    typedef ::xsd::cxx::tree::optional< addressDeliveryCode_type > addressDeliveryCode_optional;
    typedef ::xsd::cxx::tree::traits< addressDeliveryCode_type, char > addressDeliveryCode_traits;

    const addressDeliveryCode_optional&
    addressDeliveryCode () const;

    addressDeliveryCode_optional&
    addressDeliveryCode ();

    void
    addressDeliveryCode (const addressDeliveryCode_type& x);

    void
    addressDeliveryCode (const addressDeliveryCode_optional& x);

    void
    addressDeliveryCode (::std::auto_ptr< addressDeliveryCode_type > p);

    // country
    // 
    typedef ::ebuCore_2012::country country_type;
    typedef ::xsd::cxx::tree::optional< country_type > country_optional;
    typedef ::xsd::cxx::tree::traits< country_type, char > country_traits;

    const country_optional&
    country () const;

    country_optional&
    country ();

    void
    country (const country_type& x);

    void
    country (const country_optional& x);

    void
    country (::std::auto_ptr< country_type > p);

    // Constructors.
    //
    addressType ();

    addressType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    addressType (const addressType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual addressType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~addressType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    addressLine_sequence addressLine_;
    addressTownCity_optional addressTownCity_;
    addressCountyState_optional addressCountyState_;
    addressDeliveryCode_optional addressDeliveryCode_;
    country_optional country_;
  };

  class compoundNameType: public ::xml_schema::string
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // Constructors.
    //
    compoundNameType ();

    compoundNameType (const char*);

    compoundNameType (const ::std::string&);

    compoundNameType (const ::xml_schema::string&);

    compoundNameType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    compoundNameType (const compoundNameType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual compoundNameType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~compoundNameType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
  };

  class regionType: public ::xml_schema::type
  {
    public:
    // country
    // 
    typedef ::ebuCore_2012::country1 country_type;
    typedef ::xsd::cxx::tree::optional< country_type > country_optional;
    typedef ::xsd::cxx::tree::traits< country_type, char > country_traits;

    const country_optional&
    country () const;

    country_optional&
    country ();

    void
    country (const country_type& x);

    void
    country (const country_optional& x);

    void
    country (::std::auto_ptr< country_type > p);

    // countryRegion
    // 
    typedef ::ebuCore_2012::countryRegion countryRegion_type;
    typedef ::xsd::cxx::tree::sequence< countryRegion_type > countryRegion_sequence;
    typedef countryRegion_sequence::iterator countryRegion_iterator;
    typedef countryRegion_sequence::const_iterator countryRegion_const_iterator;
    typedef ::xsd::cxx::tree::traits< countryRegion_type, char > countryRegion_traits;

    const countryRegion_sequence&
    countryRegion () const;

    countryRegion_sequence&
    countryRegion ();

    void
    countryRegion (const countryRegion_sequence& s);

    // Constructors.
    //
    regionType ();

    regionType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    regionType (const regionType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual regionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~regionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    country_optional country_;
    countryRegion_sequence countryRegion_;
  };

  class editUnitNumberType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >
  {
    public:
    // editRate
    // 
    typedef ::xml_schema::positive_integer editRate_type;
    typedef ::xsd::cxx::tree::optional< editRate_type > editRate_optional;
    typedef ::xsd::cxx::tree::traits< editRate_type, char > editRate_traits;

    const editRate_optional&
    editRate () const;

    editRate_optional&
    editRate ();

    void
    editRate (const editRate_type& x);

    void
    editRate (const editRate_optional& x);

    // factorNumerator
    // 
    typedef ::xml_schema::positive_integer factorNumerator_type;
    typedef ::xsd::cxx::tree::traits< factorNumerator_type, char > factorNumerator_traits;

    const factorNumerator_type&
    factorNumerator () const;

    factorNumerator_type&
    factorNumerator ();

    void
    factorNumerator (const factorNumerator_type& x);

    static factorNumerator_type
    factorNumerator_default_value ();

    // factorDenominator
    // 
    typedef ::xml_schema::positive_integer factorDenominator_type;
    typedef ::xsd::cxx::tree::traits< factorDenominator_type, char > factorDenominator_traits;

    const factorDenominator_type&
    factorDenominator () const;

    factorDenominator_type&
    factorDenominator ();

    void
    factorDenominator (const factorDenominator_type& x);

    static factorDenominator_type
    factorDenominator_default_value ();

    // Constructors.
    //
    editUnitNumberType (const ::xml_schema::long_&);

    editUnitNumberType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    editUnitNumberType (const editUnitNumberType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual editUnitNumberType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~editUnitNumberType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    editRate_optional editRate_;
    ::xsd::cxx::tree::one< factorNumerator_type > factorNumerator_;
    ::xsd::cxx::tree::one< factorDenominator_type > factorDenominator_;
  };

  class ratingType: public ::xml_schema::type
  {
    public:
    // ratingValue
    // 
    typedef ::dc::elementType ratingValue_type;
    typedef ::xsd::cxx::tree::sequence< ratingValue_type > ratingValue_sequence;
    typedef ratingValue_sequence::iterator ratingValue_iterator;
    typedef ratingValue_sequence::const_iterator ratingValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< ratingValue_type, char > ratingValue_traits;

    const ratingValue_sequence&
    ratingValue () const;

    ratingValue_sequence&
    ratingValue ();

    void
    ratingValue (const ratingValue_sequence& s);

    // ratingScaleMaxValue
    // 
    typedef ::dc::elementType ratingScaleMaxValue_type;
    typedef ::xsd::cxx::tree::sequence< ratingScaleMaxValue_type > ratingScaleMaxValue_sequence;
    typedef ratingScaleMaxValue_sequence::iterator ratingScaleMaxValue_iterator;
    typedef ratingScaleMaxValue_sequence::const_iterator ratingScaleMaxValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< ratingScaleMaxValue_type, char > ratingScaleMaxValue_traits;

    const ratingScaleMaxValue_sequence&
    ratingScaleMaxValue () const;

    ratingScaleMaxValue_sequence&
    ratingScaleMaxValue ();

    void
    ratingScaleMaxValue (const ratingScaleMaxValue_sequence& s);

    // ratingScaleMinValue
    // 
    typedef ::dc::elementType ratingScaleMinValue_type;
    typedef ::xsd::cxx::tree::sequence< ratingScaleMinValue_type > ratingScaleMinValue_sequence;
    typedef ratingScaleMinValue_sequence::iterator ratingScaleMinValue_iterator;
    typedef ratingScaleMinValue_sequence::const_iterator ratingScaleMinValue_const_iterator;
    typedef ::xsd::cxx::tree::traits< ratingScaleMinValue_type, char > ratingScaleMinValue_traits;

    const ratingScaleMinValue_sequence&
    ratingScaleMinValue () const;

    ratingScaleMinValue_sequence&
    ratingScaleMinValue ();

    void
    ratingScaleMinValue (const ratingScaleMinValue_sequence& s);

    // ratingProvider
    // 
    typedef ::ebuCore_2012::entityType ratingProvider_type;
    typedef ::xsd::cxx::tree::optional< ratingProvider_type > ratingProvider_optional;
    typedef ::xsd::cxx::tree::traits< ratingProvider_type, char > ratingProvider_traits;

    const ratingProvider_optional&
    ratingProvider () const;

    ratingProvider_optional&
    ratingProvider ();

    void
    ratingProvider (const ratingProvider_type& x);

    void
    ratingProvider (const ratingProvider_optional& x);

    void
    ratingProvider (::std::auto_ptr< ratingProvider_type > p);

    // ratingRegion
    // 
    typedef ::ebuCore_2012::regionType ratingRegion_type;
    typedef ::xsd::cxx::tree::sequence< ratingRegion_type > ratingRegion_sequence;
    typedef ratingRegion_sequence::iterator ratingRegion_iterator;
    typedef ratingRegion_sequence::const_iterator ratingRegion_const_iterator;
    typedef ::xsd::cxx::tree::traits< ratingRegion_type, char > ratingRegion_traits;

    const ratingRegion_sequence&
    ratingRegion () const;

    ratingRegion_sequence&
    ratingRegion ();

    void
    ratingRegion (const ratingRegion_sequence& s);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // reason
    // 
    typedef ::xml_schema::string reason_type;
    typedef ::xsd::cxx::tree::optional< reason_type > reason_optional;
    typedef ::xsd::cxx::tree::traits< reason_type, char > reason_traits;

    const reason_optional&
    reason () const;

    reason_optional&
    reason ();

    void
    reason (const reason_type& x);

    void
    reason (const reason_optional& x);

    void
    reason (::std::auto_ptr< reason_type > p);

    // linkToLogo
    // 
    typedef ::xml_schema::uri linkToLogo_type;
    typedef ::xsd::cxx::tree::optional< linkToLogo_type > linkToLogo_optional;
    typedef ::xsd::cxx::tree::traits< linkToLogo_type, char > linkToLogo_traits;

    const linkToLogo_optional&
    linkToLogo () const;

    linkToLogo_optional&
    linkToLogo ();

    void
    linkToLogo (const linkToLogo_type& x);

    void
    linkToLogo (const linkToLogo_optional& x);

    void
    linkToLogo (::std::auto_ptr< linkToLogo_type > p);

    // notRated
    // 
    typedef ::xml_schema::boolean notRated_type;
    typedef ::xsd::cxx::tree::optional< notRated_type > notRated_optional;
    typedef ::xsd::cxx::tree::traits< notRated_type, char > notRated_traits;

    const notRated_optional&
    notRated () const;

    notRated_optional&
    notRated ();

    void
    notRated (const notRated_type& x);

    void
    notRated (const notRated_optional& x);

    // adultContent
    // 
    typedef ::xml_schema::boolean adultContent_type;
    typedef ::xsd::cxx::tree::optional< adultContent_type > adultContent_optional;
    typedef ::xsd::cxx::tree::traits< adultContent_type, char > adultContent_traits;

    const adultContent_optional&
    adultContent () const;

    adultContent_optional&
    adultContent ();

    void
    adultContent (const adultContent_type& x);

    void
    adultContent (const adultContent_optional& x);

    // Constructors.
    //
    ratingType ();

    ratingType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ratingType (const ratingType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual ratingType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ratingType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ratingValue_sequence ratingValue_;
    ratingScaleMaxValue_sequence ratingScaleMaxValue_;
    ratingScaleMinValue_sequence ratingScaleMinValue_;
    ratingProvider_optional ratingProvider_;
    ratingRegion_sequence ratingRegion_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
    reason_optional reason_;
    linkToLogo_optional linkToLogo_;
    notRated_optional notRated_;
    adultContent_optional adultContent_;
  };

  class lengthType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >
  {
    public:
    // unit
    // 
    typedef ::xml_schema::string unit_type;
    typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
    typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

    const unit_optional&
    unit () const;

    unit_optional&
    unit ();

    void
    unit (const unit_type& x);

    void
    unit (const unit_optional& x);

    void
    unit (::std::auto_ptr< unit_type > p);

    // Constructors.
    //
    lengthType (const ::xml_schema::non_negative_integer&);

    lengthType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    lengthType (const lengthType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual lengthType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~lengthType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    unit_optional unit_;
  };

  class dimensionType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >
  {
    public:
    // unit
    // 
    typedef ::xml_schema::string unit_type;
    typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
    typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

    const unit_optional&
    unit () const;

    unit_optional&
    unit ();

    void
    unit (const unit_type& x);

    void
    unit (const unit_optional& x);

    void
    unit (::std::auto_ptr< unit_type > p);

    // Constructors.
    //
    dimensionType (const ::xml_schema::non_negative_integer&);

    dimensionType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    dimensionType (const dimensionType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual dimensionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~dimensionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    unit_optional unit_;
  };

  class imageFormatType: public ::xml_schema::type
  {
    public:
    // regionDelimX
    // 
    typedef ::xml_schema::non_negative_integer regionDelimX_type;
    typedef ::xsd::cxx::tree::optional< regionDelimX_type > regionDelimX_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimX_type, char > regionDelimX_traits;

    const regionDelimX_optional&
    regionDelimX () const;

    regionDelimX_optional&
    regionDelimX ();

    void
    regionDelimX (const regionDelimX_type& x);

    void
    regionDelimX (const regionDelimX_optional& x);

    // regionDelimY
    // 
    typedef ::xml_schema::non_negative_integer regionDelimY_type;
    typedef ::xsd::cxx::tree::optional< regionDelimY_type > regionDelimY_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimY_type, char > regionDelimY_traits;

    const regionDelimY_optional&
    regionDelimY () const;

    regionDelimY_optional&
    regionDelimY ();

    void
    regionDelimY (const regionDelimY_type& x);

    void
    regionDelimY (const regionDelimY_optional& x);

    // width
    // 
    typedef ::ebuCore_2012::dimensionType width_type;
    typedef ::xsd::cxx::tree::optional< width_type > width_optional;
    typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

    const width_optional&
    width () const;

    width_optional&
    width ();

    void
    width (const width_type& x);

    void
    width (const width_optional& x);

    void
    width (::std::auto_ptr< width_type > p);

    // height
    // 
    typedef ::ebuCore_2012::dimensionType height_type;
    typedef ::xsd::cxx::tree::optional< height_type > height_optional;
    typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

    const height_optional&
    height () const;

    height_optional&
    height ();

    void
    height (const height_type& x);

    void
    height (const height_optional& x);

    void
    height (::std::auto_ptr< height_type > p);

    // orientation
    // 
    typedef ::ebuCore_2012::orientation orientation_type;
    typedef ::xsd::cxx::tree::optional< orientation_type > orientation_optional;
    typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

    const orientation_optional&
    orientation () const;

    orientation_optional&
    orientation ();

    void
    orientation (const orientation_type& x);

    void
    orientation (const orientation_optional& x);

    void
    orientation (::std::auto_ptr< orientation_type > p);

    // aspectRatio
    // 
    typedef ::ebuCore_2012::aspectRatioType aspectRatio_type;
    typedef ::xsd::cxx::tree::optional< aspectRatio_type > aspectRatio_optional;
    typedef ::xsd::cxx::tree::traits< aspectRatio_type, char > aspectRatio_traits;

    const aspectRatio_optional&
    aspectRatio () const;

    aspectRatio_optional&
    aspectRatio ();

    void
    aspectRatio (const aspectRatio_type& x);

    void
    aspectRatio (const aspectRatio_optional& x);

    void
    aspectRatio (::std::auto_ptr< aspectRatio_type > p);

    // imageEncoding
    // 
    typedef ::ebuCore_2012::imageEncoding imageEncoding_type;
    typedef ::xsd::cxx::tree::optional< imageEncoding_type > imageEncoding_optional;
    typedef ::xsd::cxx::tree::traits< imageEncoding_type, char > imageEncoding_traits;

    const imageEncoding_optional&
    imageEncoding () const;

    imageEncoding_optional&
    imageEncoding ();

    void
    imageEncoding (const imageEncoding_type& x);

    void
    imageEncoding (const imageEncoding_optional& x);

    void
    imageEncoding (::std::auto_ptr< imageEncoding_type > p);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2012::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2012::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2012::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2012::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2012::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2012::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2012::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2012::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2012::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2012::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2012::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2012::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2012::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // comment
    // 
    typedef ::ebuCore_2012::comment comment_type;
    typedef ::xsd::cxx::tree::sequence< comment_type > comment_sequence;
    typedef comment_sequence::iterator comment_iterator;
    typedef comment_sequence::const_iterator comment_const_iterator;
    typedef ::xsd::cxx::tree::traits< comment_type, char > comment_traits;

    const comment_sequence&
    comment () const;

    comment_sequence&
    comment ();

    void
    comment (const comment_sequence& s);

    // imageFormatId
    // 
    typedef ::xml_schema::uri imageFormatId_type;
    typedef ::xsd::cxx::tree::optional< imageFormatId_type > imageFormatId_optional;
    typedef ::xsd::cxx::tree::traits< imageFormatId_type, char > imageFormatId_traits;

    const imageFormatId_optional&
    imageFormatId () const;

    imageFormatId_optional&
    imageFormatId ();

    void
    imageFormatId (const imageFormatId_type& x);

    void
    imageFormatId (const imageFormatId_optional& x);

    void
    imageFormatId (::std::auto_ptr< imageFormatId_type > p);

    // imageFormatVersionId
    // 
    typedef ::xml_schema::string imageFormatVersionId_type;
    typedef ::xsd::cxx::tree::optional< imageFormatVersionId_type > imageFormatVersionId_optional;
    typedef ::xsd::cxx::tree::traits< imageFormatVersionId_type, char > imageFormatVersionId_traits;

    const imageFormatVersionId_optional&
    imageFormatVersionId () const;

    imageFormatVersionId_optional&
    imageFormatVersionId ();

    void
    imageFormatVersionId (const imageFormatVersionId_type& x);

    void
    imageFormatVersionId (const imageFormatVersionId_optional& x);

    void
    imageFormatVersionId (::std::auto_ptr< imageFormatVersionId_type > p);

    // imageFormatName
    // 
    typedef ::xml_schema::string imageFormatName_type;
    typedef ::xsd::cxx::tree::optional< imageFormatName_type > imageFormatName_optional;
    typedef ::xsd::cxx::tree::traits< imageFormatName_type, char > imageFormatName_traits;

    const imageFormatName_optional&
    imageFormatName () const;

    imageFormatName_optional&
    imageFormatName ();

    void
    imageFormatName (const imageFormatName_type& x);

    void
    imageFormatName (const imageFormatName_optional& x);

    void
    imageFormatName (::std::auto_ptr< imageFormatName_type > p);

    // imageFormatDefinition
    // 
    typedef ::xml_schema::string imageFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< imageFormatDefinition_type > imageFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< imageFormatDefinition_type, char > imageFormatDefinition_traits;

    const imageFormatDefinition_optional&
    imageFormatDefinition () const;

    imageFormatDefinition_optional&
    imageFormatDefinition ();

    void
    imageFormatDefinition (const imageFormatDefinition_type& x);

    void
    imageFormatDefinition (const imageFormatDefinition_optional& x);

    void
    imageFormatDefinition (::std::auto_ptr< imageFormatDefinition_type > p);

    // Constructors.
    //
    imageFormatType ();

    imageFormatType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    imageFormatType (const imageFormatType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual imageFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~imageFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    regionDelimX_optional regionDelimX_;
    regionDelimY_optional regionDelimY_;
    width_optional width_;
    height_optional height_;
    orientation_optional orientation_;
    aspectRatio_optional aspectRatio_;
    imageEncoding_optional imageEncoding_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    comment_sequence comment_;
    imageFormatId_optional imageFormatId_;
    imageFormatVersionId_optional imageFormatVersionId_;
    imageFormatName_optional imageFormatName_;
    imageFormatDefinition_optional imageFormatDefinition_;
  };

  class videoFormatType: public ::xml_schema::type
  {
    public:
    // regionDelimX
    // 
    typedef ::xml_schema::non_negative_integer regionDelimX_type;
    typedef ::xsd::cxx::tree::optional< regionDelimX_type > regionDelimX_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimX_type, char > regionDelimX_traits;

    const regionDelimX_optional&
    regionDelimX () const;

    regionDelimX_optional&
    regionDelimX ();

    void
    regionDelimX (const regionDelimX_type& x);

    void
    regionDelimX (const regionDelimX_optional& x);

    // regionDelimY
    // 
    typedef ::xml_schema::non_negative_integer regionDelimY_type;
    typedef ::xsd::cxx::tree::optional< regionDelimY_type > regionDelimY_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimY_type, char > regionDelimY_traits;

    const regionDelimY_optional&
    regionDelimY () const;

    regionDelimY_optional&
    regionDelimY ();

    void
    regionDelimY (const regionDelimY_type& x);

    void
    regionDelimY (const regionDelimY_optional& x);

    // width
    // 
    typedef ::ebuCore_2012::width width_type;
    typedef ::xsd::cxx::tree::sequence< width_type > width_sequence;
    typedef width_sequence::iterator width_iterator;
    typedef width_sequence::const_iterator width_const_iterator;
    typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

    const width_sequence&
    width () const;

    width_sequence&
    width ();

    void
    width (const width_sequence& s);

    // height
    // 
    typedef ::ebuCore_2012::height height_type;
    typedef ::xsd::cxx::tree::sequence< height_type > height_sequence;
    typedef height_sequence::iterator height_iterator;
    typedef height_sequence::const_iterator height_const_iterator;
    typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

    const height_sequence&
    height () const;

    height_sequence&
    height ();

    void
    height (const height_sequence& s);

    // lines
    // 
    typedef ::xml_schema::non_negative_integer lines_type;
    typedef ::xsd::cxx::tree::optional< lines_type > lines_optional;
    typedef ::xsd::cxx::tree::traits< lines_type, char > lines_traits;

    const lines_optional&
    lines () const;

    lines_optional&
    lines ();

    void
    lines (const lines_type& x);

    void
    lines (const lines_optional& x);

    // frameRate
    // 
    typedef ::ebuCore_2012::rationalType frameRate_type;
    typedef ::xsd::cxx::tree::optional< frameRate_type > frameRate_optional;
    typedef ::xsd::cxx::tree::traits< frameRate_type, char > frameRate_traits;

    const frameRate_optional&
    frameRate () const;

    frameRate_optional&
    frameRate ();

    void
    frameRate (const frameRate_type& x);

    void
    frameRate (const frameRate_optional& x);

    void
    frameRate (::std::auto_ptr< frameRate_type > p);

    // aspectRatio
    // 
    typedef ::ebuCore_2012::aspectRatioType aspectRatio_type;
    typedef ::xsd::cxx::tree::sequence< aspectRatio_type > aspectRatio_sequence;
    typedef aspectRatio_sequence::iterator aspectRatio_iterator;
    typedef aspectRatio_sequence::const_iterator aspectRatio_const_iterator;
    typedef ::xsd::cxx::tree::traits< aspectRatio_type, char > aspectRatio_traits;

    const aspectRatio_sequence&
    aspectRatio () const;

    aspectRatio_sequence&
    aspectRatio ();

    void
    aspectRatio (const aspectRatio_sequence& s);

    // videoEncoding
    // 
    typedef ::ebuCore_2012::videoEncoding videoEncoding_type;
    typedef ::xsd::cxx::tree::optional< videoEncoding_type > videoEncoding_optional;
    typedef ::xsd::cxx::tree::traits< videoEncoding_type, char > videoEncoding_traits;

    const videoEncoding_optional&
    videoEncoding () const;

    videoEncoding_optional&
    videoEncoding ();

    void
    videoEncoding (const videoEncoding_type& x);

    void
    videoEncoding (const videoEncoding_optional& x);

    void
    videoEncoding (::std::auto_ptr< videoEncoding_type > p);

    // codec
    // 
    typedef ::ebuCore_2012::codecType codec_type;
    typedef ::xsd::cxx::tree::optional< codec_type > codec_optional;
    typedef ::xsd::cxx::tree::traits< codec_type, char > codec_traits;

    const codec_optional&
    codec () const;

    codec_optional&
    codec ();

    void
    codec (const codec_type& x);

    void
    codec (const codec_optional& x);

    void
    codec (::std::auto_ptr< codec_type > p);

    // bitRate
    // 
    typedef ::xml_schema::non_negative_integer bitRate_type;
    typedef ::xsd::cxx::tree::optional< bitRate_type > bitRate_optional;
    typedef ::xsd::cxx::tree::traits< bitRate_type, char > bitRate_traits;

    const bitRate_optional&
    bitRate () const;

    bitRate_optional&
    bitRate ();

    void
    bitRate (const bitRate_type& x);

    void
    bitRate (const bitRate_optional& x);

    // bitRateMax
    // 
    typedef ::xml_schema::non_negative_integer bitRateMax_type;
    typedef ::xsd::cxx::tree::optional< bitRateMax_type > bitRateMax_optional;
    typedef ::xsd::cxx::tree::traits< bitRateMax_type, char > bitRateMax_traits;

    const bitRateMax_optional&
    bitRateMax () const;

    bitRateMax_optional&
    bitRateMax ();

    void
    bitRateMax (const bitRateMax_type& x);

    void
    bitRateMax (const bitRateMax_optional& x);

    // bitRateMode
    // 
    typedef ::ebuCore_2012::bitRateMode bitRateMode_type;
    typedef ::xsd::cxx::tree::optional< bitRateMode_type > bitRateMode_optional;
    typedef ::xsd::cxx::tree::traits< bitRateMode_type, char > bitRateMode_traits;

    const bitRateMode_optional&
    bitRateMode () const;

    bitRateMode_optional&
    bitRateMode ();

    void
    bitRateMode (const bitRateMode_type& x);

    void
    bitRateMode (const bitRateMode_optional& x);

    void
    bitRateMode (::std::auto_ptr< bitRateMode_type > p);

    // scanningFormat
    // 
    typedef ::ebuCore_2012::scanningFormat scanningFormat_type;
    typedef ::xsd::cxx::tree::optional< scanningFormat_type > scanningFormat_optional;
    typedef ::xsd::cxx::tree::traits< scanningFormat_type, char > scanningFormat_traits;

    const scanningFormat_optional&
    scanningFormat () const;

    scanningFormat_optional&
    scanningFormat ();

    void
    scanningFormat (const scanningFormat_type& x);

    void
    scanningFormat (const scanningFormat_optional& x);

    void
    scanningFormat (::std::auto_ptr< scanningFormat_type > p);

    // scanningOrder
    // 
    typedef ::ebuCore_2012::scanningOrder scanningOrder_type;
    typedef ::xsd::cxx::tree::optional< scanningOrder_type > scanningOrder_optional;
    typedef ::xsd::cxx::tree::traits< scanningOrder_type, char > scanningOrder_traits;

    const scanningOrder_optional&
    scanningOrder () const;

    scanningOrder_optional&
    scanningOrder ();

    void
    scanningOrder (const scanningOrder_type& x);

    void
    scanningOrder (const scanningOrder_optional& x);

    void
    scanningOrder (::std::auto_ptr< scanningOrder_type > p);

    // noiseFilter
    // 
    typedef ::xml_schema::boolean noiseFilter_type;
    typedef ::xsd::cxx::tree::optional< noiseFilter_type > noiseFilter_optional;
    typedef ::xsd::cxx::tree::traits< noiseFilter_type, char > noiseFilter_traits;

    const noiseFilter_optional&
    noiseFilter () const;

    noiseFilter_optional&
    noiseFilter ();

    void
    noiseFilter (const noiseFilter_type& x);

    void
    noiseFilter (const noiseFilter_optional& x);

    // videoTrack
    // 
    typedef ::ebuCore_2012::videoTrack videoTrack_type;
    typedef ::xsd::cxx::tree::sequence< videoTrack_type > videoTrack_sequence;
    typedef videoTrack_sequence::iterator videoTrack_iterator;
    typedef videoTrack_sequence::const_iterator videoTrack_const_iterator;
    typedef ::xsd::cxx::tree::traits< videoTrack_type, char > videoTrack_traits;

    const videoTrack_sequence&
    videoTrack () const;

    videoTrack_sequence&
    videoTrack ();

    void
    videoTrack (const videoTrack_sequence& s);

    // flag_3D
    // 
    typedef ::xml_schema::boolean flag_3D_type;
    typedef ::xsd::cxx::tree::optional< flag_3D_type > flag_3D_optional;
    typedef ::xsd::cxx::tree::traits< flag_3D_type, char > flag_3D_traits;

    const flag_3D_optional&
    flag_3D () const;

    flag_3D_optional&
    flag_3D ();

    void
    flag_3D (const flag_3D_type& x);

    void
    flag_3D (const flag_3D_optional& x);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2012::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2012::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2012::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2012::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2012::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2012::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2012::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2012::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2012::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2012::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2012::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2012::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2012::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // comment
    // 
    typedef ::ebuCore_2012::comment1 comment_type;
    typedef ::xsd::cxx::tree::sequence< comment_type > comment_sequence;
    typedef comment_sequence::iterator comment_iterator;
    typedef comment_sequence::const_iterator comment_const_iterator;
    typedef ::xsd::cxx::tree::traits< comment_type, char > comment_traits;

    const comment_sequence&
    comment () const;

    comment_sequence&
    comment ();

    void
    comment (const comment_sequence& s);

    // videoFormatId
    // 
    typedef ::xml_schema::uri videoFormatId_type;
    typedef ::xsd::cxx::tree::optional< videoFormatId_type > videoFormatId_optional;
    typedef ::xsd::cxx::tree::traits< videoFormatId_type, char > videoFormatId_traits;

    const videoFormatId_optional&
    videoFormatId () const;

    videoFormatId_optional&
    videoFormatId ();

    void
    videoFormatId (const videoFormatId_type& x);

    void
    videoFormatId (const videoFormatId_optional& x);

    void
    videoFormatId (::std::auto_ptr< videoFormatId_type > p);

    // videoFormatVersionId
    // 
    typedef ::xml_schema::string videoFormatVersionId_type;
    typedef ::xsd::cxx::tree::optional< videoFormatVersionId_type > videoFormatVersionId_optional;
    typedef ::xsd::cxx::tree::traits< videoFormatVersionId_type, char > videoFormatVersionId_traits;

    const videoFormatVersionId_optional&
    videoFormatVersionId () const;

    videoFormatVersionId_optional&
    videoFormatVersionId ();

    void
    videoFormatVersionId (const videoFormatVersionId_type& x);

    void
    videoFormatVersionId (const videoFormatVersionId_optional& x);

    void
    videoFormatVersionId (::std::auto_ptr< videoFormatVersionId_type > p);

    // videoFormatName
    // 
    typedef ::xml_schema::string videoFormatName_type;
    typedef ::xsd::cxx::tree::optional< videoFormatName_type > videoFormatName_optional;
    typedef ::xsd::cxx::tree::traits< videoFormatName_type, char > videoFormatName_traits;

    const videoFormatName_optional&
    videoFormatName () const;

    videoFormatName_optional&
    videoFormatName ();

    void
    videoFormatName (const videoFormatName_type& x);

    void
    videoFormatName (const videoFormatName_optional& x);

    void
    videoFormatName (::std::auto_ptr< videoFormatName_type > p);

    // videoFormatDefinition
    // 
    typedef ::xml_schema::string videoFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< videoFormatDefinition_type > videoFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< videoFormatDefinition_type, char > videoFormatDefinition_traits;

    const videoFormatDefinition_optional&
    videoFormatDefinition () const;

    videoFormatDefinition_optional&
    videoFormatDefinition ();

    void
    videoFormatDefinition (const videoFormatDefinition_type& x);

    void
    videoFormatDefinition (const videoFormatDefinition_optional& x);

    void
    videoFormatDefinition (::std::auto_ptr< videoFormatDefinition_type > p);

    // Constructors.
    //
    videoFormatType ();

    videoFormatType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    videoFormatType (const videoFormatType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual videoFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~videoFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    regionDelimX_optional regionDelimX_;
    regionDelimY_optional regionDelimY_;
    width_sequence width_;
    height_sequence height_;
    lines_optional lines_;
    frameRate_optional frameRate_;
    aspectRatio_sequence aspectRatio_;
    videoEncoding_optional videoEncoding_;
    codec_optional codec_;
    bitRate_optional bitRate_;
    bitRateMax_optional bitRateMax_;
    bitRateMode_optional bitRateMode_;
    scanningFormat_optional scanningFormat_;
    scanningOrder_optional scanningOrder_;
    noiseFilter_optional noiseFilter_;
    videoTrack_sequence videoTrack_;
    flag_3D_optional flag_3D_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    comment_sequence comment_;
    videoFormatId_optional videoFormatId_;
    videoFormatVersionId_optional videoFormatVersionId_;
    videoFormatName_optional videoFormatName_;
    videoFormatDefinition_optional videoFormatDefinition_;
  };

  class audioFormatType: public ::xml_schema::type
  {
    public:
    // audioEncoding
    // 
    typedef ::ebuCore_2012::audioEncoding audioEncoding_type;
    typedef ::xsd::cxx::tree::optional< audioEncoding_type > audioEncoding_optional;
    typedef ::xsd::cxx::tree::traits< audioEncoding_type, char > audioEncoding_traits;

    const audioEncoding_optional&
    audioEncoding () const;

    audioEncoding_optional&
    audioEncoding ();

    void
    audioEncoding (const audioEncoding_type& x);

    void
    audioEncoding (const audioEncoding_optional& x);

    void
    audioEncoding (::std::auto_ptr< audioEncoding_type > p);

    // codec
    // 
    typedef ::ebuCore_2012::codecType codec_type;
    typedef ::xsd::cxx::tree::optional< codec_type > codec_optional;
    typedef ::xsd::cxx::tree::traits< codec_type, char > codec_traits;

    const codec_optional&
    codec () const;

    codec_optional&
    codec ();

    void
    codec (const codec_type& x);

    void
    codec (const codec_optional& x);

    void
    codec (::std::auto_ptr< codec_type > p);

    // audioTrackConfiguration
    // 
    typedef ::ebuCore_2012::audioTrackConfiguration audioTrackConfiguration_type;
    typedef ::xsd::cxx::tree::optional< audioTrackConfiguration_type > audioTrackConfiguration_optional;
    typedef ::xsd::cxx::tree::traits< audioTrackConfiguration_type, char > audioTrackConfiguration_traits;

    const audioTrackConfiguration_optional&
    audioTrackConfiguration () const;

    audioTrackConfiguration_optional&
    audioTrackConfiguration ();

    void
    audioTrackConfiguration (const audioTrackConfiguration_type& x);

    void
    audioTrackConfiguration (const audioTrackConfiguration_optional& x);

    void
    audioTrackConfiguration (::std::auto_ptr< audioTrackConfiguration_type > p);

    // samplingRate
    // 
    typedef ::xml_schema::long_ samplingRate_type;
    typedef ::xsd::cxx::tree::optional< samplingRate_type > samplingRate_optional;
    typedef ::xsd::cxx::tree::traits< samplingRate_type, char > samplingRate_traits;

    const samplingRate_optional&
    samplingRate () const;

    samplingRate_optional&
    samplingRate ();

    void
    samplingRate (const samplingRate_type& x);

    void
    samplingRate (const samplingRate_optional& x);

    // sampleSize
    // 
    typedef ::xml_schema::non_negative_integer sampleSize_type;
    typedef ::xsd::cxx::tree::optional< sampleSize_type > sampleSize_optional;
    typedef ::xsd::cxx::tree::traits< sampleSize_type, char > sampleSize_traits;

    const sampleSize_optional&
    sampleSize () const;

    sampleSize_optional&
    sampleSize ();

    void
    sampleSize (const sampleSize_type& x);

    void
    sampleSize (const sampleSize_optional& x);

    // sampleType
    // 
    typedef ::ebuCore_2012::sampleType sampleType_type;
    typedef ::xsd::cxx::tree::optional< sampleType_type > sampleType_optional;
    typedef ::xsd::cxx::tree::traits< sampleType_type, char > sampleType_traits;

    const sampleType_optional&
    sampleType () const;

    sampleType_optional&
    sampleType ();

    void
    sampleType (const sampleType_type& x);

    void
    sampleType (const sampleType_optional& x);

    void
    sampleType (::std::auto_ptr< sampleType_type > p);

    // bitRate
    // 
    typedef ::xml_schema::non_negative_integer bitRate_type;
    typedef ::xsd::cxx::tree::optional< bitRate_type > bitRate_optional;
    typedef ::xsd::cxx::tree::traits< bitRate_type, char > bitRate_traits;

    const bitRate_optional&
    bitRate () const;

    bitRate_optional&
    bitRate ();

    void
    bitRate (const bitRate_type& x);

    void
    bitRate (const bitRate_optional& x);

    // bitRateMax
    // 
    typedef ::xml_schema::non_negative_integer bitRateMax_type;
    typedef ::xsd::cxx::tree::optional< bitRateMax_type > bitRateMax_optional;
    typedef ::xsd::cxx::tree::traits< bitRateMax_type, char > bitRateMax_traits;

    const bitRateMax_optional&
    bitRateMax () const;

    bitRateMax_optional&
    bitRateMax ();

    void
    bitRateMax (const bitRateMax_type& x);

    void
    bitRateMax (const bitRateMax_optional& x);

    // bitRateMode
    // 
    typedef ::ebuCore_2012::bitRateMode1 bitRateMode_type;
    typedef ::xsd::cxx::tree::optional< bitRateMode_type > bitRateMode_optional;
    typedef ::xsd::cxx::tree::traits< bitRateMode_type, char > bitRateMode_traits;

    const bitRateMode_optional&
    bitRateMode () const;

    bitRateMode_optional&
    bitRateMode ();

    void
    bitRateMode (const bitRateMode_type& x);

    void
    bitRateMode (const bitRateMode_optional& x);

    void
    bitRateMode (::std::auto_ptr< bitRateMode_type > p);

    // audioTrack
    // 
    typedef ::ebuCore_2012::audioTrack audioTrack_type;
    typedef ::xsd::cxx::tree::sequence< audioTrack_type > audioTrack_sequence;
    typedef audioTrack_sequence::iterator audioTrack_iterator;
    typedef audioTrack_sequence::const_iterator audioTrack_const_iterator;
    typedef ::xsd::cxx::tree::traits< audioTrack_type, char > audioTrack_traits;

    const audioTrack_sequence&
    audioTrack () const;

    audioTrack_sequence&
    audioTrack ();

    void
    audioTrack (const audioTrack_sequence& s);

    // channels
    // 
    typedef ::xml_schema::non_negative_integer channels_type;
    typedef ::xsd::cxx::tree::optional< channels_type > channels_optional;
    typedef ::xsd::cxx::tree::traits< channels_type, char > channels_traits;

    const channels_optional&
    channels () const;

    channels_optional&
    channels ();

    void
    channels (const channels_type& x);

    void
    channels (const channels_optional& x);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2012::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2012::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2012::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2012::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2012::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2012::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2012::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2012::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2012::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2012::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2012::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2012::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2012::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // comment
    // 
    typedef ::ebuCore_2012::comment2 comment_type;
    typedef ::xsd::cxx::tree::sequence< comment_type > comment_sequence;
    typedef comment_sequence::iterator comment_iterator;
    typedef comment_sequence::const_iterator comment_const_iterator;
    typedef ::xsd::cxx::tree::traits< comment_type, char > comment_traits;

    const comment_sequence&
    comment () const;

    comment_sequence&
    comment ();

    void
    comment (const comment_sequence& s);

    // audioFormatId
    // 
    typedef ::xml_schema::uri audioFormatId_type;
    typedef ::xsd::cxx::tree::optional< audioFormatId_type > audioFormatId_optional;
    typedef ::xsd::cxx::tree::traits< audioFormatId_type, char > audioFormatId_traits;

    const audioFormatId_optional&
    audioFormatId () const;

    audioFormatId_optional&
    audioFormatId ();

    void
    audioFormatId (const audioFormatId_type& x);

    void
    audioFormatId (const audioFormatId_optional& x);

    void
    audioFormatId (::std::auto_ptr< audioFormatId_type > p);

    // audioFormatVersionId
    // 
    typedef ::xml_schema::string audioFormatVersionId_type;
    typedef ::xsd::cxx::tree::optional< audioFormatVersionId_type > audioFormatVersionId_optional;
    typedef ::xsd::cxx::tree::traits< audioFormatVersionId_type, char > audioFormatVersionId_traits;

    const audioFormatVersionId_optional&
    audioFormatVersionId () const;

    audioFormatVersionId_optional&
    audioFormatVersionId ();

    void
    audioFormatVersionId (const audioFormatVersionId_type& x);

    void
    audioFormatVersionId (const audioFormatVersionId_optional& x);

    void
    audioFormatVersionId (::std::auto_ptr< audioFormatVersionId_type > p);

    // audioFormatName
    // 
    typedef ::xml_schema::string audioFormatName_type;
    typedef ::xsd::cxx::tree::optional< audioFormatName_type > audioFormatName_optional;
    typedef ::xsd::cxx::tree::traits< audioFormatName_type, char > audioFormatName_traits;

    const audioFormatName_optional&
    audioFormatName () const;

    audioFormatName_optional&
    audioFormatName ();

    void
    audioFormatName (const audioFormatName_type& x);

    void
    audioFormatName (const audioFormatName_optional& x);

    void
    audioFormatName (::std::auto_ptr< audioFormatName_type > p);

    // audioFormatDefinition
    // 
    typedef ::xml_schema::string audioFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< audioFormatDefinition_type > audioFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< audioFormatDefinition_type, char > audioFormatDefinition_traits;

    const audioFormatDefinition_optional&
    audioFormatDefinition () const;

    audioFormatDefinition_optional&
    audioFormatDefinition ();

    void
    audioFormatDefinition (const audioFormatDefinition_type& x);

    void
    audioFormatDefinition (const audioFormatDefinition_optional& x);

    void
    audioFormatDefinition (::std::auto_ptr< audioFormatDefinition_type > p);

    // Constructors.
    //
    audioFormatType ();

    audioFormatType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    audioFormatType (const audioFormatType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual audioFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~audioFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    audioEncoding_optional audioEncoding_;
    codec_optional codec_;
    audioTrackConfiguration_optional audioTrackConfiguration_;
    samplingRate_optional samplingRate_;
    sampleSize_optional sampleSize_;
    sampleType_optional sampleType_;
    bitRate_optional bitRate_;
    bitRateMax_optional bitRateMax_;
    bitRateMode_optional bitRateMode_;
    audioTrack_sequence audioTrack_;
    channels_optional channels_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    comment_sequence comment_;
    audioFormatId_optional audioFormatId_;
    audioFormatVersionId_optional audioFormatVersionId_;
    audioFormatName_optional audioFormatName_;
    audioFormatDefinition_optional audioFormatDefinition_;
  };

  class dataFormatType: public ::xml_schema::type
  {
    public:
    // captioningFormat
    // 
    typedef ::ebuCore_2012::captioningFormat captioningFormat_type;
    typedef ::xsd::cxx::tree::sequence< captioningFormat_type > captioningFormat_sequence;
    typedef captioningFormat_sequence::iterator captioningFormat_iterator;
    typedef captioningFormat_sequence::const_iterator captioningFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< captioningFormat_type, char > captioningFormat_traits;

    const captioningFormat_sequence&
    captioningFormat () const;

    captioningFormat_sequence&
    captioningFormat ();

    void
    captioningFormat (const captioningFormat_sequence& s);

    // subtitlingFormat
    // 
    typedef ::ebuCore_2012::subtitlingFormat subtitlingFormat_type;
    typedef ::xsd::cxx::tree::sequence< subtitlingFormat_type > subtitlingFormat_sequence;
    typedef subtitlingFormat_sequence::iterator subtitlingFormat_iterator;
    typedef subtitlingFormat_sequence::const_iterator subtitlingFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< subtitlingFormat_type, char > subtitlingFormat_traits;

    const subtitlingFormat_sequence&
    subtitlingFormat () const;

    subtitlingFormat_sequence&
    subtitlingFormat ();

    void
    subtitlingFormat (const subtitlingFormat_sequence& s);

    // ancillaryDataFormat
    // 
    typedef ::ebuCore_2012::ancillaryDataFormat ancillaryDataFormat_type;
    typedef ::xsd::cxx::tree::sequence< ancillaryDataFormat_type > ancillaryDataFormat_sequence;
    typedef ancillaryDataFormat_sequence::iterator ancillaryDataFormat_iterator;
    typedef ancillaryDataFormat_sequence::const_iterator ancillaryDataFormat_const_iterator;
    typedef ::xsd::cxx::tree::traits< ancillaryDataFormat_type, char > ancillaryDataFormat_traits;

    const ancillaryDataFormat_sequence&
    ancillaryDataFormat () const;

    ancillaryDataFormat_sequence&
    ancillaryDataFormat ();

    void
    ancillaryDataFormat (const ancillaryDataFormat_sequence& s);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2012::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2012::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2012::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2012::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2012::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2012::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2012::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2012::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2012::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2012::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2012::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2012::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2012::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // comment
    // 
    typedef ::ebuCore_2012::comment3 comment_type;
    typedef ::xsd::cxx::tree::sequence< comment_type > comment_sequence;
    typedef comment_sequence::iterator comment_iterator;
    typedef comment_sequence::const_iterator comment_const_iterator;
    typedef ::xsd::cxx::tree::traits< comment_type, char > comment_traits;

    const comment_sequence&
    comment () const;

    comment_sequence&
    comment ();

    void
    comment (const comment_sequence& s);

    // dataFormatId
    // 
    typedef ::xml_schema::uri dataFormatId_type;
    typedef ::xsd::cxx::tree::optional< dataFormatId_type > dataFormatId_optional;
    typedef ::xsd::cxx::tree::traits< dataFormatId_type, char > dataFormatId_traits;

    const dataFormatId_optional&
    dataFormatId () const;

    dataFormatId_optional&
    dataFormatId ();

    void
    dataFormatId (const dataFormatId_type& x);

    void
    dataFormatId (const dataFormatId_optional& x);

    void
    dataFormatId (::std::auto_ptr< dataFormatId_type > p);

    // dataFormatVersionId
    // 
    typedef ::xml_schema::string dataFormatVersionId_type;
    typedef ::xsd::cxx::tree::optional< dataFormatVersionId_type > dataFormatVersionId_optional;
    typedef ::xsd::cxx::tree::traits< dataFormatVersionId_type, char > dataFormatVersionId_traits;

    const dataFormatVersionId_optional&
    dataFormatVersionId () const;

    dataFormatVersionId_optional&
    dataFormatVersionId ();

    void
    dataFormatVersionId (const dataFormatVersionId_type& x);

    void
    dataFormatVersionId (const dataFormatVersionId_optional& x);

    void
    dataFormatVersionId (::std::auto_ptr< dataFormatVersionId_type > p);

    // dataFormatName
    // 
    typedef ::xml_schema::string dataFormatName_type;
    typedef ::xsd::cxx::tree::optional< dataFormatName_type > dataFormatName_optional;
    typedef ::xsd::cxx::tree::traits< dataFormatName_type, char > dataFormatName_traits;

    const dataFormatName_optional&
    dataFormatName () const;

    dataFormatName_optional&
    dataFormatName ();

    void
    dataFormatName (const dataFormatName_type& x);

    void
    dataFormatName (const dataFormatName_optional& x);

    void
    dataFormatName (::std::auto_ptr< dataFormatName_type > p);

    // dataFormatDefinition
    // 
    typedef ::xml_schema::string dataFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< dataFormatDefinition_type > dataFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< dataFormatDefinition_type, char > dataFormatDefinition_traits;

    const dataFormatDefinition_optional&
    dataFormatDefinition () const;

    dataFormatDefinition_optional&
    dataFormatDefinition ();

    void
    dataFormatDefinition (const dataFormatDefinition_type& x);

    void
    dataFormatDefinition (const dataFormatDefinition_optional& x);

    void
    dataFormatDefinition (::std::auto_ptr< dataFormatDefinition_type > p);

    // dataTrackId
    // 
    typedef ::xml_schema::nmtoken dataTrackId_type;
    typedef ::xsd::cxx::tree::optional< dataTrackId_type > dataTrackId_optional;
    typedef ::xsd::cxx::tree::traits< dataTrackId_type, char > dataTrackId_traits;

    const dataTrackId_optional&
    dataTrackId () const;

    dataTrackId_optional&
    dataTrackId ();

    void
    dataTrackId (const dataTrackId_type& x);

    void
    dataTrackId (const dataTrackId_optional& x);

    void
    dataTrackId (::std::auto_ptr< dataTrackId_type > p);

    // dataTrackName
    // 
    typedef ::xml_schema::string dataTrackName_type;
    typedef ::xsd::cxx::tree::optional< dataTrackName_type > dataTrackName_optional;
    typedef ::xsd::cxx::tree::traits< dataTrackName_type, char > dataTrackName_traits;

    const dataTrackName_optional&
    dataTrackName () const;

    dataTrackName_optional&
    dataTrackName ();

    void
    dataTrackName (const dataTrackName_type& x);

    void
    dataTrackName (const dataTrackName_optional& x);

    void
    dataTrackName (::std::auto_ptr< dataTrackName_type > p);

    // dataTrackLanguage
    // 
    typedef ::xml_schema::language dataTrackLanguage_type;
    typedef ::xsd::cxx::tree::optional< dataTrackLanguage_type > dataTrackLanguage_optional;
    typedef ::xsd::cxx::tree::traits< dataTrackLanguage_type, char > dataTrackLanguage_traits;

    const dataTrackLanguage_optional&
    dataTrackLanguage () const;

    dataTrackLanguage_optional&
    dataTrackLanguage ();

    void
    dataTrackLanguage (const dataTrackLanguage_type& x);

    void
    dataTrackLanguage (const dataTrackLanguage_optional& x);

    void
    dataTrackLanguage (::std::auto_ptr< dataTrackLanguage_type > p);

    // Constructors.
    //
    dataFormatType ();

    dataFormatType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    dataFormatType (const dataFormatType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual dataFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~dataFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    captioningFormat_sequence captioningFormat_;
    subtitlingFormat_sequence subtitlingFormat_;
    ancillaryDataFormat_sequence ancillaryDataFormat_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    comment_sequence comment_;
    dataFormatId_optional dataFormatId_;
    dataFormatVersionId_optional dataFormatVersionId_;
    dataFormatName_optional dataFormatName_;
    dataFormatDefinition_optional dataFormatDefinition_;
    dataTrackId_optional dataTrackId_;
    dataTrackName_optional dataTrackName_;
    dataTrackLanguage_optional dataTrackLanguage_;
  };

  class documentFormatType: public ::xml_schema::type
  {
    public:
    // wordCount
    // 
    typedef ::xml_schema::integer wordCount_type;
    typedef ::xsd::cxx::tree::optional< wordCount_type > wordCount_optional;
    typedef ::xsd::cxx::tree::traits< wordCount_type, char > wordCount_traits;

    const wordCount_optional&
    wordCount () const;

    wordCount_optional&
    wordCount ();

    void
    wordCount (const wordCount_type& x);

    void
    wordCount (const wordCount_optional& x);

    // regionDelimX
    // 
    typedef ::xml_schema::non_negative_integer regionDelimX_type;
    typedef ::xsd::cxx::tree::optional< regionDelimX_type > regionDelimX_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimX_type, char > regionDelimX_traits;

    const regionDelimX_optional&
    regionDelimX () const;

    regionDelimX_optional&
    regionDelimX ();

    void
    regionDelimX (const regionDelimX_type& x);

    void
    regionDelimX (const regionDelimX_optional& x);

    // regionDelimY
    // 
    typedef ::xml_schema::non_negative_integer regionDelimY_type;
    typedef ::xsd::cxx::tree::optional< regionDelimY_type > regionDelimY_optional;
    typedef ::xsd::cxx::tree::traits< regionDelimY_type, char > regionDelimY_traits;

    const regionDelimY_optional&
    regionDelimY () const;

    regionDelimY_optional&
    regionDelimY ();

    void
    regionDelimY (const regionDelimY_type& x);

    void
    regionDelimY (const regionDelimY_optional& x);

    // width
    // 
    typedef ::ebuCore_2012::dimensionType width_type;
    typedef ::xsd::cxx::tree::optional< width_type > width_optional;
    typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

    const width_optional&
    width () const;

    width_optional&
    width ();

    void
    width (const width_type& x);

    void
    width (const width_optional& x);

    void
    width (::std::auto_ptr< width_type > p);

    // height
    // 
    typedef ::ebuCore_2012::dimensionType height_type;
    typedef ::xsd::cxx::tree::optional< height_type > height_optional;
    typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

    const height_optional&
    height () const;

    height_optional&
    height ();

    void
    height (const height_type& x);

    void
    height (const height_optional& x);

    void
    height (::std::auto_ptr< height_type > p);

    // technicalAttributeString
    // 
    typedef ::ebuCore_2012::String technicalAttributeString_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeString_type > technicalAttributeString_sequence;
    typedef technicalAttributeString_sequence::iterator technicalAttributeString_iterator;
    typedef technicalAttributeString_sequence::const_iterator technicalAttributeString_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeString_type, char > technicalAttributeString_traits;

    const technicalAttributeString_sequence&
    technicalAttributeString () const;

    technicalAttributeString_sequence&
    technicalAttributeString ();

    void
    technicalAttributeString (const technicalAttributeString_sequence& s);

    // technicalAttributeByte
    // 
    typedef ::ebuCore_2012::Int8 technicalAttributeByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeByte_type > technicalAttributeByte_sequence;
    typedef technicalAttributeByte_sequence::iterator technicalAttributeByte_iterator;
    typedef technicalAttributeByte_sequence::const_iterator technicalAttributeByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeByte_type, char > technicalAttributeByte_traits;

    const technicalAttributeByte_sequence&
    technicalAttributeByte () const;

    technicalAttributeByte_sequence&
    technicalAttributeByte ();

    void
    technicalAttributeByte (const technicalAttributeByte_sequence& s);

    // technicalAttributeShort
    // 
    typedef ::ebuCore_2012::Int16 technicalAttributeShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeShort_type > technicalAttributeShort_sequence;
    typedef technicalAttributeShort_sequence::iterator technicalAttributeShort_iterator;
    typedef technicalAttributeShort_sequence::const_iterator technicalAttributeShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeShort_type, char > technicalAttributeShort_traits;

    const technicalAttributeShort_sequence&
    technicalAttributeShort () const;

    technicalAttributeShort_sequence&
    technicalAttributeShort ();

    void
    technicalAttributeShort (const technicalAttributeShort_sequence& s);

    // technicalAttributeInteger
    // 
    typedef ::ebuCore_2012::Int32 technicalAttributeInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeInteger_type > technicalAttributeInteger_sequence;
    typedef technicalAttributeInteger_sequence::iterator technicalAttributeInteger_iterator;
    typedef technicalAttributeInteger_sequence::const_iterator technicalAttributeInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeInteger_type, char > technicalAttributeInteger_traits;

    const technicalAttributeInteger_sequence&
    technicalAttributeInteger () const;

    technicalAttributeInteger_sequence&
    technicalAttributeInteger ();

    void
    technicalAttributeInteger (const technicalAttributeInteger_sequence& s);

    // technicalAttributeLong
    // 
    typedef ::ebuCore_2012::Int64 technicalAttributeLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeLong_type > technicalAttributeLong_sequence;
    typedef technicalAttributeLong_sequence::iterator technicalAttributeLong_iterator;
    typedef technicalAttributeLong_sequence::const_iterator technicalAttributeLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeLong_type, char > technicalAttributeLong_traits;

    const technicalAttributeLong_sequence&
    technicalAttributeLong () const;

    technicalAttributeLong_sequence&
    technicalAttributeLong ();

    void
    technicalAttributeLong (const technicalAttributeLong_sequence& s);

    // technicalAttributeUnsignedByte
    // 
    typedef ::ebuCore_2012::UInt8 technicalAttributeUnsignedByte_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedByte_type > technicalAttributeUnsignedByte_sequence;
    typedef technicalAttributeUnsignedByte_sequence::iterator technicalAttributeUnsignedByte_iterator;
    typedef technicalAttributeUnsignedByte_sequence::const_iterator technicalAttributeUnsignedByte_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedByte_type, char > technicalAttributeUnsignedByte_traits;

    const technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte () const;

    technicalAttributeUnsignedByte_sequence&
    technicalAttributeUnsignedByte ();

    void
    technicalAttributeUnsignedByte (const technicalAttributeUnsignedByte_sequence& s);

    // technicalAttributeUnsignedShort
    // 
    typedef ::ebuCore_2012::UInt16 technicalAttributeUnsignedShort_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedShort_type > technicalAttributeUnsignedShort_sequence;
    typedef technicalAttributeUnsignedShort_sequence::iterator technicalAttributeUnsignedShort_iterator;
    typedef technicalAttributeUnsignedShort_sequence::const_iterator technicalAttributeUnsignedShort_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedShort_type, char > technicalAttributeUnsignedShort_traits;

    const technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort () const;

    technicalAttributeUnsignedShort_sequence&
    technicalAttributeUnsignedShort ();

    void
    technicalAttributeUnsignedShort (const technicalAttributeUnsignedShort_sequence& s);

    // technicalAttributeUnsignedInteger
    // 
    typedef ::ebuCore_2012::UInt32 technicalAttributeUnsignedInteger_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedInteger_type > technicalAttributeUnsignedInteger_sequence;
    typedef technicalAttributeUnsignedInteger_sequence::iterator technicalAttributeUnsignedInteger_iterator;
    typedef technicalAttributeUnsignedInteger_sequence::const_iterator technicalAttributeUnsignedInteger_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedInteger_type, char > technicalAttributeUnsignedInteger_traits;

    const technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger () const;

    technicalAttributeUnsignedInteger_sequence&
    technicalAttributeUnsignedInteger ();

    void
    technicalAttributeUnsignedInteger (const technicalAttributeUnsignedInteger_sequence& s);

    // technicalAttributeUnsignedLong
    // 
    typedef ::ebuCore_2012::UInt64 technicalAttributeUnsignedLong_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUnsignedLong_type > technicalAttributeUnsignedLong_sequence;
    typedef technicalAttributeUnsignedLong_sequence::iterator technicalAttributeUnsignedLong_iterator;
    typedef technicalAttributeUnsignedLong_sequence::const_iterator technicalAttributeUnsignedLong_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUnsignedLong_type, char > technicalAttributeUnsignedLong_traits;

    const technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong () const;

    technicalAttributeUnsignedLong_sequence&
    technicalAttributeUnsignedLong ();

    void
    technicalAttributeUnsignedLong (const technicalAttributeUnsignedLong_sequence& s);

    // technicalAttributeBoolean
    // 
    typedef ::ebuCore_2012::Boolean technicalAttributeBoolean_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeBoolean_type > technicalAttributeBoolean_sequence;
    typedef technicalAttributeBoolean_sequence::iterator technicalAttributeBoolean_iterator;
    typedef technicalAttributeBoolean_sequence::const_iterator technicalAttributeBoolean_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeBoolean_type, char > technicalAttributeBoolean_traits;

    const technicalAttributeBoolean_sequence&
    technicalAttributeBoolean () const;

    technicalAttributeBoolean_sequence&
    technicalAttributeBoolean ();

    void
    technicalAttributeBoolean (const technicalAttributeBoolean_sequence& s);

    // technicalAttributeFloat
    // 
    typedef ::ebuCore_2012::Float technicalAttributeFloat_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeFloat_type > technicalAttributeFloat_sequence;
    typedef technicalAttributeFloat_sequence::iterator technicalAttributeFloat_iterator;
    typedef technicalAttributeFloat_sequence::const_iterator technicalAttributeFloat_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeFloat_type, char > technicalAttributeFloat_traits;

    const technicalAttributeFloat_sequence&
    technicalAttributeFloat () const;

    technicalAttributeFloat_sequence&
    technicalAttributeFloat ();

    void
    technicalAttributeFloat (const technicalAttributeFloat_sequence& s);

    // technicalAttributeRational
    // 
    typedef ::ebuCore_2012::technicalAttributeRationalType technicalAttributeRational_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeRational_type > technicalAttributeRational_sequence;
    typedef technicalAttributeRational_sequence::iterator technicalAttributeRational_iterator;
    typedef technicalAttributeRational_sequence::const_iterator technicalAttributeRational_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeRational_type, char > technicalAttributeRational_traits;

    const technicalAttributeRational_sequence&
    technicalAttributeRational () const;

    technicalAttributeRational_sequence&
    technicalAttributeRational ();

    void
    technicalAttributeRational (const technicalAttributeRational_sequence& s);

    // technicalAttributeUri
    // 
    typedef ::ebuCore_2012::technicalAttributeUriType technicalAttributeUri_type;
    typedef ::xsd::cxx::tree::sequence< technicalAttributeUri_type > technicalAttributeUri_sequence;
    typedef technicalAttributeUri_sequence::iterator technicalAttributeUri_iterator;
    typedef technicalAttributeUri_sequence::const_iterator technicalAttributeUri_const_iterator;
    typedef ::xsd::cxx::tree::traits< technicalAttributeUri_type, char > technicalAttributeUri_traits;

    const technicalAttributeUri_sequence&
    technicalAttributeUri () const;

    technicalAttributeUri_sequence&
    technicalAttributeUri ();

    void
    technicalAttributeUri (const technicalAttributeUri_sequence& s);

    // comment
    // 
    typedef ::ebuCore_2012::comment4 comment_type;
    typedef ::xsd::cxx::tree::sequence< comment_type > comment_sequence;
    typedef comment_sequence::iterator comment_iterator;
    typedef comment_sequence::const_iterator comment_const_iterator;
    typedef ::xsd::cxx::tree::traits< comment_type, char > comment_traits;

    const comment_sequence&
    comment () const;

    comment_sequence&
    comment ();

    void
    comment (const comment_sequence& s);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // documentFormatId
    // 
    typedef ::xml_schema::uri documentFormatId_type;
    typedef ::xsd::cxx::tree::optional< documentFormatId_type > documentFormatId_optional;
    typedef ::xsd::cxx::tree::traits< documentFormatId_type, char > documentFormatId_traits;

    const documentFormatId_optional&
    documentFormatId () const;

    documentFormatId_optional&
    documentFormatId ();

    void
    documentFormatId (const documentFormatId_type& x);

    void
    documentFormatId (const documentFormatId_optional& x);

    void
    documentFormatId (::std::auto_ptr< documentFormatId_type > p);

    // documentFormatVersionId
    // 
    typedef ::xml_schema::string documentFormatVersionId_type;
    typedef ::xsd::cxx::tree::optional< documentFormatVersionId_type > documentFormatVersionId_optional;
    typedef ::xsd::cxx::tree::traits< documentFormatVersionId_type, char > documentFormatVersionId_traits;

    const documentFormatVersionId_optional&
    documentFormatVersionId () const;

    documentFormatVersionId_optional&
    documentFormatVersionId ();

    void
    documentFormatVersionId (const documentFormatVersionId_type& x);

    void
    documentFormatVersionId (const documentFormatVersionId_optional& x);

    void
    documentFormatVersionId (::std::auto_ptr< documentFormatVersionId_type > p);

    // documentFormatName
    // 
    typedef ::xml_schema::string documentFormatName_type;
    typedef ::xsd::cxx::tree::optional< documentFormatName_type > documentFormatName_optional;
    typedef ::xsd::cxx::tree::traits< documentFormatName_type, char > documentFormatName_traits;

    const documentFormatName_optional&
    documentFormatName () const;

    documentFormatName_optional&
    documentFormatName ();

    void
    documentFormatName (const documentFormatName_type& x);

    void
    documentFormatName (const documentFormatName_optional& x);

    void
    documentFormatName (::std::auto_ptr< documentFormatName_type > p);

    // documentFormatDefinition
    // 
    typedef ::xml_schema::string documentFormatDefinition_type;
    typedef ::xsd::cxx::tree::optional< documentFormatDefinition_type > documentFormatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< documentFormatDefinition_type, char > documentFormatDefinition_traits;

    const documentFormatDefinition_optional&
    documentFormatDefinition () const;

    documentFormatDefinition_optional&
    documentFormatDefinition ();

    void
    documentFormatDefinition (const documentFormatDefinition_type& x);

    void
    documentFormatDefinition (const documentFormatDefinition_optional& x);

    void
    documentFormatDefinition (::std::auto_ptr< documentFormatDefinition_type > p);

    // Constructors.
    //
    documentFormatType ();

    documentFormatType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    documentFormatType (const documentFormatType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual documentFormatType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~documentFormatType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    wordCount_optional wordCount_;
    regionDelimX_optional regionDelimX_;
    regionDelimY_optional regionDelimY_;
    width_optional width_;
    height_optional height_;
    technicalAttributeString_sequence technicalAttributeString_;
    technicalAttributeByte_sequence technicalAttributeByte_;
    technicalAttributeShort_sequence technicalAttributeShort_;
    technicalAttributeInteger_sequence technicalAttributeInteger_;
    technicalAttributeLong_sequence technicalAttributeLong_;
    technicalAttributeUnsignedByte_sequence technicalAttributeUnsignedByte_;
    technicalAttributeUnsignedShort_sequence technicalAttributeUnsignedShort_;
    technicalAttributeUnsignedInteger_sequence technicalAttributeUnsignedInteger_;
    technicalAttributeUnsignedLong_sequence technicalAttributeUnsignedLong_;
    technicalAttributeBoolean_sequence technicalAttributeBoolean_;
    technicalAttributeFloat_sequence technicalAttributeFloat_;
    technicalAttributeRational_sequence technicalAttributeRational_;
    technicalAttributeUri_sequence technicalAttributeUri_;
    comment_sequence comment_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    documentFormatId_optional documentFormatId_;
    documentFormatVersionId_optional documentFormatVersionId_;
    documentFormatName_optional documentFormatName_;
    documentFormatDefinition_optional documentFormatDefinition_;
  };

  class codecType: public ::xml_schema::type
  {
    public:
    // codecIdentifier
    // 
    typedef ::ebuCore_2012::identifierType codecIdentifier_type;
    typedef ::xsd::cxx::tree::optional< codecIdentifier_type > codecIdentifier_optional;
    typedef ::xsd::cxx::tree::traits< codecIdentifier_type, char > codecIdentifier_traits;

    const codecIdentifier_optional&
    codecIdentifier () const;

    codecIdentifier_optional&
    codecIdentifier ();

    void
    codecIdentifier (const codecIdentifier_type& x);

    void
    codecIdentifier (const codecIdentifier_optional& x);

    void
    codecIdentifier (::std::auto_ptr< codecIdentifier_type > p);

    // name
    // 
    typedef ::xml_schema::string name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // vendor
    // 
    typedef ::xml_schema::string vendor_type;
    typedef ::xsd::cxx::tree::optional< vendor_type > vendor_optional;
    typedef ::xsd::cxx::tree::traits< vendor_type, char > vendor_traits;

    const vendor_optional&
    vendor () const;

    vendor_optional&
    vendor ();

    void
    vendor (const vendor_type& x);

    void
    vendor (const vendor_optional& x);

    void
    vendor (::std::auto_ptr< vendor_type > p);

    // version
    // 
    typedef ::xml_schema::string version_type;
    typedef ::xsd::cxx::tree::optional< version_type > version_optional;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_optional&
    version () const;

    version_optional&
    version ();

    void
    version (const version_type& x);

    void
    version (const version_optional& x);

    void
    version (::std::auto_ptr< version_type > p);

    // family
    // 
    typedef ::xml_schema::string family_type;
    typedef ::xsd::cxx::tree::optional< family_type > family_optional;
    typedef ::xsd::cxx::tree::traits< family_type, char > family_traits;

    const family_optional&
    family () const;

    family_optional&
    family ();

    void
    family (const family_type& x);

    void
    family (const family_optional& x);

    void
    family (::std::auto_ptr< family_type > p);

    // Constructors.
    //
    codecType ();

    codecType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    codecType (const codecType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual codecType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~codecType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    codecIdentifier_optional codecIdentifier_;
    name_optional name_;
    vendor_optional vendor_;
    version_optional version_;
    family_optional family_;
  };

  class timeType: public ::xml_schema::type
  {
    public:
    // timecode
    // 
    typedef ::ebuCore_2012::timecode timecode_type;
    typedef ::xsd::cxx::tree::optional< timecode_type > timecode_optional;
    typedef ::xsd::cxx::tree::traits< timecode_type, char > timecode_traits;

    const timecode_optional&
    timecode () const;

    timecode_optional&
    timecode ();

    void
    timecode (const timecode_type& x);

    void
    timecode (const timecode_optional& x);

    void
    timecode (::std::auto_ptr< timecode_type > p);

    // normalPlayTime
    // 
    typedef ::xml_schema::time normalPlayTime_type;
    typedef ::xsd::cxx::tree::optional< normalPlayTime_type > normalPlayTime_optional;
    typedef ::xsd::cxx::tree::traits< normalPlayTime_type, char > normalPlayTime_traits;

    const normalPlayTime_optional&
    normalPlayTime () const;

    normalPlayTime_optional&
    normalPlayTime ();

    void
    normalPlayTime (const normalPlayTime_type& x);

    void
    normalPlayTime (const normalPlayTime_optional& x);

    void
    normalPlayTime (::std::auto_ptr< normalPlayTime_type > p);

    // editUnitNumber
    // 
    typedef ::ebuCore_2012::editUnitNumberType editUnitNumber_type;
    typedef ::xsd::cxx::tree::optional< editUnitNumber_type > editUnitNumber_optional;
    typedef ::xsd::cxx::tree::traits< editUnitNumber_type, char > editUnitNumber_traits;

    const editUnitNumber_optional&
    editUnitNumber () const;

    editUnitNumber_optional&
    editUnitNumber ();

    void
    editUnitNumber (const editUnitNumber_type& x);

    void
    editUnitNumber (const editUnitNumber_optional& x);

    void
    editUnitNumber (::std::auto_ptr< editUnitNumber_type > p);

    // time
    // 
    typedef ::ebuCore_2012::time time_type;
    typedef ::xsd::cxx::tree::optional< time_type > time_optional;
    typedef ::xsd::cxx::tree::traits< time_type, char > time_traits;

    const time_optional&
    time () const;

    time_optional&
    time ();

    void
    time (const time_type& x);

    void
    time (const time_optional& x);

    void
    time (::std::auto_ptr< time_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    timeType ();

    timeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    timeType (const timeType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual timeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~timeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    timecode_optional timecode_;
    normalPlayTime_optional normalPlayTime_;
    editUnitNumber_optional editUnitNumber_;
    time_optional time_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class durationType: public ::xml_schema::type
  {
    public:
    // timecode
    // 
    typedef ::ebuCore_2012::timecode1 timecode_type;
    typedef ::xsd::cxx::tree::optional< timecode_type > timecode_optional;
    typedef ::xsd::cxx::tree::traits< timecode_type, char > timecode_traits;

    const timecode_optional&
    timecode () const;

    timecode_optional&
    timecode ();

    void
    timecode (const timecode_type& x);

    void
    timecode (const timecode_optional& x);

    void
    timecode (::std::auto_ptr< timecode_type > p);

    // normalPlayTime
    // 
    typedef ::xml_schema::duration normalPlayTime_type;
    typedef ::xsd::cxx::tree::optional< normalPlayTime_type > normalPlayTime_optional;
    typedef ::xsd::cxx::tree::traits< normalPlayTime_type, char > normalPlayTime_traits;

    const normalPlayTime_optional&
    normalPlayTime () const;

    normalPlayTime_optional&
    normalPlayTime ();

    void
    normalPlayTime (const normalPlayTime_type& x);

    void
    normalPlayTime (const normalPlayTime_optional& x);

    void
    normalPlayTime (::std::auto_ptr< normalPlayTime_type > p);

    // editUnitNumber
    // 
    typedef ::ebuCore_2012::editUnitNumberType editUnitNumber_type;
    typedef ::xsd::cxx::tree::optional< editUnitNumber_type > editUnitNumber_optional;
    typedef ::xsd::cxx::tree::traits< editUnitNumber_type, char > editUnitNumber_traits;

    const editUnitNumber_optional&
    editUnitNumber () const;

    editUnitNumber_optional&
    editUnitNumber ();

    void
    editUnitNumber (const editUnitNumber_type& x);

    void
    editUnitNumber (const editUnitNumber_optional& x);

    void
    editUnitNumber (::std::auto_ptr< editUnitNumber_type > p);

    // duration
    // 
    typedef ::ebuCore_2012::duration duration_type;
    typedef ::xsd::cxx::tree::optional< duration_type > duration_optional;
    typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

    const duration_optional&
    duration () const;

    duration_optional&
    duration ();

    void
    duration (const duration_type& x);

    void
    duration (const duration_optional& x);

    void
    duration (::std::auto_ptr< duration_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    durationType ();

    durationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    durationType (const durationType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual durationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~durationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    timecode_optional timecode_;
    normalPlayTime_optional normalPlayTime_;
    editUnitNumber_optional editUnitNumber_;
    duration_optional duration_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class hashType: public ::xml_schema::type
  {
    public:
    // hashValue
    // 
    typedef ::xml_schema::hex_binary hashValue_type;
    typedef ::xsd::cxx::tree::traits< hashValue_type, char > hashValue_traits;

    const hashValue_type&
    hashValue () const;

    hashValue_type&
    hashValue ();

    void
    hashValue (const hashValue_type& x);

    void
    hashValue (::std::auto_ptr< hashValue_type > p);

    // hashFunction
    // 
    typedef ::ebuCore_2012::hashFunction hashFunction_type;
    typedef ::xsd::cxx::tree::traits< hashFunction_type, char > hashFunction_traits;

    const hashFunction_type&
    hashFunction () const;

    hashFunction_type&
    hashFunction ();

    void
    hashFunction (const hashFunction_type& x);

    void
    hashFunction (::std::auto_ptr< hashFunction_type > p);

    // Constructors.
    //
    hashType (const hashValue_type&,
              const hashFunction_type&);

    hashType (const hashValue_type&,
              ::std::auto_ptr< hashFunction_type >&);

    hashType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    hashType (const hashType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual hashType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~hashType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< hashValue_type > hashValue_;
    ::xsd::cxx::tree::one< hashFunction_type > hashFunction_;
  };

  class String: public ::xml_schema::string
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // Constructors.
    //
    String ();

    String (const char*);

    String (const ::std::string&);

    String (const ::xml_schema::string&);

    String (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    String (const String& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual String*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~String ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
  };

  class Boolean: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    Boolean (const ::xml_schema::boolean&);

    Boolean (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Boolean (const Boolean& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Boolean*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Boolean ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class Float: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    Float (const ::xml_schema::double_&);

    Float (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Float (const Float& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Float*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Float ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class Int8: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::byte, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    Int8 (const ::xml_schema::byte&);

    Int8 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Int8 (const Int8& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Int8*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Int8 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class Int16: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::short_, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    Int16 (const ::xml_schema::short_&);

    Int16 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Int16 (const Int16& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Int16*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Int16 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class Int32: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    Int32 (const ::xml_schema::integer&);

    Int32 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Int32 (const Int32& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Int32*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Int32 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class Int64: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    Int64 (const ::xml_schema::long_&);

    Int64 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Int64 (const Int64& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Int64*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Int64 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class UInt8: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    UInt8 (const ::xml_schema::unsigned_byte&);

    UInt8 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    UInt8 (const UInt8& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual UInt8*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UInt8 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class UInt16: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    UInt16 (const ::xml_schema::unsigned_short&);

    UInt16 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    UInt16 (const UInt16& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual UInt16*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UInt16 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class UInt32: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    UInt32 (const ::xml_schema::unsigned_int&);

    UInt32 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    UInt32 (const UInt32& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual UInt32*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UInt32 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class UInt64: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_long, char, ::xml_schema::simple_type >
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    UInt64 (const ::xml_schema::unsigned_long&);

    UInt64 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    UInt64 (const UInt64& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual UInt64*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UInt64 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class rationalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::long_, char, ::xml_schema::simple_type >
  {
    public:
    // factorNumerator
    // 
    typedef ::xml_schema::integer factorNumerator_type;
    typedef ::xsd::cxx::tree::traits< factorNumerator_type, char > factorNumerator_traits;

    const factorNumerator_type&
    factorNumerator () const;

    factorNumerator_type&
    factorNumerator ();

    void
    factorNumerator (const factorNumerator_type& x);

    static factorNumerator_type
    factorNumerator_default_value ();

    // factorDenominator
    // 
    typedef ::xml_schema::integer factorDenominator_type;
    typedef ::xsd::cxx::tree::traits< factorDenominator_type, char > factorDenominator_traits;

    const factorDenominator_type&
    factorDenominator () const;

    factorDenominator_type&
    factorDenominator ();

    void
    factorDenominator (const factorDenominator_type& x);

    static factorDenominator_type
    factorDenominator_default_value ();

    // Constructors.
    //
    rationalType (const ::xml_schema::long_&);

    rationalType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    rationalType (const rationalType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual rationalType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~rationalType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< factorNumerator_type > factorNumerator_;
    ::xsd::cxx::tree::one< factorDenominator_type > factorDenominator_;
  };

  class aspectRatioType: public ::xml_schema::type
  {
    public:
    // factorNumerator
    // 
    typedef ::xml_schema::integer factorNumerator_type;
    typedef ::xsd::cxx::tree::traits< factorNumerator_type, char > factorNumerator_traits;

    const factorNumerator_type&
    factorNumerator () const;

    factorNumerator_type&
    factorNumerator ();

    void
    factorNumerator (const factorNumerator_type& x);

    static factorNumerator_type
    factorNumerator_default_value ();

    // factorDenominator
    // 
    typedef ::xml_schema::integer factorDenominator_type;
    typedef ::xsd::cxx::tree::traits< factorDenominator_type, char > factorDenominator_traits;

    const factorDenominator_type&
    factorDenominator () const;

    factorDenominator_type&
    factorDenominator ();

    void
    factorDenominator (const factorDenominator_type& x);

    static factorDenominator_type
    factorDenominator_default_value ();

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    aspectRatioType (const factorNumerator_type&,
                     const factorDenominator_type&);

    aspectRatioType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    aspectRatioType (const aspectRatioType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual aspectRatioType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~aspectRatioType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< factorNumerator_type > factorNumerator_;
    ::xsd::cxx::tree::one< factorDenominator_type > factorDenominator_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class technicalAttributeRationalType: public ::ebuCore_2012::rationalType
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    technicalAttributeRationalType (const ::xml_schema::long_&);

    technicalAttributeRationalType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    technicalAttributeRationalType (const technicalAttributeRationalType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual technicalAttributeRationalType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~technicalAttributeRationalType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class technicalAttributeUriType: public ::xml_schema::uri
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    technicalAttributeUriType (const ::xml_schema::uri&);

    technicalAttributeUriType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    technicalAttributeUriType (const technicalAttributeUriType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual technicalAttributeUriType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~technicalAttributeUriType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class versionType: public ::dc::elementType
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    versionType ();

    versionType (const char*);

    versionType (const ::std::string&);

    versionType (const ::xml_schema::string&);

    versionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    versionType (const versionType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual versionType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~versionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class hasTrackPart: public ::ebuCore_2012::relationType
  {
    public:
    // trackPartTitle
    // 
    typedef ::ebuCore_2012::alternativeTitleType trackPartTitle_type;
    typedef ::xsd::cxx::tree::traits< trackPartTitle_type, char > trackPartTitle_traits;

    const trackPartTitle_type&
    trackPartTitle () const;

    trackPartTitle_type&
    trackPartTitle ();

    void
    trackPartTitle (const trackPartTitle_type& x);

    void
    trackPartTitle (::std::auto_ptr< trackPartTitle_type > p);

    // destinationId
    // 
    typedef ::xml_schema::uri destinationId_type;
    typedef ::xsd::cxx::tree::optional< destinationId_type > destinationId_optional;
    typedef ::xsd::cxx::tree::traits< destinationId_type, char > destinationId_traits;

    const destinationId_optional&
    destinationId () const;

    destinationId_optional&
    destinationId ();

    void
    destinationId (const destinationId_type& x);

    void
    destinationId (const destinationId_optional& x);

    void
    destinationId (::std::auto_ptr< destinationId_type > p);

    // destinationStart
    // 
    typedef ::ebuCore_2012::timeType destinationStart_type;
    typedef ::xsd::cxx::tree::optional< destinationStart_type > destinationStart_optional;
    typedef ::xsd::cxx::tree::traits< destinationStart_type, char > destinationStart_traits;

    const destinationStart_optional&
    destinationStart () const;

    destinationStart_optional&
    destinationStart ();

    void
    destinationStart (const destinationStart_type& x);

    void
    destinationStart (const destinationStart_optional& x);

    void
    destinationStart (::std::auto_ptr< destinationStart_type > p);

    // destinationEnd
    // 
    typedef ::ebuCore_2012::timeType destinationEnd_type;
    typedef ::xsd::cxx::tree::optional< destinationEnd_type > destinationEnd_optional;
    typedef ::xsd::cxx::tree::traits< destinationEnd_type, char > destinationEnd_traits;

    const destinationEnd_optional&
    destinationEnd () const;

    destinationEnd_optional&
    destinationEnd ();

    void
    destinationEnd (const destinationEnd_type& x);

    void
    destinationEnd (const destinationEnd_optional& x);

    void
    destinationEnd (::std::auto_ptr< destinationEnd_type > p);

    // sourceId
    // 
    typedef ::xml_schema::uri sourceId_type;
    typedef ::xsd::cxx::tree::optional< sourceId_type > sourceId_optional;
    typedef ::xsd::cxx::tree::traits< sourceId_type, char > sourceId_traits;

    const sourceId_optional&
    sourceId () const;

    sourceId_optional&
    sourceId ();

    void
    sourceId (const sourceId_type& x);

    void
    sourceId (const sourceId_optional& x);

    void
    sourceId (::std::auto_ptr< sourceId_type > p);

    // sourceStart
    // 
    typedef ::ebuCore_2012::timeType sourceStart_type;
    typedef ::xsd::cxx::tree::optional< sourceStart_type > sourceStart_optional;
    typedef ::xsd::cxx::tree::traits< sourceStart_type, char > sourceStart_traits;

    const sourceStart_optional&
    sourceStart () const;

    sourceStart_optional&
    sourceStart ();

    void
    sourceStart (const sourceStart_type& x);

    void
    sourceStart (const sourceStart_optional& x);

    void
    sourceStart (::std::auto_ptr< sourceStart_type > p);

    // sourceEnd
    // 
    typedef ::ebuCore_2012::timeType sourceEnd_type;
    typedef ::xsd::cxx::tree::optional< sourceEnd_type > sourceEnd_optional;
    typedef ::xsd::cxx::tree::traits< sourceEnd_type, char > sourceEnd_traits;

    const sourceEnd_optional&
    sourceEnd () const;

    sourceEnd_optional&
    sourceEnd ();

    void
    sourceEnd (const sourceEnd_type& x);

    void
    sourceEnd (const sourceEnd_optional& x);

    void
    sourceEnd (::std::auto_ptr< sourceEnd_type > p);

    // Constructors.
    //
    hasTrackPart (const trackPartTitle_type&);

    hasTrackPart (::std::auto_ptr< trackPartTitle_type >&);

    hasTrackPart (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    hasTrackPart (const hasTrackPart& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual hasTrackPart*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~hasTrackPart ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< trackPartTitle_type > trackPartTitle_;
    destinationId_optional destinationId_;
    destinationStart_optional destinationStart_;
    destinationEnd_optional destinationEnd_;
    sourceId_optional sourceId_;
    sourceStart_optional sourceStart_;
    sourceEnd_optional sourceEnd_;
  };

  class genre: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    genre ();

    genre (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    genre (const genre& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual genre*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~genre ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class objectType: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    objectType ();

    objectType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    objectType (const objectType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual objectType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~objectType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class targetAudience: public ::xml_schema::type
  {
    public:
    // targetRegion
    // 
    typedef ::ebuCore_2012::regionType targetRegion_type;
    typedef ::xsd::cxx::tree::sequence< targetRegion_type > targetRegion_sequence;
    typedef targetRegion_sequence::iterator targetRegion_iterator;
    typedef targetRegion_sequence::const_iterator targetRegion_const_iterator;
    typedef ::xsd::cxx::tree::traits< targetRegion_type, char > targetRegion_traits;

    const targetRegion_sequence&
    targetRegion () const;

    targetRegion_sequence&
    targetRegion ();

    void
    targetRegion (const targetRegion_sequence& s);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // reason
    // 
    typedef ::xml_schema::string reason_type;
    typedef ::xsd::cxx::tree::optional< reason_type > reason_optional;
    typedef ::xsd::cxx::tree::traits< reason_type, char > reason_traits;

    const reason_optional&
    reason () const;

    reason_optional&
    reason ();

    void
    reason (const reason_type& x);

    void
    reason (const reason_optional& x);

    void
    reason (::std::auto_ptr< reason_type > p);

    // linkToLogo
    // 
    typedef ::xml_schema::uri linkToLogo_type;
    typedef ::xsd::cxx::tree::optional< linkToLogo_type > linkToLogo_optional;
    typedef ::xsd::cxx::tree::traits< linkToLogo_type, char > linkToLogo_traits;

    const linkToLogo_optional&
    linkToLogo () const;

    linkToLogo_optional&
    linkToLogo ();

    void
    linkToLogo (const linkToLogo_type& x);

    void
    linkToLogo (const linkToLogo_optional& x);

    void
    linkToLogo (::std::auto_ptr< linkToLogo_type > p);

    // notRated
    // 
    typedef ::xml_schema::boolean notRated_type;
    typedef ::xsd::cxx::tree::optional< notRated_type > notRated_optional;
    typedef ::xsd::cxx::tree::traits< notRated_type, char > notRated_traits;

    const notRated_optional&
    notRated () const;

    notRated_optional&
    notRated ();

    void
    notRated (const notRated_type& x);

    void
    notRated (const notRated_optional& x);

    // adultContent
    // 
    typedef ::xml_schema::boolean adultContent_type;
    typedef ::xsd::cxx::tree::optional< adultContent_type > adultContent_optional;
    typedef ::xsd::cxx::tree::traits< adultContent_type, char > adultContent_traits;

    const adultContent_optional&
    adultContent () const;

    adultContent_optional&
    adultContent ();

    void
    adultContent (const adultContent_type& x);

    void
    adultContent (const adultContent_optional& x);

    // Constructors.
    //
    targetAudience ();

    targetAudience (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    targetAudience (const targetAudience& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual targetAudience*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~targetAudience ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    targetRegion_sequence targetRegion_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    reason_optional reason_;
    linkToLogo_optional linkToLogo_;
    notRated_optional notRated_;
    adultContent_optional adultContent_;
  };

  class temporal: public ::xml_schema::type
  {
    public:
    // PeriodOfTime
    // 
    typedef ::ebuCore_2012::periodOfTimeType PeriodOfTime_type;
    typedef ::xsd::cxx::tree::sequence< PeriodOfTime_type > PeriodOfTime_sequence;
    typedef PeriodOfTime_sequence::iterator PeriodOfTime_iterator;
    typedef PeriodOfTime_sequence::const_iterator PeriodOfTime_const_iterator;
    typedef ::xsd::cxx::tree::traits< PeriodOfTime_type, char > PeriodOfTime_traits;

    const PeriodOfTime_sequence&
    PeriodOfTime () const;

    PeriodOfTime_sequence&
    PeriodOfTime ();

    void
    PeriodOfTime (const PeriodOfTime_sequence& s);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // note
    // 
    typedef ::xml_schema::string note_type;
    typedef ::xsd::cxx::tree::optional< note_type > note_optional;
    typedef ::xsd::cxx::tree::traits< note_type, char > note_traits;

    const note_optional&
    note () const;

    note_optional&
    note ();

    void
    note (const note_type& x);

    void
    note (const note_optional& x);

    void
    note (::std::auto_ptr< note_type > p);

    // periodId
    // 
    typedef ::xml_schema::uri periodId_type;
    typedef ::xsd::cxx::tree::optional< periodId_type > periodId_optional;
    typedef ::xsd::cxx::tree::traits< periodId_type, char > periodId_traits;

    const periodId_optional&
    periodId () const;

    periodId_optional&
    periodId ();

    void
    periodId (const periodId_type& x);

    void
    periodId (const periodId_optional& x);

    void
    periodId (::std::auto_ptr< periodId_type > p);

    // Constructors.
    //
    temporal ();

    temporal (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    temporal (const temporal& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual temporal*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~temporal ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    PeriodOfTime_sequence PeriodOfTime_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    note_optional note_;
    periodId_optional periodId_;
  };

  class spatial: public ::xml_schema::type
  {
    public:
    // location
    // 
    typedef ::ebuCore_2012::locationType location_type;
    typedef ::xsd::cxx::tree::sequence< location_type > location_sequence;
    typedef location_sequence::iterator location_iterator;
    typedef location_sequence::const_iterator location_const_iterator;
    typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

    const location_sequence&
    location () const;

    location_sequence&
    location ();

    void
    location (const location_sequence& s);

    // Constructors.
    //
    spatial ();

    spatial (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    spatial (const spatial& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual spatial*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~spatial ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    location_sequence location_;
  };

  class coordinates: public ::xml_schema::type
  {
    public:
    // posy
    // 
    typedef ::xml_schema::float_ posy_type;
    typedef ::xsd::cxx::tree::traits< posy_type, char > posy_traits;

    const posy_type&
    posy () const;

    posy_type&
    posy ();

    void
    posy (const posy_type& x);

    // posx
    // 
    typedef ::xml_schema::float_ posx_type;
    typedef ::xsd::cxx::tree::traits< posx_type, char > posx_traits;

    const posx_type&
    posx () const;

    posx_type&
    posx ();

    void
    posx (const posx_type& x);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // Constructors.
    //
    coordinates (const posy_type&,
                 const posx_type&);

    coordinates (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    coordinates (const coordinates& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual coordinates*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~coordinates ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< posy_type > posy_;
    ::xsd::cxx::tree::one< posx_type > posx_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
  };

  class created: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // Constructors.
    //
    created ();

    created (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    created (const created& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual created*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~created ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
  };

  class issued: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // Constructors.
    //
    issued ();

    issued (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    issued (const issued& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual issued*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~issued ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
  };

  class modified: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // Constructors.
    //
    modified ();

    modified (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    modified (const modified& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual modified*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~modified ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
  };

  class digitised: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // Constructors.
    //
    digitised ();

    digitised (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    digitised (const digitised& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual digitised*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~digitised ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
  };

  class released: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // Constructors.
    //
    released ();

    released (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    released (const released& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual released*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~released ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
  };

  class copyrighted: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // Constructors.
    //
    copyrighted ();

    copyrighted (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    copyrighted (const copyrighted& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual copyrighted*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~copyrighted ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
  };

  class alternative: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    alternative ();

    alternative (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    alternative (const alternative& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual alternative*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~alternative ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class medium: public ::xml_schema::type
  {
    public:
    // mediumId
    // 
    typedef ::xml_schema::uri mediumId_type;
    typedef ::xsd::cxx::tree::optional< mediumId_type > mediumId_optional;
    typedef ::xsd::cxx::tree::traits< mediumId_type, char > mediumId_traits;

    const mediumId_optional&
    mediumId () const;

    mediumId_optional&
    mediumId ();

    void
    mediumId (const mediumId_type& x);

    void
    mediumId (const mediumId_optional& x);

    void
    mediumId (::std::auto_ptr< mediumId_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    medium ();

    medium (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    medium (const medium& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual medium*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~medium ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    mediumId_optional mediumId_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class containerFormat: public ::xml_schema::type
  {
    public:
    // comment
    // 
    typedef ::dc::elementType comment_type;
    typedef ::xsd::cxx::tree::sequence< comment_type > comment_sequence;
    typedef comment_sequence::iterator comment_iterator;
    typedef comment_sequence::const_iterator comment_const_iterator;
    typedef ::xsd::cxx::tree::traits< comment_type, char > comment_traits;

    const comment_sequence&
    comment () const;

    comment_sequence&
    comment ();

    void
    comment (const comment_sequence& s);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // Constructors.
    //
    containerFormat ();

    containerFormat (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    containerFormat (const containerFormat& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual containerFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~containerFormat ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    comment_sequence comment_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
  };

  class signingFormat: public ::xml_schema::type
  {
    public:
    // signingFormatId
    // 
    typedef ::xml_schema::uri signingFormatId_type;
    typedef ::xsd::cxx::tree::optional< signingFormatId_type > signingFormatId_optional;
    typedef ::xsd::cxx::tree::traits< signingFormatId_type, char > signingFormatId_traits;

    const signingFormatId_optional&
    signingFormatId () const;

    signingFormatId_optional&
    signingFormatId ();

    void
    signingFormatId (const signingFormatId_type& x);

    void
    signingFormatId (const signingFormatId_optional& x);

    void
    signingFormatId (::std::auto_ptr< signingFormatId_type > p);

    // signingFormatVersionId
    // 
    typedef ::xml_schema::string signingFormatVersionId_type;
    typedef ::xsd::cxx::tree::optional< signingFormatVersionId_type > signingFormatVersionId_optional;
    typedef ::xsd::cxx::tree::traits< signingFormatVersionId_type, char > signingFormatVersionId_traits;

    const signingFormatVersionId_optional&
    signingFormatVersionId () const;

    signingFormatVersionId_optional&
    signingFormatVersionId ();

    void
    signingFormatVersionId (const signingFormatVersionId_type& x);

    void
    signingFormatVersionId (const signingFormatVersionId_optional& x);

    void
    signingFormatVersionId (::std::auto_ptr< signingFormatVersionId_type > p);

    // signingFormatName
    // 
    typedef ::xml_schema::string signingFormatName_type;
    typedef ::xsd::cxx::tree::optional< signingFormatName_type > signingFormatName_optional;
    typedef ::xsd::cxx::tree::traits< signingFormatName_type, char > signingFormatName_traits;

    const signingFormatName_optional&
    signingFormatName () const;

    signingFormatName_optional&
    signingFormatName ();

    void
    signingFormatName (const signingFormatName_type& x);

    void
    signingFormatName (const signingFormatName_optional& x);

    void
    signingFormatName (::std::auto_ptr< signingFormatName_type > p);

    // trackId
    // 
    typedef ::xml_schema::nmtoken trackId_type;
    typedef ::xsd::cxx::tree::optional< trackId_type > trackId_optional;
    typedef ::xsd::cxx::tree::traits< trackId_type, char > trackId_traits;

    const trackId_optional&
    trackId () const;

    trackId_optional&
    trackId ();

    void
    trackId (const trackId_type& x);

    void
    trackId (const trackId_optional& x);

    void
    trackId (::std::auto_ptr< trackId_type > p);

    // trackName
    // 
    typedef ::xml_schema::string trackName_type;
    typedef ::xsd::cxx::tree::optional< trackName_type > trackName_optional;
    typedef ::xsd::cxx::tree::traits< trackName_type, char > trackName_traits;

    const trackName_optional&
    trackName () const;

    trackName_optional&
    trackName ();

    void
    trackName (const trackName_type& x);

    void
    trackName (const trackName_optional& x);

    void
    trackName (::std::auto_ptr< trackName_type > p);

    // signingSourceUri
    // 
    typedef ::xml_schema::uri signingSourceUri_type;
    typedef ::xsd::cxx::tree::optional< signingSourceUri_type > signingSourceUri_optional;
    typedef ::xsd::cxx::tree::traits< signingSourceUri_type, char > signingSourceUri_traits;

    const signingSourceUri_optional&
    signingSourceUri () const;

    signingSourceUri_optional&
    signingSourceUri ();

    void
    signingSourceUri (const signingSourceUri_type& x);

    void
    signingSourceUri (const signingSourceUri_optional& x);

    void
    signingSourceUri (::std::auto_ptr< signingSourceUri_type > p);

    // language
    // 
    typedef ::xml_schema::language language_type;
    typedef ::xsd::cxx::tree::optional< language_type > language_optional;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_optional&
    language () const;

    language_optional&
    language ();

    void
    language (const language_type& x);

    void
    language (const language_optional& x);

    void
    language (::std::auto_ptr< language_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // Constructors.
    //
    signingFormat ();

    signingFormat (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    signingFormat (const signingFormat& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual signingFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~signingFormat ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    signingFormatId_optional signingFormatId_;
    signingFormatVersionId_optional signingFormatVersionId_;
    signingFormatName_optional signingFormatName_;
    trackId_optional trackId_;
    trackName_optional trackName_;
    signingSourceUri_optional signingSourceUri_;
    language_optional language_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
  };

  class dateCreated: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // Constructors.
    //
    dateCreated ();

    dateCreated (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    dateCreated (const dateCreated& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual dateCreated*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~dateCreated ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
  };

  class dateModified: public ::xml_schema::type
  {
    public:
    // startYear
    // 
    typedef ::xml_schema::gyear startYear_type;
    typedef ::xsd::cxx::tree::optional< startYear_type > startYear_optional;
    typedef ::xsd::cxx::tree::traits< startYear_type, char > startYear_traits;

    const startYear_optional&
    startYear () const;

    startYear_optional&
    startYear ();

    void
    startYear (const startYear_type& x);

    void
    startYear (const startYear_optional& x);

    void
    startYear (::std::auto_ptr< startYear_type > p);

    // startDate
    // 
    typedef ::xml_schema::date startDate_type;
    typedef ::xsd::cxx::tree::optional< startDate_type > startDate_optional;
    typedef ::xsd::cxx::tree::traits< startDate_type, char > startDate_traits;

    const startDate_optional&
    startDate () const;

    startDate_optional&
    startDate ();

    void
    startDate (const startDate_type& x);

    void
    startDate (const startDate_optional& x);

    void
    startDate (::std::auto_ptr< startDate_type > p);

    // startTime
    // 
    typedef ::xml_schema::time startTime_type;
    typedef ::xsd::cxx::tree::optional< startTime_type > startTime_optional;
    typedef ::xsd::cxx::tree::traits< startTime_type, char > startTime_traits;

    const startTime_optional&
    startTime () const;

    startTime_optional&
    startTime ();

    void
    startTime (const startTime_type& x);

    void
    startTime (const startTime_optional& x);

    void
    startTime (::std::auto_ptr< startTime_type > p);

    // endYear
    // 
    typedef ::xml_schema::gyear endYear_type;
    typedef ::xsd::cxx::tree::optional< endYear_type > endYear_optional;
    typedef ::xsd::cxx::tree::traits< endYear_type, char > endYear_traits;

    const endYear_optional&
    endYear () const;

    endYear_optional&
    endYear ();

    void
    endYear (const endYear_type& x);

    void
    endYear (const endYear_optional& x);

    void
    endYear (::std::auto_ptr< endYear_type > p);

    // endDate
    // 
    typedef ::xml_schema::date endDate_type;
    typedef ::xsd::cxx::tree::optional< endDate_type > endDate_optional;
    typedef ::xsd::cxx::tree::traits< endDate_type, char > endDate_traits;

    const endDate_optional&
    endDate () const;

    endDate_optional&
    endDate ();

    void
    endDate (const endDate_type& x);

    void
    endDate (const endDate_optional& x);

    void
    endDate (::std::auto_ptr< endDate_type > p);

    // endTime
    // 
    typedef ::xml_schema::time endTime_type;
    typedef ::xsd::cxx::tree::optional< endTime_type > endTime_optional;
    typedef ::xsd::cxx::tree::traits< endTime_type, char > endTime_traits;

    const endTime_optional&
    endTime () const;

    endTime_optional&
    endTime ();

    void
    endTime (const endTime_type& x);

    void
    endTime (const endTime_optional& x);

    void
    endTime (::std::auto_ptr< endTime_type > p);

    // Constructors.
    //
    dateModified ();

    dateModified (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    dateModified (const dateModified& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual dateModified*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~dateModified ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    startYear_optional startYear_;
    startDate_optional startDate_;
    startTime_optional startTime_;
    endYear_optional endYear_;
    endDate_optional endDate_;
    endTime_optional endTime_;
  };

  class role: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // costCentre
    // 
    typedef ::xml_schema::simple_type costCentre_type;
    typedef ::xsd::cxx::tree::optional< costCentre_type > costCentre_optional;
    typedef ::xsd::cxx::tree::traits< costCentre_type, char > costCentre_traits;

    const costCentre_optional&
    costCentre () const;

    costCentre_optional&
    costCentre ();

    void
    costCentre (const costCentre_type& x);

    void
    costCentre (const costCentre_optional& x);

    void
    costCentre (::std::auto_ptr< costCentre_type > p);

    // Constructors.
    //
    role ();

    role (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    role (const role& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual role*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~role ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    costCentre_optional costCentre_;
  };

  class relatedInformationLink: public ::xml_schema::uri
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    relatedInformationLink (const ::xml_schema::uri&);

    relatedInformationLink (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    relatedInformationLink (const relatedInformationLink& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual relatedInformationLink*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~relatedInformationLink ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class organisationDepartment: public ::dc::elementType
  {
    public:
    // departmentId
    // 
    typedef ::xml_schema::uri departmentId_type;
    typedef ::xsd::cxx::tree::optional< departmentId_type > departmentId_optional;
    typedef ::xsd::cxx::tree::traits< departmentId_type, char > departmentId_traits;

    const departmentId_optional&
    departmentId () const;

    departmentId_optional&
    departmentId ();

    void
    departmentId (const departmentId_type& x);

    void
    departmentId (const departmentId_optional& x);

    void
    departmentId (::std::auto_ptr< departmentId_type > p);

    // Constructors.
    //
    organisationDepartment ();

    organisationDepartment (const char*);

    organisationDepartment (const ::std::string&);

    organisationDepartment (const ::xml_schema::string&);

    organisationDepartment (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    organisationDepartment (const organisationDepartment& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual organisationDepartment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~organisationDepartment ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    departmentId_optional departmentId_;
  };

  class relatedInformationLink1: public ::xml_schema::uri
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    relatedInformationLink1 (const ::xml_schema::uri&);

    relatedInformationLink1 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    relatedInformationLink1 (const relatedInformationLink1& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual relatedInformationLink1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~relatedInformationLink1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class country: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    country ();

    country (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    country (const country& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual country*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~country ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class country1: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    country1 ();

    country1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    country1 (const country1& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual country1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~country1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class countryRegion: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    countryRegion ();

    countryRegion (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    countryRegion (const countryRegion& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual countryRegion*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~countryRegion ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class orientation: public ::xml_schema::string
  {
    public:
    enum value
    {
      landscape,
      portrait
    };

    orientation (value v);

    orientation (const char* v);

    orientation (const ::std::string& v);

    orientation (const ::xml_schema::string& v);

    orientation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    orientation (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    orientation (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    orientation (const orientation& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual orientation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    orientation&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_orientation_convert ();
    }

    protected:
    value
    _xsd_orientation_convert () const;

    public:
    static const char* const _xsd_orientation_literals_[2];
    static const value _xsd_orientation_indexes_[2];
  };

  class imageEncoding: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    imageEncoding ();

    imageEncoding (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    imageEncoding (const imageEncoding& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual imageEncoding*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~imageEncoding ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class comment: public ::dc::elementType
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    comment ();

    comment (const char*);

    comment (const ::std::string&);

    comment (const ::xml_schema::string&);

    comment (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    comment (const comment& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual comment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~comment ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class width: public ::ebuCore_2012::dimensionType
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    width (const ::xml_schema::non_negative_integer&);

    width (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    width (const width& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual width*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~width ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class height: public ::ebuCore_2012::dimensionType
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    height (const ::xml_schema::non_negative_integer&);

    height (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    height (const height& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual height*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~height ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class videoEncoding: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    videoEncoding ();

    videoEncoding (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    videoEncoding (const videoEncoding& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual videoEncoding*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~videoEncoding ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class bitRateMode: public ::xml_schema::string
  {
    public:
    enum value
    {
      none,
      constant,
      variable
    };

    bitRateMode (value v);

    bitRateMode (const char* v);

    bitRateMode (const ::std::string& v);

    bitRateMode (const ::xml_schema::string& v);

    bitRateMode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    bitRateMode (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    bitRateMode (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    bitRateMode (const bitRateMode& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual bitRateMode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    bitRateMode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_bitRateMode_convert ();
    }

    protected:
    value
    _xsd_bitRateMode_convert () const;

    public:
    static const char* const _xsd_bitRateMode_literals_[3];
    static const value _xsd_bitRateMode_indexes_[3];
  };

  class scanningFormat: public ::xml_schema::string
  {
    public:
    enum value
    {
      none,
      interlaced,
      progressive
    };

    scanningFormat (value v);

    scanningFormat (const char* v);

    scanningFormat (const ::std::string& v);

    scanningFormat (const ::xml_schema::string& v);

    scanningFormat (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    scanningFormat (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    scanningFormat (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    scanningFormat (const scanningFormat& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual scanningFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    scanningFormat&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_scanningFormat_convert ();
    }

    protected:
    value
    _xsd_scanningFormat_convert () const;

    public:
    static const char* const _xsd_scanningFormat_literals_[3];
    static const value _xsd_scanningFormat_indexes_[3];
  };

  class scanningOrder: public ::xml_schema::string
  {
    public:
    enum value
    {
      none,
      top,
      bottom
    };

    scanningOrder (value v);

    scanningOrder (const char* v);

    scanningOrder (const ::std::string& v);

    scanningOrder (const ::xml_schema::string& v);

    scanningOrder (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    scanningOrder (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    scanningOrder (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    scanningOrder (const scanningOrder& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual scanningOrder*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    scanningOrder&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_scanningOrder_convert ();
    }

    protected:
    value
    _xsd_scanningOrder_convert () const;

    public:
    static const char* const _xsd_scanningOrder_literals_[3];
    static const value _xsd_scanningOrder_indexes_[3];
  };

  class videoTrack: public ::xml_schema::type
  {
    public:
    // trackId
    // 
    typedef ::xml_schema::nmtoken trackId_type;
    typedef ::xsd::cxx::tree::optional< trackId_type > trackId_optional;
    typedef ::xsd::cxx::tree::traits< trackId_type, char > trackId_traits;

    const trackId_optional&
    trackId () const;

    trackId_optional&
    trackId ();

    void
    trackId (const trackId_type& x);

    void
    trackId (const trackId_optional& x);

    void
    trackId (::std::auto_ptr< trackId_type > p);

    // trackName
    // 
    typedef ::xml_schema::string trackName_type;
    typedef ::xsd::cxx::tree::optional< trackName_type > trackName_optional;
    typedef ::xsd::cxx::tree::traits< trackName_type, char > trackName_traits;

    const trackName_optional&
    trackName () const;

    trackName_optional&
    trackName ();

    void
    trackName (const trackName_type& x);

    void
    trackName (const trackName_optional& x);

    void
    trackName (::std::auto_ptr< trackName_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    videoTrack ();

    videoTrack (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    videoTrack (const videoTrack& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual videoTrack*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~videoTrack ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    trackId_optional trackId_;
    trackName_optional trackName_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class comment1: public ::dc::elementType
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    comment1 ();

    comment1 (const char*);

    comment1 (const ::std::string&);

    comment1 (const ::xml_schema::string&);

    comment1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    comment1 (const comment1& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual comment1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~comment1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class audioEncoding: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    audioEncoding ();

    audioEncoding (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    audioEncoding (const audioEncoding& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual audioEncoding*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~audioEncoding ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class audioTrackConfiguration: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    audioTrackConfiguration ();

    audioTrackConfiguration (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    audioTrackConfiguration (const audioTrackConfiguration& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual audioTrackConfiguration*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~audioTrackConfiguration ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class sampleType: public ::xml_schema::string
  {
    public:
    enum value
    {
      float_,
      integer
    };

    sampleType (value v);

    sampleType (const char* v);

    sampleType (const ::std::string& v);

    sampleType (const ::xml_schema::string& v);

    sampleType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    sampleType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    sampleType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    sampleType (const sampleType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual sampleType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    sampleType&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_sampleType_convert ();
    }

    protected:
    value
    _xsd_sampleType_convert () const;

    public:
    static const char* const _xsd_sampleType_literals_[2];
    static const value _xsd_sampleType_indexes_[2];
  };

  class bitRateMode1: public ::xml_schema::string
  {
    public:
    enum value
    {
      none,
      constant,
      variable
    };

    bitRateMode1 (value v);

    bitRateMode1 (const char* v);

    bitRateMode1 (const ::std::string& v);

    bitRateMode1 (const ::xml_schema::string& v);

    bitRateMode1 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    bitRateMode1 (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    bitRateMode1 (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    bitRateMode1 (const bitRateMode1& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual bitRateMode1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    bitRateMode1&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_bitRateMode1_convert ();
    }

    protected:
    value
    _xsd_bitRateMode1_convert () const;

    public:
    static const char* const _xsd_bitRateMode1_literals_[3];
    static const value _xsd_bitRateMode1_indexes_[3];
  };

  class audioTrack: public ::xml_schema::type
  {
    public:
    // trackLanguage
    // 
    typedef ::xml_schema::language trackLanguage_type;
    typedef ::xsd::cxx::tree::optional< trackLanguage_type > trackLanguage_optional;
    typedef ::xsd::cxx::tree::traits< trackLanguage_type, char > trackLanguage_traits;

    const trackLanguage_optional&
    trackLanguage () const;

    trackLanguage_optional&
    trackLanguage ();

    void
    trackLanguage (const trackLanguage_type& x);

    void
    trackLanguage (const trackLanguage_optional& x);

    void
    trackLanguage (::std::auto_ptr< trackLanguage_type > p);

    // trackId
    // 
    typedef ::xml_schema::nmtoken trackId_type;
    typedef ::xsd::cxx::tree::optional< trackId_type > trackId_optional;
    typedef ::xsd::cxx::tree::traits< trackId_type, char > trackId_traits;

    const trackId_optional&
    trackId () const;

    trackId_optional&
    trackId ();

    void
    trackId (const trackId_type& x);

    void
    trackId (const trackId_optional& x);

    void
    trackId (::std::auto_ptr< trackId_type > p);

    // trackName
    // 
    typedef ::xml_schema::string trackName_type;
    typedef ::xsd::cxx::tree::optional< trackName_type > trackName_optional;
    typedef ::xsd::cxx::tree::traits< trackName_type, char > trackName_traits;

    const trackName_optional&
    trackName () const;

    trackName_optional&
    trackName ();

    void
    trackName (const trackName_type& x);

    void
    trackName (const trackName_optional& x);

    void
    trackName (::std::auto_ptr< trackName_type > p);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    audioTrack ();

    audioTrack (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    audioTrack (const audioTrack& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual audioTrack*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~audioTrack ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    trackLanguage_optional trackLanguage_;
    trackId_optional trackId_;
    trackName_optional trackName_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class comment2: public ::dc::elementType
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    comment2 ();

    comment2 (const char*);

    comment2 (const ::std::string&);

    comment2 (const ::xml_schema::string&);

    comment2 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    comment2 (const comment2& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual comment2*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~comment2 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class captioningFormat: public ::xml_schema::type
  {
    public:
    // captioningFormatId
    // 
    typedef ::xml_schema::uri captioningFormatId_type;
    typedef ::xsd::cxx::tree::optional< captioningFormatId_type > captioningFormatId_optional;
    typedef ::xsd::cxx::tree::traits< captioningFormatId_type, char > captioningFormatId_traits;

    const captioningFormatId_optional&
    captioningFormatId () const;

    captioningFormatId_optional&
    captioningFormatId ();

    void
    captioningFormatId (const captioningFormatId_type& x);

    void
    captioningFormatId (const captioningFormatId_optional& x);

    void
    captioningFormatId (::std::auto_ptr< captioningFormatId_type > p);

    // captioningFormatName
    // 
    typedef ::xml_schema::string captioningFormatName_type;
    typedef ::xsd::cxx::tree::optional< captioningFormatName_type > captioningFormatName_optional;
    typedef ::xsd::cxx::tree::traits< captioningFormatName_type, char > captioningFormatName_traits;

    const captioningFormatName_optional&
    captioningFormatName () const;

    captioningFormatName_optional&
    captioningFormatName ();

    void
    captioningFormatName (const captioningFormatName_type& x);

    void
    captioningFormatName (const captioningFormatName_optional& x);

    void
    captioningFormatName (::std::auto_ptr< captioningFormatName_type > p);

    // trackId
    // 
    typedef ::xml_schema::nmtoken trackId_type;
    typedef ::xsd::cxx::tree::optional< trackId_type > trackId_optional;
    typedef ::xsd::cxx::tree::traits< trackId_type, char > trackId_traits;

    const trackId_optional&
    trackId () const;

    trackId_optional&
    trackId ();

    void
    trackId (const trackId_type& x);

    void
    trackId (const trackId_optional& x);

    void
    trackId (::std::auto_ptr< trackId_type > p);

    // trackName
    // 
    typedef ::xml_schema::string trackName_type;
    typedef ::xsd::cxx::tree::optional< trackName_type > trackName_optional;
    typedef ::xsd::cxx::tree::traits< trackName_type, char > trackName_traits;

    const trackName_optional&
    trackName () const;

    trackName_optional&
    trackName ();

    void
    trackName (const trackName_type& x);

    void
    trackName (const trackName_optional& x);

    void
    trackName (::std::auto_ptr< trackName_type > p);

    // captioningSourceUri
    // 
    typedef ::xml_schema::uri captioningSourceUri_type;
    typedef ::xsd::cxx::tree::optional< captioningSourceUri_type > captioningSourceUri_optional;
    typedef ::xsd::cxx::tree::traits< captioningSourceUri_type, char > captioningSourceUri_traits;

    const captioningSourceUri_optional&
    captioningSourceUri () const;

    captioningSourceUri_optional&
    captioningSourceUri ();

    void
    captioningSourceUri (const captioningSourceUri_type& x);

    void
    captioningSourceUri (const captioningSourceUri_optional& x);

    void
    captioningSourceUri (::std::auto_ptr< captioningSourceUri_type > p);

    // language
    // 
    typedef ::xml_schema::language language_type;
    typedef ::xsd::cxx::tree::optional< language_type > language_optional;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_optional&
    language () const;

    language_optional&
    language ();

    void
    language (const language_type& x);

    void
    language (const language_optional& x);

    void
    language (::std::auto_ptr< language_type > p);

    // closed
    // 
    typedef ::xml_schema::boolean closed_type;
    typedef ::xsd::cxx::tree::optional< closed_type > closed_optional;
    typedef ::xsd::cxx::tree::traits< closed_type, char > closed_traits;

    const closed_optional&
    closed () const;

    closed_optional&
    closed ();

    void
    closed (const closed_type& x);

    void
    closed (const closed_optional& x);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // Constructors.
    //
    captioningFormat ();

    captioningFormat (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    captioningFormat (const captioningFormat& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual captioningFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~captioningFormat ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    captioningFormatId_optional captioningFormatId_;
    captioningFormatName_optional captioningFormatName_;
    trackId_optional trackId_;
    trackName_optional trackName_;
    captioningSourceUri_optional captioningSourceUri_;
    language_optional language_;
    closed_optional closed_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
  };

  class subtitlingFormat: public ::xml_schema::type
  {
    public:
    // subtitlingFormatId
    // 
    typedef ::xml_schema::uri subtitlingFormatId_type;
    typedef ::xsd::cxx::tree::optional< subtitlingFormatId_type > subtitlingFormatId_optional;
    typedef ::xsd::cxx::tree::traits< subtitlingFormatId_type, char > subtitlingFormatId_traits;

    const subtitlingFormatId_optional&
    subtitlingFormatId () const;

    subtitlingFormatId_optional&
    subtitlingFormatId ();

    void
    subtitlingFormatId (const subtitlingFormatId_type& x);

    void
    subtitlingFormatId (const subtitlingFormatId_optional& x);

    void
    subtitlingFormatId (::std::auto_ptr< subtitlingFormatId_type > p);

    // subtitlingFormatName
    // 
    typedef ::xml_schema::string subtitlingFormatName_type;
    typedef ::xsd::cxx::tree::optional< subtitlingFormatName_type > subtitlingFormatName_optional;
    typedef ::xsd::cxx::tree::traits< subtitlingFormatName_type, char > subtitlingFormatName_traits;

    const subtitlingFormatName_optional&
    subtitlingFormatName () const;

    subtitlingFormatName_optional&
    subtitlingFormatName ();

    void
    subtitlingFormatName (const subtitlingFormatName_type& x);

    void
    subtitlingFormatName (const subtitlingFormatName_optional& x);

    void
    subtitlingFormatName (::std::auto_ptr< subtitlingFormatName_type > p);

    // trackId
    // 
    typedef ::xml_schema::nmtoken trackId_type;
    typedef ::xsd::cxx::tree::optional< trackId_type > trackId_optional;
    typedef ::xsd::cxx::tree::traits< trackId_type, char > trackId_traits;

    const trackId_optional&
    trackId () const;

    trackId_optional&
    trackId ();

    void
    trackId (const trackId_type& x);

    void
    trackId (const trackId_optional& x);

    void
    trackId (::std::auto_ptr< trackId_type > p);

    // trackName
    // 
    typedef ::xml_schema::string trackName_type;
    typedef ::xsd::cxx::tree::optional< trackName_type > trackName_optional;
    typedef ::xsd::cxx::tree::traits< trackName_type, char > trackName_traits;

    const trackName_optional&
    trackName () const;

    trackName_optional&
    trackName ();

    void
    trackName (const trackName_type& x);

    void
    trackName (const trackName_optional& x);

    void
    trackName (::std::auto_ptr< trackName_type > p);

    // subtitlingSourceUri
    // 
    typedef ::xml_schema::uri subtitlingSourceUri_type;
    typedef ::xsd::cxx::tree::optional< subtitlingSourceUri_type > subtitlingSourceUri_optional;
    typedef ::xsd::cxx::tree::traits< subtitlingSourceUri_type, char > subtitlingSourceUri_traits;

    const subtitlingSourceUri_optional&
    subtitlingSourceUri () const;

    subtitlingSourceUri_optional&
    subtitlingSourceUri ();

    void
    subtitlingSourceUri (const subtitlingSourceUri_type& x);

    void
    subtitlingSourceUri (const subtitlingSourceUri_optional& x);

    void
    subtitlingSourceUri (::std::auto_ptr< subtitlingSourceUri_type > p);

    // language
    // 
    typedef ::xml_schema::language language_type;
    typedef ::xsd::cxx::tree::optional< language_type > language_optional;
    typedef ::xsd::cxx::tree::traits< language_type, char > language_traits;

    const language_optional&
    language () const;

    language_optional&
    language ();

    void
    language (const language_type& x);

    void
    language (const language_optional& x);

    void
    language (::std::auto_ptr< language_type > p);

    // closed
    // 
    typedef ::xml_schema::boolean closed_type;
    typedef ::xsd::cxx::tree::optional< closed_type > closed_optional;
    typedef ::xsd::cxx::tree::traits< closed_type, char > closed_traits;

    const closed_optional&
    closed () const;

    closed_optional&
    closed ();

    void
    closed (const closed_type& x);

    void
    closed (const closed_optional& x);

    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // Constructors.
    //
    subtitlingFormat ();

    subtitlingFormat (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    subtitlingFormat (const subtitlingFormat& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual subtitlingFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~subtitlingFormat ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    subtitlingFormatId_optional subtitlingFormatId_;
    subtitlingFormatName_optional subtitlingFormatName_;
    trackId_optional trackId_;
    trackName_optional trackName_;
    subtitlingSourceUri_optional subtitlingSourceUri_;
    language_optional language_;
    closed_optional closed_;
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
  };

  class ancillaryDataFormat: public ::xml_schema::type
  {
    public:
    // DID
    // 
    typedef ::xml_schema::integer DID_type;
    typedef ::xsd::cxx::tree::optional< DID_type > DID_optional;
    typedef ::xsd::cxx::tree::traits< DID_type, char > DID_traits;

    const DID_optional&
    DID () const;

    DID_optional&
    DID ();

    void
    DID (const DID_type& x);

    void
    DID (const DID_optional& x);

    // SDID
    // 
    typedef ::xml_schema::integer SDID_type;
    typedef ::xsd::cxx::tree::optional< SDID_type > SDID_optional;
    typedef ::xsd::cxx::tree::traits< SDID_type, char > SDID_traits;

    const SDID_optional&
    SDID () const;

    SDID_optional&
    SDID ();

    void
    SDID (const SDID_type& x);

    void
    SDID (const SDID_optional& x);

    // lineNumber
    // 
    typedef ::xml_schema::integer lineNumber_type;
    typedef ::xsd::cxx::tree::sequence< lineNumber_type > lineNumber_sequence;
    typedef lineNumber_sequence::iterator lineNumber_iterator;
    typedef lineNumber_sequence::const_iterator lineNumber_const_iterator;
    typedef ::xsd::cxx::tree::traits< lineNumber_type, char > lineNumber_traits;

    const lineNumber_sequence&
    lineNumber () const;

    lineNumber_sequence&
    lineNumber ();

    void
    lineNumber (const lineNumber_sequence& s);

    // wrappingType
    // 
    typedef ::xml_schema::integer wrappingType_type;
    typedef ::xsd::cxx::tree::optional< wrappingType_type > wrappingType_optional;
    typedef ::xsd::cxx::tree::traits< wrappingType_type, char > wrappingType_traits;

    const wrappingType_optional&
    wrappingType () const;

    wrappingType_optional&
    wrappingType ();

    void
    wrappingType (const wrappingType_type& x);

    void
    wrappingType (const wrappingType_optional& x);

    // ancillaryDataFormatId
    // 
    typedef ::xml_schema::uri ancillaryDataFormatId_type;
    typedef ::xsd::cxx::tree::optional< ancillaryDataFormatId_type > ancillaryDataFormatId_optional;
    typedef ::xsd::cxx::tree::traits< ancillaryDataFormatId_type, char > ancillaryDataFormatId_traits;

    const ancillaryDataFormatId_optional&
    ancillaryDataFormatId () const;

    ancillaryDataFormatId_optional&
    ancillaryDataFormatId ();

    void
    ancillaryDataFormatId (const ancillaryDataFormatId_type& x);

    void
    ancillaryDataFormatId (const ancillaryDataFormatId_optional& x);

    void
    ancillaryDataFormatId (::std::auto_ptr< ancillaryDataFormatId_type > p);

    // ancillaryDataFormatName
    // 
    typedef ::xml_schema::string ancillaryDataFormatName_type;
    typedef ::xsd::cxx::tree::optional< ancillaryDataFormatName_type > ancillaryDataFormatName_optional;
    typedef ::xsd::cxx::tree::traits< ancillaryDataFormatName_type, char > ancillaryDataFormatName_traits;

    const ancillaryDataFormatName_optional&
    ancillaryDataFormatName () const;

    ancillaryDataFormatName_optional&
    ancillaryDataFormatName ();

    void
    ancillaryDataFormatName (const ancillaryDataFormatName_type& x);

    void
    ancillaryDataFormatName (const ancillaryDataFormatName_optional& x);

    void
    ancillaryDataFormatName (::std::auto_ptr< ancillaryDataFormatName_type > p);

    // Constructors.
    //
    ancillaryDataFormat ();

    ancillaryDataFormat (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ancillaryDataFormat (const ancillaryDataFormat& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ancillaryDataFormat*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ancillaryDataFormat ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DID_optional DID_;
    SDID_optional SDID_;
    lineNumber_sequence lineNumber_;
    wrappingType_optional wrappingType_;
    ancillaryDataFormatId_optional ancillaryDataFormatId_;
    ancillaryDataFormatName_optional ancillaryDataFormatName_;
  };

  class comment3: public ::dc::elementType
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    comment3 ();

    comment3 (const char*);

    comment3 (const ::std::string&);

    comment3 (const ::xml_schema::string&);

    comment3 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    comment3 (const comment3& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual comment3*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~comment3 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class comment4: public ::dc::elementType
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    comment4 ();

    comment4 (const char*);

    comment4 (const ::std::string&);

    comment4 (const ::xml_schema::string&);

    comment4 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    comment4 (const comment4& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual comment4*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~comment4 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class timecode: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    timecode ();

    timecode (const char*);

    timecode (const ::std::string&);

    timecode (const ::xml_schema::string&);

    timecode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    timecode (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    timecode (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    timecode (const timecode& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual timecode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~timecode ();
  };

  class time: public ::xml_schema::string
  {
    public:
    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // Constructors.
    //
    time ();

    time (const char*);

    time (const ::std::string&);

    time (const ::xml_schema::string&);

    time (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    time (const time& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual time*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~time ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
  };

  class timecode1: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    timecode1 ();

    timecode1 (const char*);

    timecode1 (const ::std::string&);

    timecode1 (const ::xml_schema::string&);

    timecode1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    timecode1 (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    timecode1 (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    timecode1 (const timecode1& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual timecode1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~timecode1 ();
  };

  class duration: public ::xml_schema::string
  {
    public:
    // formatLabel
    // 
    typedef ::xml_schema::string formatLabel_type;
    typedef ::xsd::cxx::tree::optional< formatLabel_type > formatLabel_optional;
    typedef ::xsd::cxx::tree::traits< formatLabel_type, char > formatLabel_traits;

    const formatLabel_optional&
    formatLabel () const;

    formatLabel_optional&
    formatLabel ();

    void
    formatLabel (const formatLabel_type& x);

    void
    formatLabel (const formatLabel_optional& x);

    void
    formatLabel (::std::auto_ptr< formatLabel_type > p);

    // formatDefinition
    // 
    typedef ::xml_schema::string formatDefinition_type;
    typedef ::xsd::cxx::tree::optional< formatDefinition_type > formatDefinition_optional;
    typedef ::xsd::cxx::tree::traits< formatDefinition_type, char > formatDefinition_traits;

    const formatDefinition_optional&
    formatDefinition () const;

    formatDefinition_optional&
    formatDefinition ();

    void
    formatDefinition (const formatDefinition_type& x);

    void
    formatDefinition (const formatDefinition_optional& x);

    void
    formatDefinition (::std::auto_ptr< formatDefinition_type > p);

    // formatLink
    // 
    typedef ::xml_schema::uri formatLink_type;
    typedef ::xsd::cxx::tree::optional< formatLink_type > formatLink_optional;
    typedef ::xsd::cxx::tree::traits< formatLink_type, char > formatLink_traits;

    const formatLink_optional&
    formatLink () const;

    formatLink_optional&
    formatLink ();

    void
    formatLink (const formatLink_type& x);

    void
    formatLink (const formatLink_optional& x);

    void
    formatLink (::std::auto_ptr< formatLink_type > p);

    // formatLanguage
    // 
    typedef ::xml_schema::language formatLanguage_type;
    typedef ::xsd::cxx::tree::optional< formatLanguage_type > formatLanguage_optional;
    typedef ::xsd::cxx::tree::traits< formatLanguage_type, char > formatLanguage_traits;

    const formatLanguage_optional&
    formatLanguage () const;

    formatLanguage_optional&
    formatLanguage ();

    void
    formatLanguage (const formatLanguage_type& x);

    void
    formatLanguage (const formatLanguage_optional& x);

    void
    formatLanguage (::std::auto_ptr< formatLanguage_type > p);

    // Constructors.
    //
    duration ();

    duration (const char*);

    duration (const ::std::string&);

    duration (const ::xml_schema::string&);

    duration (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    duration (const duration& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual duration*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~duration ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    formatLabel_optional formatLabel_;
    formatDefinition_optional formatDefinition_;
    formatLink_optional formatLink_;
    formatLanguage_optional formatLanguage_;
  };

  class hashFunction: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    hashFunction ();

    hashFunction (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    hashFunction (const hashFunction& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual hashFunction*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~hashFunction ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class mimeType: public ::xml_schema::type
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    mimeType ();

    mimeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    mimeType (const mimeType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual mimeType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~mimeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };

  class locator: public ::xml_schema::uri
  {
    public:
    // typeLabel
    // 
    typedef ::xml_schema::string typeLabel_type;
    typedef ::xsd::cxx::tree::optional< typeLabel_type > typeLabel_optional;
    typedef ::xsd::cxx::tree::traits< typeLabel_type, char > typeLabel_traits;

    const typeLabel_optional&
    typeLabel () const;

    typeLabel_optional&
    typeLabel ();

    void
    typeLabel (const typeLabel_type& x);

    void
    typeLabel (const typeLabel_optional& x);

    void
    typeLabel (::std::auto_ptr< typeLabel_type > p);

    // typeDefinition
    // 
    typedef ::xml_schema::string typeDefinition_type;
    typedef ::xsd::cxx::tree::optional< typeDefinition_type > typeDefinition_optional;
    typedef ::xsd::cxx::tree::traits< typeDefinition_type, char > typeDefinition_traits;

    const typeDefinition_optional&
    typeDefinition () const;

    typeDefinition_optional&
    typeDefinition ();

    void
    typeDefinition (const typeDefinition_type& x);

    void
    typeDefinition (const typeDefinition_optional& x);

    void
    typeDefinition (::std::auto_ptr< typeDefinition_type > p);

    // typeLink
    // 
    typedef ::xml_schema::uri typeLink_type;
    typedef ::xsd::cxx::tree::optional< typeLink_type > typeLink_optional;
    typedef ::xsd::cxx::tree::traits< typeLink_type, char > typeLink_traits;

    const typeLink_optional&
    typeLink () const;

    typeLink_optional&
    typeLink ();

    void
    typeLink (const typeLink_type& x);

    void
    typeLink (const typeLink_optional& x);

    void
    typeLink (::std::auto_ptr< typeLink_type > p);

    // typeLanguage
    // 
    typedef ::xml_schema::language typeLanguage_type;
    typedef ::xsd::cxx::tree::optional< typeLanguage_type > typeLanguage_optional;
    typedef ::xsd::cxx::tree::traits< typeLanguage_type, char > typeLanguage_traits;

    const typeLanguage_optional&
    typeLanguage () const;

    typeLanguage_optional&
    typeLanguage ();

    void
    typeLanguage (const typeLanguage_type& x);

    void
    typeLanguage (const typeLanguage_optional& x);

    void
    typeLanguage (::std::auto_ptr< typeLanguage_type > p);

    // Constructors.
    //
    locator (const ::xml_schema::uri&);

    locator (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    locator (const locator& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual locator*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~locator ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    typeLabel_optional typeLabel_;
    typeDefinition_optional typeDefinition_;
    typeLink_optional typeLink_;
    typeLanguage_optional typeLanguage_;
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace ebuCore_2012
{
  // Parse a URI or a local file.
  //

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (const ::std::string& uri,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (const ::std::string& uri,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (const ::std::string& uri,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::std::istream& is,
               const ::std::string& id,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::xercesc::InputSource& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::ebuCore_2012::ebuCoreMainType >
  ebuCoreMain (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace ebuCore_2012
{
  // Serialize to std::ostream.
  //

  void
  ebuCoreMain (::std::ostream& os,
               const ::ebuCore_2012::ebuCoreMainType& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  void
  ebuCoreMain (::std::ostream& os,
               const ::ebuCore_2012::ebuCoreMainType& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  void
  ebuCoreMain (::std::ostream& os,
               const ::ebuCore_2012::ebuCoreMainType& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& ft,
               const ::ebuCore_2012::ebuCoreMainType& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& ft,
               const ::ebuCore_2012::ebuCoreMainType& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  void
  ebuCoreMain (::xercesc::XMLFormatTarget& ft,
               const ::ebuCore_2012::ebuCoreMainType& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  ebuCoreMain (::xercesc::DOMDocument& d,
               const ::ebuCore_2012::ebuCoreMainType& x,
               ::xml_schema::flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  ebuCoreMain (const ::ebuCore_2012::ebuCoreMainType& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const ebuCoreMainType&);

  void
  operator<< (::xercesc::DOMElement&, const coreMetadataType&);

  void
  operator<< (::xercesc::DOMElement&, const partType&);

  void
  operator<< (::xercesc::DOMElement&, const titleType&);

  void
  operator<< (::xercesc::DOMElement&, const alternativeTitleType&);

  void
  operator<< (::xercesc::DOMElement&, const identifierType&);

  void
  operator<< (::xercesc::DOMElement&, const subjectType&);

  void
  operator<< (::xercesc::DOMElement&, const typeType&);

  void
  operator<< (::xercesc::DOMElement&, const descriptionType&);

  void
  operator<< (::xercesc::DOMElement&, const coverageType&);

  void
  operator<< (::xercesc::DOMElement&, const locationType&);

  void
  operator<< (::xercesc::DOMElement&, const periodOfTimeType&);

  void
  operator<< (::xercesc::DOMElement&, const rightsType&);

  void
  operator<< (::xercesc::DOMElement&, const relationType&);

  void
  operator<< (::xercesc::DOMElement&, const languageType&);

  void
  operator<< (::xercesc::DOMElement&, const dateType&);

  void
  operator<< (::xercesc::DOMElement&, const publicationHistoryType&);

  void
  operator<< (::xercesc::DOMElement&, const publicationEventType&);

  void
  operator<< (::xercesc::DOMElement&, const publicationServiceType&);

  void
  operator<< (::xercesc::DOMElement&, const publicationMediumType&);

  void
  operator<< (::xercesc::DOMElement&, const publicationChannelType&);

  void
  operator<< (::xercesc::DOMElement&, const formatType&);

  void
  operator<< (::xercesc::DOMElement&, const entityType&);

  void
  operator<< (::xercesc::DOMElement&, const contactDetailsType&);

  void
  operator<< (::xercesc::DOMElement&, const organisationDetailsType&);

  void
  operator<< (::xercesc::DOMElement&, const detailsType&);

  void
  operator<< (::xercesc::DOMElement&, const addressType&);

  void
  operator<< (::xercesc::DOMElement&, const compoundNameType&);

  void
  operator<< (::xercesc::DOMElement&, const regionType&);

  void
  operator<< (::xercesc::DOMElement&, const editUnitNumberType&);

  void
  operator<< (::xercesc::DOMElement&, const ratingType&);

  void
  operator<< (::xercesc::DOMElement&, const lengthType&);

  void
  operator<< (::xercesc::DOMElement&, const dimensionType&);

  void
  operator<< (::xercesc::DOMElement&, const imageFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const videoFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const audioFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const dataFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const documentFormatType&);

  void
  operator<< (::xercesc::DOMElement&, const codecType&);

  void
  operator<< (::xercesc::DOMElement&, const timeType&);

  void
  operator<< (::xercesc::DOMElement&, const durationType&);

  void
  operator<< (::xercesc::DOMElement&, const hashType&);

  void
  operator<< (::xercesc::DOMElement&, const String&);

  void
  operator<< (::xercesc::DOMElement&, const Boolean&);

  void
  operator<< (::xercesc::DOMElement&, const Float&);

  void
  operator<< (::xercesc::DOMElement&, const Int8&);

  void
  operator<< (::xercesc::DOMElement&, const Int16&);

  void
  operator<< (::xercesc::DOMElement&, const Int32&);

  void
  operator<< (::xercesc::DOMElement&, const Int64&);

  void
  operator<< (::xercesc::DOMElement&, const UInt8&);

  void
  operator<< (::xercesc::DOMElement&, const UInt16&);

  void
  operator<< (::xercesc::DOMElement&, const UInt32&);

  void
  operator<< (::xercesc::DOMElement&, const UInt64&);

  void
  operator<< (::xercesc::DOMElement&, const rationalType&);

  void
  operator<< (::xercesc::DOMElement&, const aspectRatioType&);

  void
  operator<< (::xercesc::DOMElement&, const technicalAttributeRationalType&);

  void
  operator<< (::xercesc::DOMElement&, const technicalAttributeUriType&);

  void
  operator<< (::xercesc::DOMElement&, const versionType&);

  void
  operator<< (::xercesc::DOMElement&, const hasTrackPart&);

  void
  operator<< (::xercesc::DOMElement&, const genre&);

  void
  operator<< (::xercesc::DOMElement&, const objectType&);

  void
  operator<< (::xercesc::DOMElement&, const targetAudience&);

  void
  operator<< (::xercesc::DOMElement&, const temporal&);

  void
  operator<< (::xercesc::DOMElement&, const spatial&);

  void
  operator<< (::xercesc::DOMElement&, const coordinates&);

  void
  operator<< (::xercesc::DOMElement&, const created&);

  void
  operator<< (::xercesc::DOMElement&, const issued&);

  void
  operator<< (::xercesc::DOMElement&, const modified&);

  void
  operator<< (::xercesc::DOMElement&, const digitised&);

  void
  operator<< (::xercesc::DOMElement&, const released&);

  void
  operator<< (::xercesc::DOMElement&, const copyrighted&);

  void
  operator<< (::xercesc::DOMElement&, const alternative&);

  void
  operator<< (::xercesc::DOMElement&, const medium&);

  void
  operator<< (::xercesc::DOMElement&, const containerFormat&);

  void
  operator<< (::xercesc::DOMElement&, const signingFormat&);

  void
  operator<< (::xercesc::DOMElement&, const dateCreated&);

  void
  operator<< (::xercesc::DOMElement&, const dateModified&);

  void
  operator<< (::xercesc::DOMElement&, const role&);

  void
  operator<< (::xercesc::DOMElement&, const relatedInformationLink&);

  void
  operator<< (::xercesc::DOMElement&, const organisationDepartment&);

  void
  operator<< (::xercesc::DOMElement&, const relatedInformationLink1&);

  void
  operator<< (::xercesc::DOMElement&, const country&);

  void
  operator<< (::xercesc::DOMElement&, const country1&);

  void
  operator<< (::xercesc::DOMElement&, const countryRegion&);

  void
  operator<< (::xercesc::DOMElement&, const orientation&);

  void
  operator<< (::xercesc::DOMAttr&, const orientation&);

  void
  operator<< (::xml_schema::list_stream&,
              const orientation&);

  void
  operator<< (::xercesc::DOMElement&, const imageEncoding&);

  void
  operator<< (::xercesc::DOMElement&, const comment&);

  void
  operator<< (::xercesc::DOMElement&, const width&);

  void
  operator<< (::xercesc::DOMElement&, const height&);

  void
  operator<< (::xercesc::DOMElement&, const videoEncoding&);

  void
  operator<< (::xercesc::DOMElement&, const bitRateMode&);

  void
  operator<< (::xercesc::DOMAttr&, const bitRateMode&);

  void
  operator<< (::xml_schema::list_stream&,
              const bitRateMode&);

  void
  operator<< (::xercesc::DOMElement&, const scanningFormat&);

  void
  operator<< (::xercesc::DOMAttr&, const scanningFormat&);

  void
  operator<< (::xml_schema::list_stream&,
              const scanningFormat&);

  void
  operator<< (::xercesc::DOMElement&, const scanningOrder&);

  void
  operator<< (::xercesc::DOMAttr&, const scanningOrder&);

  void
  operator<< (::xml_schema::list_stream&,
              const scanningOrder&);

  void
  operator<< (::xercesc::DOMElement&, const videoTrack&);

  void
  operator<< (::xercesc::DOMElement&, const comment1&);

  void
  operator<< (::xercesc::DOMElement&, const audioEncoding&);

  void
  operator<< (::xercesc::DOMElement&, const audioTrackConfiguration&);

  void
  operator<< (::xercesc::DOMElement&, const sampleType&);

  void
  operator<< (::xercesc::DOMAttr&, const sampleType&);

  void
  operator<< (::xml_schema::list_stream&,
              const sampleType&);

  void
  operator<< (::xercesc::DOMElement&, const bitRateMode1&);

  void
  operator<< (::xercesc::DOMAttr&, const bitRateMode1&);

  void
  operator<< (::xml_schema::list_stream&,
              const bitRateMode1&);

  void
  operator<< (::xercesc::DOMElement&, const audioTrack&);

  void
  operator<< (::xercesc::DOMElement&, const comment2&);

  void
  operator<< (::xercesc::DOMElement&, const captioningFormat&);

  void
  operator<< (::xercesc::DOMElement&, const subtitlingFormat&);

  void
  operator<< (::xercesc::DOMElement&, const ancillaryDataFormat&);

  void
  operator<< (::xercesc::DOMElement&, const comment3&);

  void
  operator<< (::xercesc::DOMElement&, const comment4&);

  void
  operator<< (::xercesc::DOMElement&, const timecode&);

  void
  operator<< (::xercesc::DOMAttr&, const timecode&);

  void
  operator<< (::xml_schema::list_stream&,
              const timecode&);

  void
  operator<< (::xercesc::DOMElement&, const time&);

  void
  operator<< (::xercesc::DOMElement&, const timecode1&);

  void
  operator<< (::xercesc::DOMAttr&, const timecode1&);

  void
  operator<< (::xml_schema::list_stream&,
              const timecode1&);

  void
  operator<< (::xercesc::DOMElement&, const duration&);

  void
  operator<< (::xercesc::DOMElement&, const hashFunction&);

  void
  operator<< (::xercesc::DOMElement&, const mimeType&);

  void
  operator<< (::xercesc::DOMElement&, const locator&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // EBU_CORE_20130107_HXX
