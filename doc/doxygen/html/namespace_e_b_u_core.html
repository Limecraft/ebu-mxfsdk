<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EBU MXF SDK: EBUCore Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EBU MXF SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EBUCore Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_b_u_core_1_1_m_x_f_file_dark_serializer.html">MXFFileDarkSerializer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_b_u_core_1_1_dark_file_serializer.html">DarkFileSerializer</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2cbd327f0706dea6d5debfb9551dc198"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a2cbd327f0706dea6d5debfb9551dc198">MetadataKind</a> { <a class="el" href="namespace_e_b_u_core.html#a2cbd327f0706dea6d5debfb9551dc198a7b282fd0d58dbe62371ef19bdd0891ca">KLV_ENCODED</a>, 
<a class="el" href="namespace_e_b_u_core.html#a2cbd327f0706dea6d5debfb9551dc198a1c85051174af6eb02867eaf287e0a3aa">DARK</a>, 
<a class="el" href="namespace_e_b_u_core.html#a2cbd327f0706dea6d5debfb9551dc198acee564a50705fdaf509da9a614dd5d83">SIDECAR</a>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a699993b606b543caf128dbb1e4da4970"><td class="memItemLeft" align="right" valign="top">mxfpp::Identification *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a699993b606b543caf128dbb1e4da4970">GenerateEBUCoreIdentificationSet</a> (mxfpp::HeaderMetadata *destination)</td></tr>
<tr class="memitem:acb8489c710bca72c0ed4d3687b035e2c"><td class="memItemLeft" align="right" valign="top">mxfpp::DMFramework *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#acb8489c710bca72c0ed4d3687b035e2c">Process</a> (const char *location, mxfpp::HeaderMetadata *destination, mxfpp::Identification *identificationToAppend=NULL)</td></tr>
<tr class="memitem:aa79ec7a01034266eb2d171ec8412abe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#aa79ec7a01034266eb2d171ec8412abe3">FindAndSerializeEBUCore</a> (mxfpp::HeaderMetadata *metadata, const char *outputfilename)</td></tr>
<tr class="memitem:a709463d0978d35dc7033a9968de7aaba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a709463d0978d35dc7033a9968de7aaba">RegisterMetadataExtensionsforEBUCore</a> (mxfpp::DataModel *data_model)</td></tr>
<tr class="memitem:ada9881a9a1d1167788775d9fb3761039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#ada9881a9a1d1167788775d9fb3761039">RegisterFrameworkObjectFactoriesforEBUCore</a> (mxfpp::HeaderMetadata *metadata)</td></tr>
<tr class="memitem:a3609c4c60753c42f02565529c7658574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a3609c4c60753c42f02565529c7658574">InsertEBUCoreFramework</a> (mxfpp::HeaderMetadata *header_metadata, mxfpp::DMFramework *framework, mxfpp::Identification *identificationToAppend=NULL)</td></tr>
<tr class="memitem:a08b668e0d8e64d6fac27763fca386de3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a08b668e0d8e64d6fac27763fca386de3">BufferIndex</a> (mxfpp::File *mFile, mxfpp::Partition *partition, bmx::ByteArray &amp;index_bytes, uint32_t *index_length)</td></tr>
<tr class="memitem:a3324464c432fe2920bd7568ad32adcb7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a3324464c432fe2920bd7568ad32adcb7">WriteMetadataToMemoryFile</a> (mxfpp::File *mFile, MXFMemoryFile **destMemFile, mxfpp::HeaderMetadata *mHeaderMetadata, uint64_t metadata_read_position, uint64_t metadata_write_position, mxfpp::Partition *metadataDestitionPartition, mxfpp::Partition *metadataSourcePartition)</td></tr>
<tr class="memitem:a21145e14bf2fb1c9e2cfe49888b51dc0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a21145e14bf2fb1c9e2cfe49888b51dc0">WriteMetadataToFile</a> (mxfpp::File *mFile, mxfpp::HeaderMetadata *mHeaderMetadata, uint64_t metadata_read_position, uint64_t metadata_write_position, bool shiftFileBytesIfNeeded, mxfpp::Partition *metadataDestitionPartition, mxfpp::Partition *metadataSourcePartition)</td></tr>
<tr class="memitem:ac85157c4a2fbe025dfa65ac92ae46d21"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#ac85157c4a2fbe025dfa65ac92ae46d21">WriteDarkMetadataToMemoryFile</a> (mxfpp::File *mFile, MXFMemoryFile **destMemFile, <a class="el" href="class_e_b_u_core_1_1_m_x_f_file_dark_serializer.html">MXFFileDarkSerializer</a> &amp;metadata, uint64_t metadata_read_position, uint64_t metadata_write_position, mxfpp::Partition *metadataDestitionPartition, mxfpp::Partition *metadataSourcePartition)</td></tr>
<tr class="memitem:a66857202694fb998c48c748892e179a6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a66857202694fb998c48c748892e179a6">WriteDarkMetadataToFile</a> (mxfpp::File *mFile, <a class="el" href="class_e_b_u_core_1_1_m_x_f_file_dark_serializer.html">MXFFileDarkSerializer</a> &amp;metadata, uint64_t metadata_read_position, uint64_t metadata_write_position, bool shiftFileBytesIfNeeded, mxfpp::Partition *metadataDestitionPartition, mxfpp::Partition *metadataSourcePartition)</td></tr>
<tr class="memitem:a627531cfdad6dc4929cd06f6fef22e7d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a627531cfdad6dc4929cd06f6fef22e7d">FindLastPartitionFill</a> (mxfpp::File *mFile, mxfpp::Partition *partition, int64_t *partitionSectionOffset, int64_t *extractedFileSize=NULL)</td></tr>
<tr class="memitem:a176a476dac9d27f606fb0179dc6fb05b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a176a476dac9d27f606fb0179dc6fb05b">ShiftBytesInFile</a> (mxfpp::File *mFile, int64_t shiftPosition, int64_t shiftOffset)</td></tr>
<tr class="memitem:a282538cbd5ececa181aa89c8333d2613"><td class="memItemLeft" align="right" valign="top">mxfpp::Partition *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a282538cbd5ececa181aa89c8333d2613">FindPreferredMetadataPartition</a> (const std::vector&lt; mxfpp::Partition * &gt; &amp;partitions, mxfpp::Partition **headerPartition, mxfpp::Partition **footerPartition)</td></tr>
<tr class="memitem:aa72287914176c1fad5c448002771e85b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#aa72287914176c1fad5c448002771e85b">EmbedEBUCoreMetadata</a> (const char *metadataLocation, const char *mxfLocation, void(*progress_callback)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...), <a class="el" href="namespace_e_b_u_core.html#a2cbd327f0706dea6d5debfb9551dc198">MetadataKind</a> optWaytoWrite=<a class="el" href="namespace_e_b_u_core.html#a2cbd327f0706dea6d5debfb9551dc198a7b282fd0d58dbe62371ef19bdd0891ca">KLV_ENCODED</a>, bool optNoIdentification=false, bool optForceHeader=false)</td></tr>
<tr class="memitem:ab29271ca292ebc32aca21deb4273a294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#ab29271ca292ebc32aca21deb4273a294">EmbedEBUCoreMetadata</a> (xercesc::DOMDocument &amp;metadataDocument, const char *metadataLocation, const char *mxfLocation, void(*progress_callback)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...), <a class="el" href="namespace_e_b_u_core.html#a2cbd327f0706dea6d5debfb9551dc198">MetadataKind</a> optWaytoWrite=<a class="el" href="namespace_e_b_u_core.html#a2cbd327f0706dea6d5debfb9551dc198a7b282fd0d58dbe62371ef19bdd0891ca">KLV_ENCODED</a>, bool optNoIdentification=false, bool optForceHeader=false)</td></tr>
<tr class="memitem:a30ede5851b0e2eeb6adb6d355e6f3f0c"><td class="memItemLeft" align="right" valign="top">xercesc::DOMDocument &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#a30ede5851b0e2eeb6adb6d355e6f3f0c">ExtractEBUCoreMetadata</a> (const char *mxfLocation, void(*progress_callback)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...))</td></tr>
<tr class="memitem:ac68b00d3d88b690e0d1022c5333ab5f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_core.html#ac68b00d3d88b690e0d1022c5333ab5f4">ExtractEBUCoreMetadata</a> (const char *mxfLocation, const char *metadataLocation, void(*progress_callback)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...))</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>EBU MXF SDK main namespace for <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> functionality. </p>
</div><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a2cbd327f0706dea6d5debfb9551dc198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_e_b_u_core.html#a2cbd327f0706dea6d5debfb9551dc198">EBUCore::MetadataKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the ways of serializing metadata in MXF files. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a2cbd327f0706dea6d5debfb9551dc198a7b282fd0d58dbe62371ef19bdd0891ca"></a>KLV_ENCODED</em>&nbsp;</td><td>
<p>Metadata is encoded using full-featured KLV-encoded metadata element sets (recommended when applicable). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2cbd327f0706dea6d5debfb9551dc198a1c85051174af6eb02867eaf287e0a3aa"></a>DARK</em>&nbsp;</td><td>
<p>Metadata is encoded using a single KLV element in which the metadata is written as is. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2cbd327f0706dea6d5debfb9551dc198acee564a50705fdaf509da9a614dd5d83"></a>SIDECAR</em>&nbsp;</td><td>
<p>A KLV-encoded metadata set is added to the the header metadata with a reference to an external file that contains the actual metadata. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a08b668e0d8e64d6fac27763fca386de3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUCore::BufferIndex </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bmx::ByteArray &amp;&#160;</td>
          <td class="paramname"><em>index_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>index_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffers the index entries of the given <b>partition</b> in a ByteArray and returns the size of the index entries buffered and the first byte of the header metadata in the given <b>partition</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the location of the first byte of the header metadata in the given <b>partition</b>. This position is location behind the partition pack set and any KLV filler elements that follow it. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>An MXF file structure opened with (at least) read access. </td></tr>
    <tr><td class="paramname">partition</td><td>The partition for which the index entries must be buffered. </td></tr>
    <tr><td class="paramname">index_bytes</td><td>A reference to a pre-allocated ByteArray structure to hold the buffered index bytes. </td></tr>
    <tr><td class="paramname">index_length</td><td>A pointer to an integer that will receive the length of the index bytes buffered when the function returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa72287914176c1fad5c448002771e85b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUCore::EmbedEBUCoreMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metadataLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mxfLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...)&#160;</td>
          <td class="paramname"><em>progress_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetadataKind&#160;</td>
          <td class="paramname"><em>optWaytoWrite</em> = <code>KLV_ENCODED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optNoIdentification</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optForceHeader</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Embed <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata into an MXF file. </p>
<dl class="section return"><dt>Returns</dt><dd>Has no return value, but throws an exception when irregularities occur. The caller is informed of any progress by means of the <b>progress_callback</b> argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadataLocation</td><td>The location of the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> XML metadata document file. This file is parsed using the Xerces-C++ XML parser. The document is assumed to conform to the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> XML schema and is not explicitly validated. </td></tr>
    <tr><td class="paramname">mxfLocation</td><td>The location of the MXF file in which to embed the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>A function that is called with updated progress concerning the embedding process. The function is called with the overall progress of the operation in <b>progress</b>, a <b>message</b> that describes the updated status, and the name of the internal <b>function</b> to which the progress update relates (which can be used for debugging purposes). </td></tr>
    <tr><td class="paramname">optWaytoWrite</td><td>Specifies the way in which the provided metadata will be serialized into the MXF file. </td></tr>
    <tr><td class="paramname">optNoIdentification</td><td>When true, forces the SDK not to write an additional MXF metadata Identification set to identify the SDK as source of metadata updates. </td></tr>
    <tr><td class="paramname">optForceHeader</td><td>When true, forces the SDK to write the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata into the header partition, potentially forcing a rewrite of the entire MXF file. In normal operation, the SDK attempts to write the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata into the footer partition, marking the header (and potential body) partitions that contain metadata as open and incomplete. This way only the footer paritition and the (small) partition packs must be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab29271ca292ebc32aca21deb4273a294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUCore::EmbedEBUCoreMetadata </td>
          <td>(</td>
          <td class="paramtype">xercesc::DOMDocument &amp;&#160;</td>
          <td class="paramname"><em>metadataDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metadataLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mxfLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...)&#160;</td>
          <td class="paramname"><em>progress_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetadataKind&#160;</td>
          <td class="paramname"><em>optWaytoWrite</em> = <code>KLV_ENCODED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optNoIdentification</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optForceHeader</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Embed <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata into an MXF file.<br/>
 This variant of <b>EmbedEBUCoreMetadata</b> accepts a processed XML document, in the form of a Xerces-C++ XML DOM representation. This function can hence be used when the caller wishes to manipulate the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata first, before embedding it in the MXF file and without having to write changes to a physical XML file first. </p>
<dl class="section return"><dt>Returns</dt><dd>Has no return value, but throws an exception when irregularities occur. The caller is informed of any progress by means of the <b>progress_callback</b> argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadataDocument</td><td>A parsed <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> XML metadata document, in the form of the DOM representation generated by the Xerces-C++ XML parser. The document is assumed to conform to the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> XML schema and is not explicitly validated. </td></tr>
    <tr><td class="paramname">metadataLocation</td><td>The logical location of the metadata document, as it will be embedded in the KLV <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata. As in this form the <b>metadataDocument</b> doesn't provide an indication of the physical source location of the document, it is be provided separately here. When irrelevant, an empty string "" can be provided. </td></tr>
    <tr><td class="paramname">mxfLocation</td><td>The location of the MXF file in which to embed the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>A function that is called with updated progress concerning the embedding process. The function is called with the overall progress of the operation in <b>progress</b>, a <b>message</b> that describes the updated status, and the name of the internal <b>function</b> to which the progress update relates (which can be used for debugging purposes). </td></tr>
    <tr><td class="paramname">optWaytoWrite</td><td>Specifies the way in which the provided metadata will be serialized into the MXF file. </td></tr>
    <tr><td class="paramname">optNoIdentification</td><td>When true, forces the SDK not to write an additional MXF metadata Identification set to identify the SDK as source of metadata updates. </td></tr>
    <tr><td class="paramname">optForceHeader</td><td>When true, forces the SDK to write the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata into the header partition, potentially forcing a rewrite of the entire MXF file. In normal operation, the SDK attempts to write the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata into the footer partition, marking the header (and potential body) partitions that contain metadata as open and incomplete. This way only the footer paritition and the (small) partition packs must be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30ede5851b0e2eeb6adb6d355e6f3f0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xercesc::DOMDocument &amp; EBUCore::ExtractEBUCoreMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mxfLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...)&#160;</td>
          <td class="paramname"><em>progress_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata from an MXF file.<br/>
 The SDK consecutively tries to extract the metadata in three ways; from KLV-encoded <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata sets, from a sidecar file referenced by the MXF file's metadata, or as 'dark' metadata from a KLV set identified by the appropriate key.<br/>
 This variant of <b>ExtractEBUCoreMetadata</b> returns a Xerces-C++ XML DOM data structure that can be processed and transformed by the caller, before e.g., being written out to disk. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to a Xerces-C++ XML DOM document representation that conforms to the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> XML schema. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mxfLocation</td><td>The location of the MXF file in which to extract the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>A function that is called with updated progress concerning the embedding process. The function is called with the overall progress of the operation in <b>progress</b>, a <b>message</b> that describes the updated status, and the name of the internal <b>function</b> to which the progress update relates (which can be used for debugging purposes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac68b00d3d88b690e0d1022c5333ab5f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUCore::ExtractEBUCoreMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mxfLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metadataLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...)&#160;</td>
          <td class="paramname"><em>progress_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata from an MXF file.<br/>
 The SDK consecutively tries to extract the metadata in three ways; from KLV-encoded <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata sets, from a sidecar file referenced by the MXF file's metadata, or as 'dark' metadata from a KLV set identified by the appropriate key.<br/>
 </p>
<dl class="section return"><dt>Returns</dt><dd>Has no return value, but throws an exception when irregularities occur. The caller is informed of any progress by means of the <b>progress_callback</b> argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mxfLocation</td><td>The location of the MXF file in which to extract the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata. </td></tr>
    <tr><td class="paramname">metadataLocation</td><td>The location of the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> XML metadata document file destination. The XML document written conforms to the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> XML schema. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>A function that is called with updated progress concerning the embedding process. The function is called with the overall progress of the operation in <b>progress</b>, a <b>message</b> that describes the updated status, and the name of the internal <b>function</b> to which the progress update relates (which can be used for debugging purposes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa79ec7a01034266eb2d171ec8412abe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUCore::FindAndSerializeEBUCore </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>outputfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function for locating KLV-encoded <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata in the provided header metadata and serializing this metadata to file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadata</td><td>Parsed header metadata structure of the MXF file. </td></tr>
    <tr><td class="paramname">outputfilename</td><td>Location of the file to write the serialized metadata to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a627531cfdad6dc4929cd06f6fef22e7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t EBUCore::FindLastPartitionFill </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>partitionSectionOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>extractedFileSize</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the last KLV filler element in the given <b>partition</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte position of the last KLV filler element in the given partition. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The MXF file structure opened with (at least) read access. </td></tr>
    <tr><td class="paramname">partition</td><td>The partition in which to locate the last KLV filler element. </td></tr>
    <tr><td class="paramname">partitionSectionOffset</td><td>Pointer to the integer that receives the byte position from where the last KLV filler was searched for. Depending on the configuration of the <b>partition</b>, this can be immediatelly behind the partition pack, behind the header metadata (if present), or behind the partition's index entries (if present). This can be the same value as returned by this function, but not necessarily in case multiple filler elements are found. </td></tr>
    <tr><td class="paramname">extractedFileSize</td><td>Pointer to the integer that receives the length of the provided MXF file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a282538cbd5ececa181aa89c8333d2613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mxfpp::Partition* EBUCore::FindPreferredMetadataPartition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; mxfpp::Partition * &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition **&#160;</td>
          <td class="paramname"><em>headerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition **&#160;</td>
          <td class="paramname"><em>footerPartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>From a given set of partitions, locates the partition which has the preferred header metadata. Additionally, also locates the header and footer partition.<br/>
 The preferred metadata is located as follows.</p>
<ul>
<li>If the footer partition is marked as closed and contains header metadata, it is selected.</li>
<li>Else, if the header partition is marked as closed and contains header metadata, it is selected.</li>
<li>Else, if any of the body partitions is marked as closed and contains header metadata, it is selected. The last body partition to match is chosen.</li>
<li>Else, if there are any open partitions that contain metadata, the last of these is selected.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the partition that contains the preferred metadata, or NULL if no applicable partition could be found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partitions</td><td>The list of partitions from which the selection is made, typically all partitions of an MXF file. </td></tr>
    <tr><td class="paramname">headerPartition</td><td>Pointer to variable that will be assigned the header partition of the list. </td></tr>
    <tr><td class="paramname">footerPartition</td><td>Pointer to variable that will be assigned the footer partition of the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a699993b606b543caf128dbb1e4da4970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Identification * EBUCore::GenerateEBUCoreIdentificationSet </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates an MXF Identification metadata set that can be referred to by new and updated metdata sets in the MXF file.<br/>
 The following information is contained in the set:<br/>
</p>
<ul>
<li>Company Name: "EBU"</li>
<li>Product Name: "EBUCore SDK"</li>
<li>ProductUID: { 0xda, 0xe5, 0x92, 0x18, 0xaf, 0x8d, 0x47, 0xd4, 0xa2, 0x16, 0xb6, 0xc6, 0x48, 0xea, 0x54, 0x8c }</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the generated Identification set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The HeaderMetadata structure to which the Identification set will be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3609c4c60753c42f02565529c7658574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUCore::InsertEBUCoreFramework </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>header_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::DMFramework *&#160;</td>
          <td class="paramname"><em>framework</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Identification *&#160;</td>
          <td class="paramname"><em>identificationToAppend</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a given descriptive metadata framework set in the provided header metadata structure.<br/>
 This function first appends the <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> DMS scheme label to the metadata Preface set and then adds a static DM track to the MXF timeline, from which the provided <b>framework</b> is referenced.<br/>
 Currently, the DM track added is assigned a Track ID <em>10001</em> and is given a Track Name <em>EBU_Core</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_metadata</td><td>The HeaderMetadata structure to which the framework and timeline elements are added. </td></tr>
    <tr><td class="paramname">framework</td><td>The DM framework set to be added to the MXF timeline. </td></tr>
    <tr><td class="paramname">identificationToAppend</td><td>Optional Identification metadata set that will be referenced from each metadata set created by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb8489c710bca72c0ed4d3687b035e2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mxfpp::DMFramework* EBUCore::Process </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Identification *&#160;</td>
          <td class="paramname"><em>identificationToAppend</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata in a file at <b>location</b> and returns the resulting <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> MXF descriptive metadata framework of the type EBUCoreMainFramework.<br/>
 In case the optional Identification set is provided in the <b>identificationToAppend</b> argument, this Identification is referenced from all metadata sets generated during the parsing operation. This allows external applications to track all metadata related to this particular parsing (and possibly subsequent MXF update) operation.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the parsed EBUCoreMainFramework set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>Location of the metadata file. </td></tr>
    <tr><td class="paramname">destination</td><td>The HeaderMetadata structure to which the EBUCoreMainFramework and its descending metadata sets will be added. </td></tr>
    <tr><td class="paramname">identificationToAppend</td><td>Optional Identification metadata set that will be referenced from each parsed metadata set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada9881a9a1d1167788775d9fb3761039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUCore::RegisterFrameworkObjectFactoriesforEBUCore </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>metadata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers the KLV <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata object factories with a given MXF header metadata structure. These object factories allow the MXF metadata processing code to locate appropriate custom metadata set instantiation functions (factories) to call when encountering custom ULs in the metadata. Essentially, when a metadata set with a registered UL is encountered in the MXF metadata, the appropriate factory function will be called to create a metadata set of the correct type.<br/>
 <em><b>Note!</em></b> The factory functions must be registered with the empty metadata before actually parsing the MXF file header metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadata</td><td>The HeaderMetadata structure with which the factory functions must be registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a709463d0978d35dc7033a9968de7aaba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUCore::RegisterMetadataExtensionsforEBUCore </td>
          <td>(</td>
          <td class="paramtype">mxfpp::DataModel *&#160;</td>
          <td class="paramname"><em>data_model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers the KLV <a class="el" href="namespace_e_b_u_core.html">EBUCore</a> metadata extensions with a given MXF metadata data model. These extensions comprise the class structure and ULs associated with metadata sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_model</td><td>The MXF metadata data model to which the extensions are to be appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a176a476dac9d27f606fb0179dc6fb05b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUCore::ShiftBytesInFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>shiftPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>shiftOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shifts bytes in an MXF file from a given posiition by a given offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">shiftPosition</td><td>The byte position in the file from which the shift operation will take place. </td></tr>
    <tr><td class="paramname">shiftOffset</td><td>The byte offset by how much each file byte must be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66857202694fb998c48c748892e179a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUCore::WriteDarkMetadataToFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MXFFileDarkSerializer &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_read_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_write_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shiftFileBytesIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataDestitionPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataSourcePartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes dark header metadata to an MXF file.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total header metadata bytes written to the MXF file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The base MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">metadata</td><td>The dark metadata serializer that will write to the memory-backed file. </td></tr>
    <tr><td class="paramname">metadata_read_position</td><td>The offset in the <b>mFile</b> from where the original header metadata is to be read. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadata_write_position</td><td>The offset in the <b>mFile</b> where the new header metadata is to be written. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">shiftFileBytesIfNeeded</td><td>Dictates whether file bytes should be shifted further down the file to accomodate metadata that has grown from what was originally in the file. If <em>false</em>, however, file bytes are written disregarding any previous file content.<br/>
 <em><b>Note!</em></b> Use this parameter with care as incorrect use can corrupt the MXF file. </td></tr>
    <tr><td class="paramname">metadataDestinationPartition</td><td>The partition in the <b>mFile</b> to which the metadata is being written. </td></tr>
    <tr><td class="paramname">metadataSourcePartition</td><td>The partition in the <b>mFile</b> from which the updated metadata was obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac85157c4a2fbe025dfa65ac92ae46d21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUCore::WriteDarkMetadataToMemoryFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MXFMemoryFile **&#160;</td>
          <td class="paramname"><em>destMemFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MXFFileDarkSerializer &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_read_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_write_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataDestitionPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataSourcePartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serializes dark header metadata to a memory-backed file, at the end of original metadata in the <b>metadataSourcePartition</b> in a single KLV element. Its purpose is to write obtain a linear buffer of serialized metadata of which the size is known, before committing this buffer (i.e., the memory-backed file) to a disk-backed file.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total header metadata bytes written to the memory-backed file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The base MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">destMemFile</td><td>A pointer that will receive a reference to the memory-backed MXF file structure created during the serialization process. </td></tr>
    <tr><td class="paramname">metadata</td><td>The dark metadata serializer that will write to the memory-backed file. </td></tr>
    <tr><td class="paramname">metadata_read_position</td><td>The offset in the <b>mFile</b> from where the original header metadata is to be read. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadata_write_position</td><td>The offset in the <b>mFile</b> where the new header metadata is to be written. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadataDestinationPartition</td><td>The partition in the <b>mFile</b> to which the metadata is being written. </td></tr>
    <tr><td class="paramname">metadataSourcePartition</td><td>The partition in the <b>mFile</b> from which the updated metadata was obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21145e14bf2fb1c9e2cfe49888b51dc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUCore::WriteMetadataToFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>mHeaderMetadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_read_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_write_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shiftFileBytesIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataDestitionPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataSourcePartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes KLV-encoded header metadata to an MXF file.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total header metadata bytes written to the MXF file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The base MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">mHeaderMetadata</td><td>The header metadata that is to be serialized. </td></tr>
    <tr><td class="paramname">metadata_read_position</td><td>The offset in the <b>mFile</b> from where the original header metadata is to be read. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadata_write_position</td><td>The offset in the <b>mFile</b> where the new header metadata is to be written. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">shiftFileBytesIfNeeded</td><td>Dictates whether file bytes should be shifted further down the file to accomodate metadata that has grown from what was originally in the file. If <em>false</em>, however, file bytes are written disregarding any previous file content.<br/>
 <em><b>Note!</em></b> Use this parameter with care as incorrect use can corrupt the MXF file. </td></tr>
    <tr><td class="paramname">metadataDestinationPartition</td><td>The partition in the <b>mFile</b> to which the metadata is being written. </td></tr>
    <tr><td class="paramname">metadataSourcePartition</td><td>The partition in the <b>mFile</b> from which the updated metadata was obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3324464c432fe2920bd7568ad32adcb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUCore::WriteMetadataToMemoryFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MXFMemoryFile **&#160;</td>
          <td class="paramname"><em>destMemFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>mHeaderMetadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_read_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_write_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataDestitionPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataSourcePartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serializes KLV-encoded header metadata to a memory-backed file. Its purpose is to write obtain a linear buffer of serialized metadata of which the size is known, before committing this buffer (i.e., the memory-backed file) to a disk-backed file.</p>
<p><em><b>Note!</em></b> The original disk-backed file is also provided to this function such that dark metadata sets not parsed by the header metadata can also be transferred to the memory-backed file. As such, this function is used in scenario's where existing MXF files are updated with modified metadata.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total header metadata bytes written to the memory-backed file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The base MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">destMemFile</td><td>A pointer that will receive a reference to the memory-backed MXF file structure created during the serialization process. </td></tr>
    <tr><td class="paramname">mHeaderMetadata</td><td>The header metadata that is to be serialized. </td></tr>
    <tr><td class="paramname">metadata_read_position</td><td>The offset in the <b>mFile</b> from where the original header metadata is to be read. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadata_write_position</td><td>The offset in the <b>mFile</b> where the new header metadata is to be written. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadataDestinationPartition</td><td>The partition in the <b>mFile</b> to which the metadata is being written. </td></tr>
    <tr><td class="paramname">metadataSourcePartition</td><td>The partition in the <b>mFile</b> from which the updated metadata was obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 29 2012 16:46:39 for EBU MXF SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
