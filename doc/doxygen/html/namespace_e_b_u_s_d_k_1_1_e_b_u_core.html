<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EBU MXF SDK: EBUSDK::EBUCore Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EBU MXF SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_e_b_u_s_d_k.html">EBUSDK</a></li><li class="navelem"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EBUSDK::EBUCore Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core__1__4"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core__1__4.html">EBUCore_1_4</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af896075fd1d0f08778fdd14fd0b0b8dd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af896075fd1d0f08778fdd14fd0b0b8dd">MetadataKind</a> { <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af896075fd1d0f08778fdd14fd0b0b8dda09c0b3d73333f14708a225f5d47626b8">KLV_ENCODED</a>, 
<a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af896075fd1d0f08778fdd14fd0b0b8ddaf85f408a05989d786087adcfe0f8c18e">DARK</a>, 
<a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af896075fd1d0f08778fdd14fd0b0b8dda88d2d8710479d536bf973a3c0e040dd0">SIDECAR</a>
 }</td></tr>
<tr class="memitem:ae1f2adaa3b0c2230605e627d1cdacda9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#ae1f2adaa3b0c2230605e627d1cdacda9">MetadataOutput</a> { <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#ae1f2adaa3b0c2230605e627d1cdacda9a853e9e1b5713fac0b9f6ef4815d065c1">SERIALIZE_TO_FILE</a>, 
<a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#ae1f2adaa3b0c2230605e627d1cdacda9a286fe62e6731ec8dffc000d745cbb130">OUTPUT_AS_DOM_DOCUMENT</a>, 
<a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#ae1f2adaa3b0c2230605e627d1cdacda9a3b94c8a4a8e7c905aff7633f9a74652b">DONT_SERIALIZE</a>
 }</td></tr>
<tr class="memitem:af093d0eaea6aa94d19e96e55a7504682"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af093d0eaea6aa94d19e96e55a7504682">EBUCoreProcessors</a> { <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af093d0eaea6aa94d19e96e55a7504682ad512e31c6a71feb8f7fba0c85bdf9aad">EBUCORE_1_4</a>, 
<a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af093d0eaea6aa94d19e96e55a7504682a39156f946bd8b9859110a8c131e99b26">EBUCORE_1_5</a>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acd8fa3e0a155ebbda02f53af148d8b3c"><td class="memItemLeft" align="right" valign="top">DLLEXPORT mxfpp::Identification *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#acd8fa3e0a155ebbda02f53af148d8b3c">GenerateEBUCoreIdentificationSet</a> (mxfpp::HeaderMetadata *destination)</td></tr>
<tr class="memitem:a1f2a8c98f4cadb51772403c9d0d3d004"><td class="memItemLeft" align="right" valign="top">DLLEXPORT mxfpp::DMFramework *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a1f2a8c98f4cadb51772403c9d0d3d004">Process</a> (const char *location, mxfpp::HeaderMetadata *destination, mxfpp::Identification *identificationToAppend=NULL)</td></tr>
<tr class="memitem:a554488a1214a91256019f82bc669696a"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a554488a1214a91256019f82bc669696a">FindAndSerializeEBUCore</a> (mxfpp::HeaderMetadata *metadata, const char *outputfilename)</td></tr>
<tr class="memitem:afb7ac19ba0e0094f2463e845134651f5"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#afb7ac19ba0e0094f2463e845134651f5">InsertEBUCoreFramework</a> (mxfpp::HeaderMetadata *header_metadata, const mxfUL *dmSchemeLabel, mxfpp::DMFramework *framework, mxfpp::Identification *identificationToAppend=NULL)</td></tr>
<tr class="memitem:a2ea1e6dd4afcd0897131ee5d75cdeab7"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a2ea1e6dd4afcd0897131ee5d75cdeab7">InsertEBUCoreEventFrameworks</a> (mxfpp::HeaderMetadata *header_metadata, std::vector&lt; <a class="el" href="struct_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_event_input.html">MXFCustomMetadata::EventInput</a> &gt; &amp;eventFrameworks, mxfpp::Identification *identificationToAppend=NULL)</td></tr>
<tr class="memitem:a2a9ad2f99fd9d4daeb6bb24d74225477"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a2a9ad2f99fd9d4daeb6bb24d74225477">RemoveEBUCoreFrameworks</a> (mxfpp::HeaderMetadata *header_metadata)</td></tr>
<tr class="memitem:a79638580d9298bbbee16e486c2c4fab1"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a79638580d9298bbbee16e486c2c4fab1">EmbedEBUCoreMetadata</a> (const char *metadataLocation, const char *mxfLocation, void(*progress_callback)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...), <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af896075fd1d0f08778fdd14fd0b0b8dd">MetadataKind</a> optWaytoWrite=<a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af896075fd1d0f08778fdd14fd0b0b8dda09c0b3d73333f14708a225f5d47626b8">KLV_ENCODED</a>, bool optNoIdentification=false, bool optForceHeader=false)</td></tr>
<tr class="memitem:a61c5515c9f7c3395e7e2b2acb30b903b"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a61c5515c9f7c3395e7e2b2acb30b903b">EmbedEBUCoreMetadata</a> (xercesc::DOMDocument &amp;metadataDocument, const char *metadataLocation, const char *mxfLocation, void(*progress_callback)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...), <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af896075fd1d0f08778fdd14fd0b0b8dd">MetadataKind</a> optWaytoWrite=<a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af896075fd1d0f08778fdd14fd0b0b8dda09c0b3d73333f14708a225f5d47626b8">KLV_ENCODED</a>, bool optNoIdentification=false, bool optForceHeader=false)</td></tr>
<tr class="memitem:afc4716b152cb23f8e69a96d6d753200d"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#afc4716b152cb23f8e69a96d6d753200d">RemoveEBUCoreMetadata</a> (const char *mxfLocation, void(*progress_callback)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...), bool optNoIdentification=false, bool optForceHeader=false)</td></tr>
<tr class="memitem:a61cbbad8a24382405688c7f921f02916"><td class="memItemLeft" align="right" valign="top">DLLEXPORT xercesc::DOMDocument &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a61cbbad8a24382405688c7f921f02916">ExtractEBUCoreMetadata</a> (const char *mxfLocation, void(*progress_callback)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...))</td></tr>
<tr class="memitem:ac4c42dcf884a28a61463f516aed6b0ec"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#ac4c42dcf884a28a61463f516aed6b0ec">ExtractEBUCoreMetadata</a> (const char *mxfLocation, const char *metadataLocation, void(*progress_callback)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...))</td></tr>
<tr class="memitem:a482682a6cd9b8c61745f0736b1510d0f"><td class="memItemLeft" align="right" valign="top">DLLEXPORT <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a482682a6cd9b8c61745f0736b1510d0f">GetDefaultEBUCoreProcessor</a> ()</td></tr>
<tr class="memitem:a3b9da3f374a3cfa73ed112b3077fd7d1"><td class="memItemLeft" align="right" valign="top">DLLEXPORT <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a3b9da3f374a3cfa73ed112b3077fd7d1">GetEBUCoreProcessor</a> (const std::vector&lt; mxfUL &gt; &amp;descriptiveMetadataSchemes)</td></tr>
<tr class="memitem:abf9cec12b4c38a175f689502566659c3"><td class="memItemLeft" align="right" valign="top">DLLEXPORT <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#abf9cec12b4c38a175f689502566659c3">GetEBUCoreProcessor</a> (const <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af093d0eaea6aa94d19e96e55a7504682">EBUCoreProcessors</a> version)</td></tr>
<tr class="memitem:aa80e9e8e2fbb2e91e53ea7759b7abe11"><td class="memItemLeft" align="right" valign="top">DLLEXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#aa80e9e8e2fbb2e91e53ea7759b7abe11">IsSupportedEBUCoreMetadataScheme</a> (const mxfUL *label)</td></tr>
<tr class="memitem:a73d62df66b462a0d72a42e86ef565424"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#a73d62df66b462a0d72a42e86ef565424">EnumerateSupportedEBUCoreDarkSetKeys</a> (std::vector&lt; const mxfKey * &gt; &amp;darkSetKeys)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>EBU MXF SDK namespace for EBUCore-specific functionality. </p>
</div><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="af093d0eaea6aa94d19e96e55a7504682"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af093d0eaea6aa94d19e96e55a7504682">EBUSDK::EBUCore::EBUCoreProcessors</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the ways of serializing metadata in MXF files. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af093d0eaea6aa94d19e96e55a7504682ad512e31c6a71feb8f7fba0c85bdf9aad"></a>EBUCORE_1_4</em>&nbsp;</td><td>
<p><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> v1.4 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af093d0eaea6aa94d19e96e55a7504682a39156f946bd8b9859110a8c131e99b26"></a>EBUCORE_1_5</em>&nbsp;</td><td>
<p><a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> v1.5 </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af896075fd1d0f08778fdd14fd0b0b8dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#af896075fd1d0f08778fdd14fd0b0b8dd">EBUSDK::EBUCore::MetadataKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the ways of serializing metadata in MXF files. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af896075fd1d0f08778fdd14fd0b0b8dda09c0b3d73333f14708a225f5d47626b8"></a>KLV_ENCODED</em>&nbsp;</td><td>
<p>Metadata is encoded using full-featured KLV-encoded metadata element sets (recommended when applicable). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af896075fd1d0f08778fdd14fd0b0b8ddaf85f408a05989d786087adcfe0f8c18e"></a>DARK</em>&nbsp;</td><td>
<p>Metadata is encoded using a single KLV element in which the metadata is written as is. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af896075fd1d0f08778fdd14fd0b0b8dda88d2d8710479d536bf973a3c0e040dd0"></a>SIDECAR</em>&nbsp;</td><td>
<p>A KLV-encoded metadata set is added to the the header metadata with a reference to an external file that contains the actual metadata. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1f2adaa3b0c2230605e627d1cdacda9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html#ae1f2adaa3b0c2230605e627d1cdacda9">EBUSDK::EBUCore::MetadataOutput</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The way in which metadata should be serialized. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae1f2adaa3b0c2230605e627d1cdacda9a853e9e1b5713fac0b9f6ef4815d065c1"></a>SERIALIZE_TO_FILE</em>&nbsp;</td><td>
<p>Serialize to a file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1f2adaa3b0c2230605e627d1cdacda9a286fe62e6731ec8dffc000d745cbb130"></a>OUTPUT_AS_DOM_DOCUMENT</em>&nbsp;</td><td>
<p>Serialize to a new Xerces-C++ XML DOM document object. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1f2adaa3b0c2230605e627d1cdacda9a3b94c8a4a8e7c905aff7633f9a74652b"></a>DONT_SERIALIZE</em>&nbsp;</td><td>
<p>Don't serialize. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a79638580d9298bbbee16e486c2c4fab1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::EBUCore::EmbedEBUCoreMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metadataLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mxfLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...)&#160;</td>
          <td class="paramname"><em>progress_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetadataKind&#160;</td>
          <td class="paramname"><em>optWaytoWrite</em> = <code>KLV_ENCODED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optNoIdentification</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optForceHeader</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Embed <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata into an MXF file. </p>
<dl class="section return"><dt>Returns</dt><dd>Has no return value, but throws an exception when irregularities occur. The caller is informed of any progress by means of the <b>progress_callback</b> argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadataLocation</td><td>The location of the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> XML metadata document file. This file is parsed using the Xerces-C++ XML parser. The document is assumed to conform to the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> XML schema and is not explicitly validated. </td></tr>
    <tr><td class="paramname">mxfLocation</td><td>The location of the MXF file in which to embed the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>A function that is called with updated progress concerning the embedding process. The function is called with the overall progress of the operation in <b>progress</b>, a <b>message</b> that describes the updated status, and the name of the internal <b>function</b> to which the progress update relates (which can be used for debugging purposes). </td></tr>
    <tr><td class="paramname">optWaytoWrite</td><td>Specifies the way in which the provided metadata will be serialized into the MXF file. </td></tr>
    <tr><td class="paramname">optNoIdentification</td><td>When true, forces the SDK not to write an additional MXF metadata Identification set to identify the SDK as source of metadata updates. </td></tr>
    <tr><td class="paramname">optForceHeader</td><td>When true, forces the SDK to write the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata into the header partition, potentially forcing a rewrite of the entire MXF file. In normal operation, the SDK attempts to write the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata into the footer partition, marking the header (and potential body) partitions that contain metadata as open and incomplete. This way only the footer paritition and the (small) partition packs must be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61c5515c9f7c3395e7e2b2acb30b903b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::EBUCore::EmbedEBUCoreMetadata </td>
          <td>(</td>
          <td class="paramtype">xercesc::DOMDocument &amp;&#160;</td>
          <td class="paramname"><em>metadataDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metadataLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mxfLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...)&#160;</td>
          <td class="paramname"><em>progress_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetadataKind&#160;</td>
          <td class="paramname"><em>optWaytoWrite</em> = <code>KLV_ENCODED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optNoIdentification</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optForceHeader</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Embed <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata into an MXF file.<br/>
 This variant of <b>EmbedEBUCoreMetadata</b> accepts a processed XML document, in the form of a Xerces-C++ XML DOM representation. This function can hence be used when the caller wishes to manipulate the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata first, before embedding it in the MXF file and without having to write changes to a physical XML file first. </p>
<dl class="section return"><dt>Returns</dt><dd>Has no return value, but throws an exception when irregularities occur. The caller is informed of any progress by means of the <b>progress_callback</b> argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadataDocument</td><td>A parsed <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> XML metadata document, in the form of the DOM representation generated by the Xerces-C++ XML parser. The document is assumed to conform to the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> XML schema and is not explicitly validated. </td></tr>
    <tr><td class="paramname">metadataLocation</td><td>The logical location of the metadata document, as it will be embedded in the KLV <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata. As in this form the <b>metadataDocument</b> doesn't provide an indication of the physical source location of the document, it is be provided separately here. When irrelevant, an empty string "" can be provided. </td></tr>
    <tr><td class="paramname">mxfLocation</td><td>The location of the MXF file in which to embed the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>A function that is called with updated progress concerning the embedding process. The function is called with the overall progress of the operation in <b>progress</b>, a <b>message</b> that describes the updated status, and the name of the internal <b>function</b> to which the progress update relates (which can be used for debugging purposes). </td></tr>
    <tr><td class="paramname">optWaytoWrite</td><td>Specifies the way in which the provided metadata will be serialized into the MXF file. </td></tr>
    <tr><td class="paramname">optNoIdentification</td><td>When true, forces the SDK not to write an additional MXF metadata Identification set to identify the SDK as source of metadata updates. </td></tr>
    <tr><td class="paramname">optForceHeader</td><td>When true, forces the SDK to write the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata into the header partition, potentially forcing a rewrite of the entire MXF file. In normal operation, the SDK attempts to write the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata into the footer partition, marking the header (and potential body) partitions that contain metadata as open and incomplete. This way only the footer paritition and the (small) partition packs must be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73d62df66b462a0d72a42e86ef565424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::EBUCore::EnumerateSupportedEBUCoreDarkSetKeys </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const mxfKey * &gt; &amp;&#160;</td>
          <td class="paramname"><em>darkSetKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates and adds to the given vector each of the KLV set keys supported by the SDK as keys for <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> dark metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">darkSetKeys</td><td>A references to the vector to which the supported keys will be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61cbbad8a24382405688c7f921f02916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xercesc::DOMDocument &amp; EBUSDK::EBUCore::ExtractEBUCoreMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mxfLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...)&#160;</td>
          <td class="paramname"><em>progress_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata from an MXF file.<br/>
 The SDK consecutively tries to extract the metadata in three ways; from KLV-encoded <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata sets, from a sidecar file referenced by the MXF file's metadata, or as 'dark' metadata from a KLV set identified by the appropriate key.<br/>
 This variant of <b>ExtractEBUCoreMetadata</b> returns a Xerces-C++ XML DOM data structure that can be processed and transformed by the caller, before e.g., being written out to disk. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to a Xerces-C++ XML DOM document representation that conforms to the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> XML schema. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mxfLocation</td><td>The location of the MXF file in which to extract the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>A function that is called with updated progress concerning the embedding process. The function is called with the overall progress of the operation in <b>progress</b>, a <b>message</b> that describes the updated status, and the name of the internal <b>function</b> to which the progress update relates (which can be used for debugging purposes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4c42dcf884a28a61463f516aed6b0ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::EBUCore::ExtractEBUCoreMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mxfLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metadataLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...)&#160;</td>
          <td class="paramname"><em>progress_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata from an MXF file.<br/>
 The SDK consecutively tries to extract the metadata in three ways; from KLV-encoded <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata sets, from a sidecar file referenced by the MXF file's metadata, or as 'dark' metadata from a KLV set identified by the appropriate key.<br/>
 </p>
<dl class="section return"><dt>Returns</dt><dd>Has no return value, but throws an exception when irregularities occur. The caller is informed of any progress by means of the <b>progress_callback</b> argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mxfLocation</td><td>The location of the MXF file in which to extract the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata. </td></tr>
    <tr><td class="paramname">metadataLocation</td><td>The location of the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> XML metadata document file destination. The XML document written conforms to the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> XML schema. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>A function that is called with updated progress concerning the embedding process. The function is called with the overall progress of the operation in <b>progress</b>, a <b>message</b> that describes the updated status, and the name of the internal <b>function</b> to which the progress update relates (which can be used for debugging purposes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a554488a1214a91256019f82bc669696a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DLLEXPORT void EBUSDK::EBUCore::FindAndSerializeEBUCore </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>outputfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function for locating KLV-encoded <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata in the provided header metadata and serializing this metadata to file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadata</td><td>Parsed header metadata structure of the MXF file. </td></tr>
    <tr><td class="paramname">outputfilename</td><td>Location of the file to write the serialized metadata to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd8fa3e0a155ebbda02f53af148d8b3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Identification * EBUSDK::EBUCore::GenerateEBUCoreIdentificationSet </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates an MXF Identification metadata set that can be referred to by new and updated metdata sets in the MXF file.<br/>
 The following information is contained in the set:<br/>
</p>
<ul>
<li>Company Name: "EBU"</li>
<li>Product Name: "EBUCore SDK"</li>
<li>ProductUID: { 0xda, 0xe5, 0x92, 0x18, 0xaf, 0x8d, 0x47, 0xd4, 0xa2, 0x16, 0xb6, 0xc6, 0x48, 0xea, 0x54, 0x8c }</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the generated Identification set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The HeaderMetadata structure to which the Identification set will be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a482682a6cd9b8c61745f0736b1510d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> * EBUSDK::EBUCore::GetDefaultEBUCoreProcessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a newly created instance of the default <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> object. This object represents processing capabilities for the preferred <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> version supported by the SDK.</p>
<dl class="section return"><dt>Returns</dt><dd>An instance of the default <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b9da3f374a3cfa73ed112b3077fd7d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> * EBUSDK::EBUCore::GetEBUCoreProcessor </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; mxfUL &gt; &amp;&#160;</td>
          <td class="paramname"><em>descriptiveMetadataSchemes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a newly created instance of the <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> object for processing capabilities for <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata declared in the given vector of DM Schemes.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> that matches the declared DM Schemes, if any. The first matching <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> is returned, or NULL if no supported <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> DM Scheme is found in the <em>descriptiveMetadataSchemes</em> vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptiveMetadataSchemes</td><td>A vector with DM Scheme Universal Labals as declared in the header metadata of the MXF file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf9cec12b4c38a175f689502566659c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> * EBUSDK::EBUCore::GetEBUCoreProcessor </td>
          <td>(</td>
          <td class="paramtype">const EBUCoreProcessors&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a newly created instance of the <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> object for processing capabilities for the given <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata version.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> that matches the given enumeration value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>The version of <a class="el" href="class_e_b_u_s_d_k_1_1_e_b_u_core_1_1_e_b_u_core_processor.html">EBUCoreProcessor</a> to be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ea1e6dd4afcd0897131ee5d75cdeab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DLLEXPORT void EBUSDK::EBUCore::InsertEBUCoreEventFrameworks </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>header_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; MXFCustomMetadata::EventInput &gt; &amp;&#160;</td>
          <td class="paramname"><em>eventFrameworks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Identification *&#160;</td>
          <td class="paramname"><em>identificationToAppend</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a given list of descriptive metadata frameworks in the provided header metadata structure.<br/>
 This function adds an Event DM track to the MXF timeline, from which the provided <b>eventFrameworks</b> are weakly referenced.<br/>
 Currently, the DM track added is assigned a Track ID <em>10002</em> and is given a Track Name <em>EBU_Core_Parts</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_metadata</td><td>The HeaderMetadata structure to which the framework and timeline elements are added. </td></tr>
    <tr><td class="paramname">eventFrameworks</td><td>The DM frameworks input set to be added to the MXF timeline. The EventInput structure's Start and Duration fields are used to properly place the DM Segment on the timeline. </td></tr>
    <tr><td class="paramname">identificationToAppend</td><td>Optional Identification metadata set that will be referenced from each metadata set created by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb7ac19ba0e0094f2463e845134651f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DLLEXPORT void EBUSDK::EBUCore::InsertEBUCoreFramework </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>header_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mxfUL *&#160;</td>
          <td class="paramname"><em>dmSchemeLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::DMFramework *&#160;</td>
          <td class="paramname"><em>framework</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Identification *&#160;</td>
          <td class="paramname"><em>identificationToAppend</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a given descriptive metadata framework set in the provided header metadata structure.<br/>
 This function first appends the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> DMS scheme label to the metadata Preface set and then adds a static DM track to the MXF timeline, from which the provided <b>framework</b> is referenced.<br/>
 Currently, the DM track added is assigned a Track ID <em>10001</em> and is given a Track Name <em>EBU_Core</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_metadata</td><td>The HeaderMetadata structure to which the framework and timeline elements are added. </td></tr>
    <tr><td class="paramname">framework</td><td>The DM framework set to be added to the MXF timeline. </td></tr>
    <tr><td class="paramname">identificationToAppend</td><td>Optional Identification metadata set that will be referenced from each metadata set created by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa80e9e8e2fbb2e91e53ea7759b7abe11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EBUSDK::EBUCore::IsSupportedEBUCoreMetadataScheme </td>
          <td>(</td>
          <td class="paramtype">const mxfUL *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether the provided KLV label is supported by the SDK as a Descriptive Metadata Scheme label for <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether the label is supported by the SDK. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>The label to be investigaged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f2a8c98f4cadb51772403c9d0d3d004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DLLEXPORT mxfpp::DMFramework* EBUSDK::EBUCore::Process </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Identification *&#160;</td>
          <td class="paramname"><em>identificationToAppend</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata in a file at <b>location</b> and returns the resulting <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> MXF descriptive metadata framework of the type EBUCoreMainFramework.<br/>
 In case the optional Identification set is provided in the <b>identificationToAppend</b> argument, this Identification is referenced from all metadata sets generated during the parsing operation. This allows external applications to track all metadata related to this particular parsing (and possibly subsequent MXF update) operation.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the parsed EBUCoreMainFramework set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>Location of the metadata file. </td></tr>
    <tr><td class="paramname">destination</td><td>The HeaderMetadata structure to which the EBUCoreMainFramework and its descending metadata sets will be added. </td></tr>
    <tr><td class="paramname">identificationToAppend</td><td>Optional Identification metadata set that will be referenced from each parsed metadata set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a9ad2f99fd9d4daeb6bb24d74225477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::EBUCore::RemoveEBUCoreFrameworks </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>header_metadata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> Descriptive Metadata frameworks from the given header metadata structure.<br/>
 This removes <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> frameworks from ant static or event tracks DM tracks on the MXF timeline, identified by the names <em>EBU_Core</em> or _EBU_Core_Parts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_metadata</td><td>The HeaderMetadata structure from which the frameworks are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc4716b152cb23f8e69a96d6d753200d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::EBUCore::RemoveEBUCoreMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mxfLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float progress, ProgressCallbackLevel level, const char *function, const char *msg_format,...)&#160;</td>
          <td class="paramname"><em>progress_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optNoIdentification</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optForceHeader</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata from an MXF file.<br/>
</p>
<dl class="section return"><dt>Returns</dt><dd>Has no return value, but throws an exception when irregularities occur. The caller is informed of any progress by means of the <b>progress_callback</b> argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mxfLocation</td><td>The location of the MXF file from which to remove the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>A function that is called with updated progress concerning the embedding process. The function is called with the overall progress of the operation in <b>progress</b>, a <b>message</b> that describes the updated status, and the name of the internal <b>function</b> to which the progress update relates (which can be used for debugging purposes). </td></tr>
    <tr><td class="paramname">optNoIdentification</td><td>When true, forces the SDK not to write an additional MXF metadata Identification set to identify the SDK as source of metadata updates. </td></tr>
    <tr><td class="paramname">optForceHeader</td><td>When true, forces the SDK to remove the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata from the header partition, potentially forcing a rewrite of the entire MXF file. In normal operation, the SDK attempts to remove the <a class="el" href="namespace_e_b_u_s_d_k_1_1_e_b_u_core.html">EBUCore</a> metadata from the footer partition, marking the header (and potential body) partitions that contain metadata as open and incomplete. This way only the footer paritition and the (small) partition packs must be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 27 2014 12:21:52 for EBU MXF SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
