<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EBU MXF SDK: EBUSDK::MXFCustomMetadata Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EBU MXF SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_e_b_u_s_d_k.html">EBUSDK</a></li><li class="navelem"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html">MXFCustomMetadata</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EBUSDK::MXFCustomMetadata Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_object_modifier.html">ObjectModifier</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_generation_u_i_d_appender.html">GenerationUIDAppender</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_m_x_f_file_dark_serializer.html">MXFFileDarkSerializer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_dark_file_serializer.html">DarkFileSerializer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_event_input.html">EventInput</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb4a23bb781bba2e2a7b78492f6e3e27"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#afb4a23bb781bba2e2a7b78492f6e3e27">BufferIndex</a> (mxfpp::File *mFile, mxfpp::Partition *partition, bmx::ByteArray &amp;index_bytes, uint32_t *index_length)</td></tr>
<tr class="memitem:a80ed4df73609691c24249ddf53ea8a10"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#a80ed4df73609691c24249ddf53ea8a10">WriteMetadataToMemoryFile</a> (mxfpp::File *mFile, MXFMemoryFile **destMemFile, mxfpp::HeaderMetadata *mHeaderMetadata, uint64_t metadata_read_position, uint64_t metadata_write_position, mxfpp::Partition *metadataDestinationPartition, mxfpp::Partition *metadataSourcePartition, std::vector&lt; const mxfKey * &gt; &amp;darkElementKeysToIgnore)</td></tr>
<tr class="memitem:affd9c817d1f4355a0cbc8c72cef5f92d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#affd9c817d1f4355a0cbc8c72cef5f92d">WriteMetadataToFile</a> (mxfpp::File *mFile, mxfpp::HeaderMetadata *mHeaderMetadata, uint64_t metadata_read_position, uint64_t metadata_write_position, bool shiftFileBytesIfNeeded, mxfpp::Partition *metadataDestinationPartition, mxfpp::Partition *metadataSourcePartition, std::vector&lt; const mxfKey * &gt; &amp;darkElementKeysToIgnore)</td></tr>
<tr class="memitem:a72fb6c3ec3b347cb799d772ae539be7a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#a72fb6c3ec3b347cb799d772ae539be7a">WriteDarkMetadataToMemoryFile</a> (mxfpp::File *mFile, MXFMemoryFile **destMemFile, <a class="el" href="class_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_m_x_f_file_dark_serializer.html">MXFFileDarkSerializer</a> &amp;metadata, const mxfKey *darkMetadataSetKey, uint64_t metadata_read_position, uint64_t metadata_write_position, mxfpp::Partition *metadataDestinationPartition, mxfpp::Partition *metadataSourcePartition)</td></tr>
<tr class="memitem:a3f1449ea2e7ad5d49395972384d2a308"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#a3f1449ea2e7ad5d49395972384d2a308">WriteDarkMetadataToFile</a> (mxfpp::File *mFile, <a class="el" href="class_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_m_x_f_file_dark_serializer.html">MXFFileDarkSerializer</a> &amp;metadata, const mxfKey *darkMetadataSetKey, uint64_t metadata_read_position, uint64_t metadata_write_position, bool shiftFileBytesIfNeeded, mxfpp::Partition *metadataDestinationPartition, mxfpp::Partition *metadataSourcePartition)</td></tr>
<tr class="memitem:a0ffc2a04126404c5733cd57f8a1aded4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#a0ffc2a04126404c5733cd57f8a1aded4">RemoveMetadataSetTree</a> (mxfpp::HeaderMetadata *header_metadata, mxfpp::MetadataSet *startSet)</td></tr>
<tr class="memitem:a8b42118c3a2523aafbc81d23e7555208"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#a8b42118c3a2523aafbc81d23e7555208">FindLastPartitionFill</a> (mxfpp::File *mFile, mxfpp::Partition *partition, int64_t *partitionSectionOffset, int64_t *extractedFileSize=NULL)</td></tr>
<tr class="memitem:ae473eadee856c02447c962257113aac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#ae473eadee856c02447c962257113aac8">ShiftBytesInFile</a> (mxfpp::File *mFile, int64_t shiftPosition, int64_t shiftOffset)</td></tr>
<tr class="memitem:ae343e7315da96a00914e05cd0cb35bfa"><td class="memItemLeft" align="right" valign="top">mxfpp::Partition *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#ae343e7315da96a00914e05cd0cb35bfa">FindPreferredMetadataPartition</a> (const std::vector&lt; mxfpp::Partition * &gt; &amp;partitions, mxfpp::Partition **headerPartition, mxfpp::Partition **footerPartition)</td></tr>
<tr class="memitem:a01cb6284c0c0d4570d8e816831181cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#a01cb6284c0c0d4570d8e816831181cc0">AppendDMSLabel</a> (mxfpp::HeaderMetadata *header_metadata, mxfUL scheme_label)</td></tr>
<tr class="memitem:ae68760612386ffdd03db488b898af59d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#ae68760612386ffdd03db488b898af59d">InsertFramework</a> (mxfpp::HeaderMetadata *header_metadata, uint32_t track_id, std::string track_name, mxfpp::DMFramework *framework, <a class="el" href="class_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_object_modifier.html">ObjectModifier</a> *mod=NULL)</td></tr>
<tr class="memitem:a46f886a4d53dc6f8322709071bc7364c"><td class="memItemLeft" align="right" valign="top">mxfRational&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#a46f886a4d53dc6f8322709071bc7364c">FindMaterialPackageEditRate</a> (mxfpp::HeaderMetadata *header_metadata)</td></tr>
<tr class="memitem:ad07dd777e3400cc0c719303bbad0b97c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_b_u_s_d_k_1_1_m_x_f_custom_metadata.html#ad07dd777e3400cc0c719303bbad0b97c">InsertEventFrameworks</a> (mxfpp::HeaderMetadata *header_metadata, uint32_t track_id, std::string track_name, std::vector&lt; <a class="el" href="struct_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_event_input.html">EventInput</a> &gt; &amp;frameworks, <a class="el" href="class_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_object_modifier.html">ObjectModifier</a> *mod=NULL)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>EBU MXF SDK Namespace for generic functionality that deals with custom MXF metadata. </p>
</div><h2>Function Documentation</h2>
<a class="anchor" id="a01cb6284c0c0d4570d8e816831181cc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::MXFCustomMetadata::AppendDMSLabel </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>header_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfUL&#160;</td>
          <td class="paramname"><em>scheme_label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends a descriptive metadata scheme Universal Label to the given header metadata object, where it is written into the Preface metadata set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_metadata</td><td>The header metadata to which to append the DM framework. </td></tr>
    <tr><td class="paramname">scheme_label</td><td>The Universal Label of the descriptive metadata scheme. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb4a23bb781bba2e2a7b78492f6e3e27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUSDK::MXFCustomMetadata::BufferIndex </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bmx::ByteArray &amp;&#160;</td>
          <td class="paramname"><em>index_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>index_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffers the index entries of the given <b>partition</b> in a ByteArray and returns the size of the index entries buffered and the first byte of the header metadata in the given <b>partition</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the location of the first byte of the header metadata in the given <b>partition</b>. This position is location behind the partition pack set and any KLV filler elements that follow it. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>An MXF file structure opened with (at least) read access. </td></tr>
    <tr><td class="paramname">partition</td><td>The partition for which the index entries must be buffered. </td></tr>
    <tr><td class="paramname">index_bytes</td><td>A reference to a pre-allocated ByteArray structure to hold the buffered index bytes. </td></tr>
    <tr><td class="paramname">index_length</td><td>A pointer to an integer that will receive the length of the index bytes buffered when the function returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b42118c3a2523aafbc81d23e7555208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t EBUSDK::MXFCustomMetadata::FindLastPartitionFill </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>partitionSectionOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>extractedFileSize</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the last KLV filler element in the given <b>partition</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte position of the last KLV filler element in the given partition. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The MXF file structure opened with (at least) read access. </td></tr>
    <tr><td class="paramname">partition</td><td>The partition in which to locate the last KLV filler element. </td></tr>
    <tr><td class="paramname">partitionSectionOffset</td><td>Pointer to the integer that receives the byte position from where the last KLV filler was searched for. Depending on the configuration of the <b>partition</b>, this can be immediatelly behind the partition pack, behind the header metadata (if present), or behind the partition's index entries (if present). This can be the same value as returned by this function, but not necessarily in case multiple filler elements are found. </td></tr>
    <tr><td class="paramname">extractedFileSize</td><td>Pointer to the integer that receives the length of the provided MXF file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46f886a4d53dc6f8322709071bc7364c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mxfRational EBUSDK::MXFCustomMetadata::FindMaterialPackageEditRate </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>header_metadata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks throught the material package of the given <b>header_metadata</b> and locates the edit rate most appropriate to the overall package. The edit rate is selected from timeline tracks in the following order: timecode tracks, video tracks or audio tracks. The edit rate of the first of these tracks found is used.</p>
<dl class="section return"><dt>Returns</dt><dd>The edit rate, or a special rational {-1, 0} if no valid value was found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_metadata</td><td>The header metadata from which to select the material package. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae343e7315da96a00914e05cd0cb35bfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mxfpp::Partition* EBUSDK::MXFCustomMetadata::FindPreferredMetadataPartition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; mxfpp::Partition * &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition **&#160;</td>
          <td class="paramname"><em>headerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition **&#160;</td>
          <td class="paramname"><em>footerPartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>From a given set of partitions, locates the partition which has the preferred header metadata. Additionally, also locates the header and footer partition.<br/>
 The preferred metadata is located as follows.</p>
<ul>
<li>If the footer partition is marked as closed and contains header metadata, it is selected.</li>
<li>Else, if the header partition is marked as closed and contains header metadata, it is selected.</li>
<li>Else, if any of the body partitions is marked as closed and contains header metadata, it is selected. The last body partition to match is chosen.</li>
<li>Else, if there are any open partitions that contain metadata, the last of these is selected.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the partition that contains the preferred metadata, or NULL if no applicable partition could be found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partitions</td><td>The list of partitions from which the selection is made, typically all partitions of an MXF file. </td></tr>
    <tr><td class="paramname">headerPartition</td><td>Pointer to variable that will be assigned the header partition of the list. </td></tr>
    <tr><td class="paramname">footerPartition</td><td>Pointer to variable that will be assigned the footer partition of the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad07dd777e3400cc0c719303bbad0b97c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::MXFCustomMetadata::InsertEventFrameworks </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>header_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>track_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>track_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; EventInput &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameworks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectModifier *&#160;</td>
          <td class="paramname"><em>mod</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a given list of descriptive metadata frameworks into the MXF timeline of the provided header metadata.<br/>
 The frameworks are attached to a newly created DM Event Track (identified by the <b>track_id</b> and <b>track_name</b> parameters) in the Material Package of the metadata. The structure built is as follows: [Preface] -&gt; [ContentStorage] -&gt; [Material Package] -&gt; [DM Event Track] -&gt; [Sequence] -&gt; [DMSegment],... -&gt; [<b>frameworks</b>[i]]. The <a class="el" href="struct_e_b_u_s_d_k_1_1_m_x_f_custom_metadata_1_1_event_input.html">EventInput</a> members are used to properly position the created DMSegments on the Event timeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_metadata</td><td>The header metadata to which to append the DM framework. </td></tr>
    <tr><td class="paramname">track_id</td><td>The identifier given to the newly created Event Track. </td></tr>
    <tr><td class="paramname">track_name</td><td>The name given to the newly created Event Track. </td></tr>
    <tr><td class="paramname">frameworks</td><td>A list of frameworks to be attached to series of DM Segments of the Event Track. </td></tr>
    <tr><td class="paramname">mod</td><td>An optional object modifier which updates all metadata objects created by this function, e.g., for unique identification purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae68760612386ffdd03db488b898af59d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::MXFCustomMetadata::InsertFramework </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>header_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>track_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>track_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::DMFramework *&#160;</td>
          <td class="paramname"><em>framework</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectModifier *&#160;</td>
          <td class="paramname"><em>mod</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts the given descriptive metadata framework into the MXF timeline of the provided header metadata.<br/>
 The framework is inserted as the framework for a newly created DM Static Track (identified by the <b>track_id</b> and <b>track_name</b> parameters) in the Material Package of the metadata. The structure built is as follows: [Preface] -&gt; [ContentStorage] -&gt; [Material Package] -&gt; [DM Static Track] -&gt; [Sequence] -&gt; [DMSegment] -&gt; [<b>framework</b>].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_metadata</td><td>The header metadata to which to append the DM framework. </td></tr>
    <tr><td class="paramname">track_id</td><td>The identifier given to the newly created Static Track. </td></tr>
    <tr><td class="paramname">track_name</td><td>The name given to the newly created Static Track. </td></tr>
    <tr><td class="paramname">framework</td><td>The framework attached to DM Segment of the Static Track. </td></tr>
    <tr><td class="paramname">mod</td><td>An optional object modifier which updates all metadata objects created by this function, e.g., for unique identification purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ffc2a04126404c5733cd57f8a1aded4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::MXFCustomMetadata::RemoveMetadataSetTree </td>
          <td>(</td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>header_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::MetadataSet *&#160;</td>
          <td class="paramname"><em>startSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a 'tree' of metadata sets from the given header metadata.<br/>
 The tree removed from the header metadata comprises all metadata sets reachable recursively from the initial set through strong references. Weak references are not followed as they do not imply ownership. </p>

</div>
</div>
<a class="anchor" id="ae473eadee856c02447c962257113aac8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBUSDK::MXFCustomMetadata::ShiftBytesInFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>shiftPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>shiftOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shifts bytes in an MXF file from a given posiition by a given offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">shiftPosition</td><td>The byte position in the file from which the shift operation will take place. </td></tr>
    <tr><td class="paramname">shiftOffset</td><td>The byte offset by how much each file byte must be shifted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f1449ea2e7ad5d49395972384d2a308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUSDK::MXFCustomMetadata::WriteDarkMetadataToFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MXFFileDarkSerializer &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mxfKey *&#160;</td>
          <td class="paramname"><em>darkMetadataSetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_read_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_write_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shiftFileBytesIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataDestinationPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataSourcePartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes dark header metadata to an MXF file.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total header metadata bytes written to the MXF file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The base MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">metadata</td><td>The dark metadata serializer that will write to the memory-backed file. </td></tr>
    <tr><td class="paramname">darkMetadataSetKey</td><td>The key to use as dark metadata KLV packet key. </td></tr>
    <tr><td class="paramname">metadata_read_position</td><td>The offset in the <b>mFile</b> from where the original header metadata is to be read. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadata_write_position</td><td>The offset in the <b>mFile</b> where the new header metadata is to be written. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">shiftFileBytesIfNeeded</td><td>Dictates whether file bytes should be shifted further down the file to accomodate metadata that has grown from what was originally in the file. If <em>false</em>, however, file bytes are written disregarding any previous file content.<br/>
 <em><b>Note!</em></b> Use this parameter with care as incorrect use can corrupt the MXF file. </td></tr>
    <tr><td class="paramname">metadataDestinationPartition</td><td>The partition in the <b>mFile</b> to which the metadata is being written. </td></tr>
    <tr><td class="paramname">metadataSourcePartition</td><td>The partition in the <b>mFile</b> from which the updated metadata was obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72fb6c3ec3b347cb799d772ae539be7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUSDK::MXFCustomMetadata::WriteDarkMetadataToMemoryFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MXFMemoryFile **&#160;</td>
          <td class="paramname"><em>destMemFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MXFFileDarkSerializer &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mxfKey *&#160;</td>
          <td class="paramname"><em>darkMetadataSetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_read_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_write_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataDestinationPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataSourcePartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serializes dark header metadata to a memory-backed file, at the end of original metadata in the <b>metadataSourcePartition</b> in a single KLV element. Its purpose is to write obtain a linear buffer of serialized metadata of which the size is known, before committing this buffer (i.e., the memory-backed file) to a disk-backed file.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total header metadata bytes written to the memory-backed file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The base MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">destMemFile</td><td>A pointer that will receive a reference to the memory-backed MXF file structure created during the serialization process. </td></tr>
    <tr><td class="paramname">metadata</td><td>The dark metadata serializer that will write to the memory-backed file. </td></tr>
    <tr><td class="paramname">darkMetadataSetKey</td><td>The key to use as dark metadata KLV packet key. </td></tr>
    <tr><td class="paramname">metadata_read_position</td><td>The offset in the <b>mFile</b> from where the original header metadata is to be read. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadata_write_position</td><td>The offset in the <b>mFile</b> where the new header metadata is to be written. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadataDestinationPartition</td><td>The partition in the <b>mFile</b> to which the metadata is being written. </td></tr>
    <tr><td class="paramname">metadataSourcePartition</td><td>The partition in the <b>mFile</b> from which the updated metadata was obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affd9c817d1f4355a0cbc8c72cef5f92d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUSDK::MXFCustomMetadata::WriteMetadataToFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>mHeaderMetadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_read_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_write_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shiftFileBytesIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataDestinationPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataSourcePartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const mxfKey * &gt; &amp;&#160;</td>
          <td class="paramname"><em>darkElementKeysToIgnore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes KLV-encoded header metadata to an MXF file.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total header metadata bytes written to the MXF file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The base MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">mHeaderMetadata</td><td>The header metadata that is to be serialized. </td></tr>
    <tr><td class="paramname">metadata_read_position</td><td>The offset in the <b>mFile</b> from where the original header metadata is to be read. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadata_write_position</td><td>The offset in the <b>mFile</b> where the new header metadata is to be written. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">shiftFileBytesIfNeeded</td><td>Dictates whether file bytes should be shifted further down the file to accomodate metadata that has grown from what was originally in the file. If <em>false</em>, however, file bytes are written disregarding any previous file content.<br/>
 <em><b>Note!</em></b> Use this parameter with care as incorrect use can corrupt the MXF file. </td></tr>
    <tr><td class="paramname">metadataDestinationPartition</td><td>The partition in the <b>mFile</b> to which the metadata is being written. </td></tr>
    <tr><td class="paramname">metadataSourcePartition</td><td>The partition in the <b>mFile</b> from which the updated metadata was obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80ed4df73609691c24249ddf53ea8a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t EBUSDK::MXFCustomMetadata::WriteMetadataToMemoryFile </td>
          <td>(</td>
          <td class="paramtype">mxfpp::File *&#160;</td>
          <td class="paramname"><em>mFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MXFMemoryFile **&#160;</td>
          <td class="paramname"><em>destMemFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::HeaderMetadata *&#160;</td>
          <td class="paramname"><em>mHeaderMetadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_read_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>metadata_write_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataDestinationPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxfpp::Partition *&#160;</td>
          <td class="paramname"><em>metadataSourcePartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const mxfKey * &gt; &amp;&#160;</td>
          <td class="paramname"><em>darkElementKeysToIgnore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serializes KLV-encoded header metadata to a memory-backed file. Its purpose is to write obtain a linear buffer of serialized metadata of which the size is known, before committing this buffer (i.e., the memory-backed file) to a disk-backed file.</p>
<p><em><b>Note!</em></b> The original disk-backed file is also provided to this function such that dark metadata sets not parsed by the header metadata can also be transferred to the memory-backed file. As such, this function is used in scenario's where existing MXF files are updated with modified metadata.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total header metadata bytes written to the memory-backed file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mFile</td><td>The base MXF file structure opened with read/write access. </td></tr>
    <tr><td class="paramname">destMemFile</td><td>A pointer that will receive a reference to the memory-backed MXF file structure created during the serialization process. </td></tr>
    <tr><td class="paramname">mHeaderMetadata</td><td>The header metadata that is to be serialized. </td></tr>
    <tr><td class="paramname">metadata_read_position</td><td>The offset in the <b>mFile</b> from where the original header metadata is to be read. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadata_write_position</td><td>The offset in the <b>mFile</b> where the new header metadata is to be written. This is the actual starting position of the metadata, beyond any preceeding KLV Filler elements. </td></tr>
    <tr><td class="paramname">metadataDestinationPartition</td><td>The partition in the <b>mFile</b> to which the metadata is being written. </td></tr>
    <tr><td class="paramname">metadataSourcePartition</td><td>The partition in the <b>mFile</b> from which the updated metadata was obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 6 2012 11:43:54 for EBU MXF SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
